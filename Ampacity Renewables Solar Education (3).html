<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ampacity Renewables - Solar Education</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
    
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      overflow: hidden; 
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; 
      background: linear-gradient(180deg, #0a1628 0%, #1a2744 100%); 
      color: #e2e8f0; 
      height: 100vh;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }
    #canvas-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
    canvas { display: block; cursor: grab; }
    canvas:active { cursor: grabbing; }
    
    /* Professional vignette overlay */
    .vignette-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      z-index: 2;
      background: radial-gradient(ellipse at center, transparent 40%, rgba(10,22,40,0.4) 100%);
    }
    
    /* Subtle scan line effect for tech feel */
    .scanlines {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      z-index: 3;
      background: repeating-linear-gradient(
        0deg,
        transparent,
        transparent 2px,
        rgba(0,0,0,0.03) 2px,
        rgba(0,0,0,0.03) 4px
      );
      opacity: 0.5;
    }
    
    /* ===== HEADER / PROGRESS TRACKER ===== */
    .header-bar {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 70px;
      background: linear-gradient(180deg, rgba(10,22,40,0.98) 0%, rgba(10,22,40,0.9) 100%);
      border-bottom: 1px solid rgba(56,189,248,0.15);
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0 30px;
    }
    
    .logo-section {
      position: absolute;
      left: 30px;
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .logo-icon {
      width: 52px;
      height: 52px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 10px;
      overflow: hidden;
      box-shadow: 0 0 20px rgba(255,20,147,0.6), 0 0 40px rgba(255,20,147,0.3), inset 0 0 0 1px rgba(255,20,147,0.3);
      border: 1px solid rgba(255,20,147,0.4);
    }
    .logo-icon img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    .logo-text {
      font-size: 20px;
      font-weight: 700;
      color: #fff;
      letter-spacing: 0.5px;
    }
    .logo-subtitle {
      font-size: 11px;
      color: #ff69b4;
      font-weight: 600;
      letter-spacing: 2px;
      text-transform: uppercase;
    }
    
    .progress-tracker {
      display: flex;
      align-items: center;
      gap: 4px;
      background: rgba(30,41,59,0.6);
      padding: 6px 8px;
      border-radius: 40px;
      border: 1px solid rgba(56,189,248,0.1);
    }
    .step {
      display: flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
      padding: 8px 14px;
      border-radius: 25px;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      border: 1px solid transparent;
      position: relative;
      overflow: hidden;
    }
    .step::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, rgba(56,189,248,0.15), transparent);
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    .step:hover::before { opacity: 1; }
    .step:hover { 
      background: rgba(56,189,248,0.1);
      transform: translateY(-1px);
    }
    .step.active { 
      background: linear-gradient(135deg, rgba(255,20,147,0.2), rgba(255,105,180,0.1)); 
      border-color: rgba(255,20,147,0.4);
      box-shadow: 0 4px 15px rgba(255,20,147,0.2);
    }
    .step-number { 
      width: 26px; 
      height: 26px; 
      background: #1e293b; 
      border-radius: 50%; 
      display: flex; 
      align-items: center; 
      justify-content: center; 
      font-weight: 600; 
      font-size: 12px;
      transition: all 0.25s;
    }
    .step.active .step-number { 
      background: linear-gradient(135deg, #ff1493, #ff69b4); 
      color: #fff;
    }
    .step-text { font-size: 13px; font-weight: 500; color: #94a3b8; }
    .step.active .step-text { color: #fff; }
    
    .header-controls {
      display: flex;
      gap: 8px;
    }
    .header-btn {
      background: rgba(30,41,59,0.8);
      border: 1px solid rgba(56,189,248,0.2);
      color: #94a3b8;
      padding: 8px 16px;
      border-radius: 8px;
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      overflow: hidden;
    }
    .header-btn::after {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, rgba(56,189,248,0.2), transparent);
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    .header-btn:hover::after { opacity: 1; }
    .header-btn:hover { 
      background: rgba(56,189,248,0.15); 
      color: #fff;
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(56,189,248,0.15);
    }
    .header-btn.active { 
      background: linear-gradient(135deg, #ff1493, #ff69b4); 
      border-color: #ff1493; 
      color: #fff;
      box-shadow: 0 4px 15px rgba(255,20,147,0.3);
    }
    
    /* ===== LEFT PANEL - EDUCATION CONTENT ===== */
    .ui-panel { 
      position: absolute; 
      top: 90px; 
      left: 20px; 
      width: 360px; 
      background: rgba(15,23,42,0.95);
      backdrop-filter: blur(20px);
      border-radius: 16px; 
      z-index: 100; 
      border: 1px solid rgba(56,189,248,0.1);
      max-height: calc(100vh - 110px); 
      overflow: hidden; 
      display: flex; 
      flex-direction: column;
      box-shadow: 
        0 20px 40px rgba(0,0,0,0.3),
        0 0 0 1px rgba(56,189,248,0.05) inset,
        0 1px 0 rgba(255,255,255,0.05) inset;
      transition: box-shadow 0.3s ease, transform 0.3s ease, opacity 0.3s ease;
    }
    .ui-panel:hover {
      box-shadow: 
        0 25px 50px rgba(0,0,0,0.35),
        0 0 0 1px rgba(56,189,248,0.1) inset,
        0 1px 0 rgba(255,255,255,0.05) inset;
    }
    .panel-header { 
      padding: 20px 24px 16px; 
      border-bottom: 1px solid rgba(56,189,248,0.1);
      background: rgba(30,41,59,0.3);
      position: relative;
    }
    .panel-hide-btn {
      position: absolute;
      top: 12px;
      right: 12px;
      width: 28px;
      height: 28px;
      background: rgba(56,189,248,0.15);
      border: 1px solid rgba(56,189,248,0.3);
      border-radius: 4px;
      color: #38bdf8;
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
    }
    .panel-hide-btn:hover {
      background: rgba(56,189,248,0.3);
      color: #fff;
    }
    .panel-show-btn {
      position: fixed;
      left: 0;
      top: 50%;
      transform: translateY(-50%);
      width: 32px;
      height: 60px;
      background: linear-gradient(135deg, rgba(15,35,50,0.95), rgba(10,25,40,0.98));
      border: 1px solid rgba(56,189,248,0.3);
      border-left: none;
      border-radius: 0 8px 8px 0;
      color: #38bdf8;
      font-size: 14px;
      cursor: pointer;
      z-index: 500;
      display: none;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
      box-shadow: 4px 0 15px rgba(0,0,0,0.3);
    }
    .panel-show-btn:hover {
      background: linear-gradient(135deg, rgba(56,189,248,0.3), rgba(30,60,80,0.95));
      color: #fff;
      width: 40px;
    }
    .ui-panel.hidden {
      transform: translateX(-100%);
      opacity: 0;
      pointer-events: none;
    }
    .panel-title h2 { 
      font-size: 18px; 
      color: #fff; 
      margin-bottom: 4px; 
      font-weight: 600;
    }
    .panel-subtitle { 
      font-size: 12px; 
      color: #ff1493;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .panel-body { 
      padding: 20px 24px; 
      overflow-y: auto; 
      color: #cbd5e1; 
      line-height: 1.65;
      flex: 1;
    }
    .panel-body::-webkit-scrollbar { width: 6px; }
    .panel-body::-webkit-scrollbar-track { background: transparent; }
    .panel-body::-webkit-scrollbar-thumb { background: rgba(56,189,248,0.3); border-radius: 3px; }
    
    .info-box { 
      background: rgba(30,41,59,0.5); 
      padding: 14px 16px; 
      border-radius: 10px; 
      border-left: 3px solid #38bdf8; 
      margin-bottom: 14px;
      transition: all 0.3s ease;
    }
    .info-box:hover {
      background: rgba(30,41,59,0.7);
      transform: translateX(2px);
    }
    .info-box h3 { 
      font-size: 13px; 
      margin-bottom: 8px; 
      color: #38bdf8;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .info-box p { font-size: 13px; color: #94a3b8; margin-bottom: 6px; line-height: 1.5; }
    .info-box p:last-child { margin-bottom: 0; }
    
    .stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px; }
    .stat-card { 
      background: linear-gradient(135deg, rgba(56,189,248,0.1), rgba(56,189,248,0.05)); 
      padding: 14px 12px; 
      border-radius: 10px; 
      text-align: center;
      border: 1px solid rgba(56,189,248,0.1);
      transition: all 0.3s ease;
    }
    .stat-card:hover {
      background: linear-gradient(135deg, rgba(56,189,248,0.15), rgba(56,189,248,0.08));
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(56,189,248,0.1);
    }
    .stat-value { font-size: 20px; font-weight: 700; color: #ff1493; }
    .stat-label { font-size: 11px; color: #64748b; margin-top: 4px; text-transform: uppercase; letter-spacing: 0.5px; }
    
    /* ===== RIGHT PANEL - QUICK STATS ===== */
    .energy-dashboard { 
      position: absolute; 
      top: 90px; 
      right: 20px; 
      width: 260px; 
      background: rgba(15,23,42,0.95);
      backdrop-filter: blur(20px);
      border-radius: 16px; 
      padding: 20px; 
      z-index: 100; 
      border: 1px solid rgba(56,189,248,0.1);
      box-shadow: 
        0 20px 40px rgba(0,0,0,0.3),
        0 0 0 1px rgba(56,189,248,0.05) inset,
        0 1px 0 rgba(255,255,255,0.05) inset;
      transition: box-shadow 0.3s ease;
    }
    .energy-dashboard:hover {
      box-shadow: 
        0 25px 50px rgba(0,0,0,0.35),
        0 0 0 1px rgba(56,189,248,0.1) inset,
        0 1px 0 rgba(255,255,255,0.05) inset;
    }
    .dashboard-title { 
      font-size: 11px; 
      color: #94a3b8; 
      font-weight: 600; 
      margin-bottom: 16px;
      text-transform: uppercase;
      letter-spacing: 2px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .step-indicator {
      width: 8px;
      height: 8px;
      background: #ff1493;
      border-radius: 50%;
      box-shadow: 0 0 8px rgba(255,20,147,0.6);
      animation: pulse-dot 2s ease-in-out infinite;
    }
    @keyframes pulse-dot {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.7; transform: scale(1.2); }
    }
    
    /* ===== BOTTOM CONTROLS ===== */
    .controls { 
      position: absolute; 
      bottom: 25px; 
      left: 50%; 
      transform: translateX(-50%); 
      display: flex; 
      gap: 10px; 
      z-index: 100;
      background: rgba(15,23,42,0.9);
      padding: 10px 16px;
      border-radius: 14px;
      border: 1px solid rgba(56,189,248,0.1);
    }
    .control-btn { 
      background: rgba(30,41,59,0.8); 
      border: 1px solid rgba(56,189,248,0.2); 
      color: #94a3b8; 
      padding: 10px 20px; 
      border-radius: 10px; 
      font-size: 13px; 
      font-weight: 500; 
      cursor: pointer; 
      transition: all 0.2s; 
    }
    .control-btn:hover { background: rgba(56,189,248,0.15); color: #fff; border-color: rgba(56,189,248,0.3); }
    .control-btn.active-view { background: linear-gradient(135deg, #ff1493, #ff69b4); border-color: #ff1493; color: #fff; }
    
    .camera-hint { 
      position: absolute; 
      bottom: 85px; 
      left: 50%; 
      transform: translateX(-50%); 
      background: rgba(15,23,42,0.8); 
      padding: 8px 16px; 
      border-radius: 20px; 
      font-size: 11px; 
      color: #64748b; 
      z-index: 100;
      border: 1px solid rgba(56,189,248,0.1);
    }
    
    /* ===== SIGNATURE FOOTER ===== */
    
    /* ===== LOADING SCREEN ===== */
    .loading { 
      position: fixed; 
      top: 0; 
      left: 0; 
      width: 100%; 
      height: 100%; 
      background: linear-gradient(180deg, #0a1628 0%, #1a2744 100%); 
      display: flex; 
      flex-direction: column; 
      align-items: center; 
      justify-content: center; 
      z-index: 10000; 
    }
    .loader { 
      width: 50px; 
      height: 50px; 
      border: 3px solid rgba(56,189,248,0.2); 
      border-top-color: #ff1493; 
      border-radius: 50%; 
      animation: spin 1s linear infinite; 
      margin-bottom: 20px; 
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    
    /* ===== VIEW CLOSE-UP BUTTONS ===== */
    .view-demo-btn {
      display: inline-block;
      background: linear-gradient(135deg, #ff1493, #ff69b4);
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 10px;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 4px 15px rgba(255,20,147,0.3);
      transition: all 0.2s;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .view-demo-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(255,20,147,0.4);
    }
    .view-demo-btn.green {
      background: linear-gradient(135deg, #10b981, #34d399);
      box-shadow: 0 4px 15px rgba(16,185,129,0.3);
    }
    .view-demo-btn.green:hover {
      box-shadow: 0 6px 20px rgba(16,185,129,0.4);
    }
    
    /* ===== HIGHLIGHT LEGEND ===== */
    .legend-box {
      background: rgba(20,30,50,0.9);
      border: 1px solid rgba(56,189,248,0.2);
      border-radius: 10px;
      padding: 12px 14px;
      margin-top: 12px;
    }
    .legend-title {
      font-size: 11px;
      color: #38bdf8;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      color: #94a3b8;
      margin-bottom: 6px;
    }
    .legend-item:last-child { margin-bottom: 0; }
    .legend-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
    }
    .legend-line {
      width: 16px;
      height: 3px;
      border-radius: 2px;
    }
    
    /* ===== QUIZ STYLES ===== */
    .quiz-btn {
      background: linear-gradient(135deg, #10b981, #059669) !important;
      border-color: #10b981 !important;
      font-weight: 800 !important;
      letter-spacing: 0.3px;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
    }
    .quiz-btn:hover {
      background: linear-gradient(135deg, #059669, #047857) !important;
      box-shadow: 0 4px 15px rgba(16, 185, 129, 0.4) !important;
    }
    
    /* Feature buttons */
    .feature-btn {
      background: linear-gradient(135deg, #8b5cf6, #7c3aed) !important;
      border-color: #8b5cf6 !important;
      position: relative;
    }
    .feature-btn:hover {
      background: linear-gradient(135deg, #7c3aed, #6d28d9) !important;
      box-shadow: 0 4px 15px rgba(139, 92, 246, 0.4) !important;
    }
    .feature-btn.active {
      background: linear-gradient(135deg, #f59e0b, #d97706) !important;
      border-color: #f59e0b !important;
      box-shadow: 0 0 20px rgba(245, 158, 11, 0.5) !important;
    }
    
    /* Tooltip bubbles */
    .tooltip-bubble {
      position: absolute;
      bottom: calc(100% + 15px);
      left: 50%;
      transform: translateX(-50%) scale(0.9);
      background: linear-gradient(145deg, #1e293b, #0f172a);
      border: 2px solid #38bdf8;
      border-radius: 12px;
      padding: 15px 18px;
      width: 260px;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
      z-index: 1000;
      box-shadow: 0 10px 40px rgba(0,0,0,0.5), 0 0 20px rgba(56, 189, 248, 0.2);
    }
    .tooltip-bubble.show {
      opacity: 1;
      visibility: visible;
      transform: translateX(-50%) scale(1);
    }
    .tooltip-bubble::after {
      content: '';
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      border: 10px solid transparent;
      border-top-color: #38bdf8;
    }
    .tooltip-bubble h4 {
      color: #ff1493;
      margin: 0 0 8px 0;
      font-size: 15px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .tooltip-bubble p {
      color: #cbd5e1;
      margin: 0 0 12px 0;
      font-size: 13px;
      line-height: 1.5;
    }
    .tooltip-bubble .tooltip-actions {
      display: flex;
      gap: 8px;
    }
    .tooltip-bubble button {
      flex: 1;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }
    .tooltip-bubble .tooltip-start {
      background: linear-gradient(135deg, #10b981, #059669);
      border: none;
      color: white;
    }
    .tooltip-bubble .tooltip-start:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);
    }
    .tooltip-bubble .tooltip-close {
      background: transparent;
      border: 1px solid #475569;
      color: #94a3b8;
    }
    .tooltip-bubble .tooltip-close:hover {
      border-color: #64748b;
      color: #cbd5e1;
    }
    
    .quiz-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 10, 20, 0.95);
      z-index: 10000;
      justify-content: center;
      align-items: center;
      animation: fadeIn 0.3s ease;
    }
    .quiz-modal.active {
      display: flex;
    }
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    .quiz-container {
      background: linear-gradient(145deg, #0f172a, #1e293b);
      border: 2px solid #38bdf8;
      border-radius: 20px;
      width: 90%;
      max-width: 700px;
      max-height: 85vh;
      overflow-y: auto;
      box-shadow: 0 25px 80px rgba(56, 189, 248, 0.3), 0 0 100px rgba(255, 20, 147, 0.1);
      position: relative;
    }
    
    .quiz-header {
      background: linear-gradient(135deg, #1e293b, #334155);
      padding: 25px 30px;
      border-bottom: 2px solid #38bdf8;
      border-radius: 18px 18px 0 0;
      text-align: center;
      position: relative;
    }
    .quiz-header h2 {
      color: #ff1493;
      margin: 0 0 8px 0;
      font-size: 28px;
    }
    .quiz-header p {
      color: #94a3b8;
      margin: 0;
      font-size: 14px;
    }
    .quiz-close {
      position: absolute;
      top: 15px;
      right: 20px;
      background: rgba(239, 68, 68, 0.2);
      border: 2px solid #ef4444;
      color: #ef4444;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 18px;
      transition: all 0.2s;
    }
    .quiz-close:hover {
      background: #ef4444;
      color: white;
    }
    
    .quiz-progress {
      height: 6px;
      background: #1e293b;
    }
    .quiz-progress-bar {
      height: 100%;
      background: linear-gradient(90deg, #ff1493, #38bdf8);
      width: 10%;
      transition: width 0.4s ease;
    }
    
    .quiz-content {
      padding: 30px;
    }
    
    .quiz-question {
      color: #f1f5f9;
      font-size: 20px;
      font-weight: 600;
      margin-bottom: 25px;
      line-height: 1.5;
    }
    .quiz-question span {
      color: #38bdf8;
      font-size: 14px;
      display: block;
      margin-bottom: 8px;
    }
    
    .quiz-options {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    
    .quiz-option {
      background: linear-gradient(135deg, #1e293b, #0f172a);
      border: 2px solid #334155;
      border-radius: 12px;
      padding: 16px 20px;
      color: #e2e8f0;
      font-size: 16px;
      cursor: pointer;
      transition: all 0.2s;
      text-align: left;
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .quiz-option:hover {
      border-color: #38bdf8;
      background: linear-gradient(135deg, #1e3a5f, #0f172a);
      transform: translateX(5px);
    }
    .quiz-option.selected {
      border-color: #38bdf8;
      background: linear-gradient(135deg, #0c4a6e, #1e293b);
    }
    .quiz-option.correct {
      border-color: #10b981;
      background: linear-gradient(135deg, #064e3b, #1e293b);
    }
    .quiz-option.incorrect {
      border-color: #ef4444;
      background: linear-gradient(135deg, #7f1d1d, #1e293b);
    }
    .quiz-option .option-letter {
      width: 32px;
      height: 32px;
      background: #334155;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      color: #38bdf8;
      flex-shrink: 0;
    }
    .quiz-option.correct .option-letter {
      background: #10b981;
      color: white;
    }
    .quiz-option.incorrect .option-letter {
      background: #ef4444;
      color: white;
    }
    
    .quiz-feedback {
      margin-top: 20px;
      padding: 15px 20px;
      border-radius: 10px;
      font-size: 15px;
      display: none;
    }
    .quiz-feedback.correct {
      display: block;
      background: rgba(16, 185, 129, 0.15);
      border: 1px solid #10b981;
      color: #10b981;
    }
    .quiz-feedback.incorrect {
      display: block;
      background: rgba(239, 68, 68, 0.15);
      border: 1px solid #ef4444;
      color: #fca5a5;
    }
    
    .quiz-footer {
      padding: 20px 30px;
      background: linear-gradient(135deg, #1e293b, #0f172a);
      border-top: 1px solid #334155;
      border-radius: 0 0 18px 18px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .quiz-score {
      color: #94a3b8;
      font-size: 14px;
    }
    .quiz-btn-action {
      background: linear-gradient(135deg, #ff1493, #db2777);
      border: none;
      color: white;
      padding: 12px 28px;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }
    .quiz-btn-action:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 20px rgba(255, 20, 147, 0.4);
    }
    .quiz-btn-action:disabled {
      background: #334155;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    
    .quiz-results {
      text-align: center;
      padding: 20px;
    }
    .quiz-results h3 {
      font-size: 32px;
      margin-bottom: 10px;
    }
    .quiz-results .score-big {
      font-size: 72px;
      font-weight: bold;
      background: linear-gradient(135deg, #ff1493, #38bdf8);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin: 20px 0;
    }
    .quiz-results .score-text {
      color: #94a3b8;
      font-size: 18px;
      margin-bottom: 30px;
    }
    .quiz-results .grade {
      font-size: 24px;
      padding: 10px 30px;
      border-radius: 50px;
      display: inline-block;
      margin-bottom: 20px;
    }
    .quiz-results .grade.excellent {
      background: linear-gradient(135deg, #10b981, #059669);
      color: white;
    }
    .quiz-results .grade.good {
      background: linear-gradient(135deg, #38bdf8, #0284c7);
      color: white;
    }
    .quiz-results .grade.okay {
      background: linear-gradient(135deg, #f59e0b, #d97706);
      color: white;
    }
    .quiz-results .grade.needs-work {
      background: linear-gradient(135deg, #ef4444, #dc2626);
      color: white;
    }
  </style>
</head>
<body>
  <div class="loading" id="loading">
    <div class="loader"></div>
    <h2 style="color:#fff; font-weight:600;">Loading Solar Education</h2>
    <p style="color:#64748b; margin-top:8px; font-size:14px;">Preparing 3D environment...</p>
  </div>
  
  <div id="canvas-container"></div>
  <div class="vignette-overlay"></div>
  <div class="scanlines"></div>
  
  <!-- ===== HEADER BAR ===== -->
  <header class="header-bar">
    <div class="logo-section">
      <div class="logo-icon">
        <img src="data:image/jpeg;base64,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" alt="Ampacity Logo">
      </div>
      <div>
        <div class="logo-text">Ampacity Renewables</div>
        <div class="logo-subtitle">Solar Education</div>
      </div>
    </div>
    
    <nav class="progress-tracker">
      <div class="step active" data-step="module"><div class="step-number">1</div><div class="step-text">Module</div></div>
      <div class="step" data-step="string"><div class="step-number">2</div><div class="step-text">String</div></div>
      <div class="step" data-step="tracker"><div class="step-number">3</div><div class="step-text">Tracker</div></div>
      <div class="step" data-step="combiner"><div class="step-number">4</div><div class="step-text">Combiner</div></div>
      <div class="step" data-step="cabling"><div class="step-number">5</div><div class="step-text">Cabling</div></div>
      <div class="step" data-step="inverter"><div class="step-number">6</div><div class="step-text">Inverter</div></div>
    </nav>
    
  </header>
  
  <!-- ===== LEFT PANEL ===== -->
  <div class="ui-panel" id="left-panel">
    <div class="panel-header">
      <button class="panel-hide-btn" id="panelHideBtn" onclick="toggleLeftPanel()" title="Hide Panel">
        <span id="panelHideIcon">‚óÄ</span>
      </button>
      <div class="panel-title"><h2 id="title">Solar Panel Module</h2></div>
      <div class="panel-subtitle" id="subtitle">Step 1: The Basic Building Block</div>
    </div>
    <div class="panel-body" id="content"></div>
  </div>
  
  <!-- Show Panel Button (when hidden) -->
  <button class="panel-show-btn" id="panelShowBtn" onclick="toggleLeftPanel()" title="Show Panel">‚ñ∂</button>
  
  <!-- ===== RIGHT PANEL ===== -->
  <div class="energy-dashboard">
    <div class="dashboard-title"><span class="step-indicator"></span>Learning Path</div>
    <div id="stats"></div>
  </div>
  
  <!-- Detailed Component Panel - slides in from right -->
  <div id="detail-panel" style="display:none; position:fixed; top:0; right:0; width:480px; height:100%; background:rgba(15,35,45,0.98); z-index:1000; overflow-y:auto; box-shadow:-5px 0 30px rgba(0,0,0,0.5); transform:translateX(100%); transition:transform 0.3s ease;">
    <div style="position:sticky; top:0; background:rgba(15,35,45,1); padding:20px; border-bottom:1px solid rgba(255,255,255,0.1); z-index:10;">
      <button onclick="closeDetailPanel()" style="position:absolute; top:15px; right:15px; background:transparent; color:#888; border:none; font-size:28px; cursor:pointer; padding:5px;">&times;</button>
      <h2 id="detail-title" style="margin:0 0 5px 0; color:#fff; font-size:1.4em; font-weight:600; text-transform:uppercase; letter-spacing:1px;"></h2>
      <div id="detail-category" style="color:#4aa; font-size:0.8em; text-transform:uppercase; letter-spacing:2px;"></div>
    </div>
    
    <div style="padding:20px;">
      <!-- Main Image -->
      <div id="detail-image" style="width:100%; height:200px; background:#1a3a45; border-radius:4px; margin-bottom:20px; display:flex; align-items:center; justify-content:center; overflow:hidden;">
        <div id="detail-image-placeholder" style="color:#4aa; font-size:0.9em;">Component Diagram</div>
      </div>
      
      <!-- Description -->
      <div style="margin-bottom:25px;">
        <h3 style="color:#4aa; font-size:0.85em; text-transform:uppercase; letter-spacing:1px; margin:0 0 10px 0; padding-bottom:8px; border-bottom:1px solid rgba(255,255,255,0.1);">Overview</h3>
        <p id="detail-desc" style="color:#ccc; line-height:1.7; margin:0; font-size:0.9em;"></p>
      </div>
      
      <!-- Key Specifications -->
      <div style="margin-bottom:25px;">
        <h3 style="color:#4aa; font-size:0.85em; text-transform:uppercase; letter-spacing:1px; margin:0 0 15px 0; padding-bottom:8px; border-bottom:1px solid rgba(255,255,255,0.1);">Technical Specifications</h3>
        <div id="detail-specs" style="display:grid; grid-template-columns:1fr 1fr; gap:10px;"></div>
      </div>
      
      <!-- Additional Images -->
      <div style="margin-bottom:25px;">
        <h3 style="color:#4aa; font-size:0.85em; text-transform:uppercase; letter-spacing:1px; margin:0 0 15px 0; padding-bottom:8px; border-bottom:1px solid rgba(255,255,255,0.1);">Installation Details</h3>
        <div id="detail-gallery" style="display:grid; grid-template-columns:1fr 1fr; gap:10px;"></div>
      </div>
      
      <!-- Did You Know Section -->
      <div id="detail-facts" style="background:rgba(74,170,170,0.1); border-left:3px solid #4aa; padding:15px; border-radius:0 4px 4px 0; margin-bottom:20px;">
        <h4 style="color:#4aa; font-size:0.8em; text-transform:uppercase; letter-spacing:1px; margin:0 0 8px 0;">Did You Know?</h4>
        <p id="detail-fact-text" style="color:#aaa; font-size:0.85em; line-height:1.6; margin:0;"></p>
      </div>
      
      <!-- Related Components -->
      <div>
        <h3 style="color:#4aa; font-size:0.85em; text-transform:uppercase; letter-spacing:1px; margin:0 0 15px 0; padding-bottom:8px; border-bottom:1px solid rgba(255,255,255,0.1);">Related Components</h3>
        <div id="detail-related" style="display:flex; gap:10px; flex-wrap:wrap;"></div>
      </div>
    </div>
  </div>
  
  <!-- Overlay for detail panel -->
  <div id="detail-overlay" onclick="closeDetailPanel()" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.5); z-index:999;"></div>
  
  <!-- Label container for 2D labels that follow 3D markers -->
  <div id="labels-container" style="position:fixed; top:0; left:0; width:100%; height:100%; pointer-events:none; z-index:50;"></div>
  
  <button id="toggle-markers" onclick="toggleMarkers()" style="position:fixed; top:20px; right:20px; background:rgba(15,35,45,0.95); color:#fff; border:1px solid #4aa; padding:10px 18px; border-radius:4px; cursor:pointer; font-weight:500; font-size:0.9em; z-index:100; box-shadow:0 3px 10px rgba(0,0,0,0.3);">
    Hide Labels
  </button>
  
  <div class="controls">
    <button class="control-btn" id="prev">‚Üê Prev Step</button>
    <button class="control-btn" id="next">Next Step ‚Üí</button>
    <button class="control-btn" id="topview">Top View</button>
    <button class="control-btn" id="reset">Reset View</button>
    <div style="position: relative; display: inline-block;">
      <button class="control-btn feature-btn" id="dayCycleBtn">üåÖ Sun Tracking</button>
      <div class="tooltip-bubble" id="sunTooltip">
        <h4>‚òÄÔ∏è Sun Tracking Mode</h4>
        <p>Watch the sun move across the sky! The solar trackers will <strong>automatically rotate</strong> to follow the sun, just like real single-axis tracking systems. Lighting changes from dawn to dusk.</p>
        <div class="tooltip-actions">
          <button class="tooltip-close" onclick="closeSunTooltip()">Close</button>
          <button class="tooltip-start" onclick="startSunTracking()">‚ñ∂ Start</button>
        </div>
      </div>
    </div>
    <div style="position: relative; display: inline-block;">
      <button class="control-btn feature-btn" id="electricFlowBtn">‚ö° Power Flow</button>
      <div class="tooltip-bubble" id="powerTooltip">
        <h4>‚ö° Power Flow Animation</h4>
        <p>See electricity flow through the solar farm! <strong style="color:#00ffff;">Cyan particles</strong> show DC power from panels, <strong style="color:#ffaa00;">orange particles</strong> show AC power going to the grid.</p>
        <div class="tooltip-actions">
          <button class="tooltip-close" onclick="closePowerTooltip()">Close</button>
          <button class="tooltip-start" onclick="startPowerFlow()">‚ñ∂ Start</button>
        </div>
      </div>
    </div>
    <button class="control-btn quiz-btn" id="quizBtn">üìù Take Quiz</button>
  </div>
  
  <!-- ===== QUIZ MODAL ===== -->
  <div id="quizModal" class="quiz-modal">
    <div class="quiz-container">
      <div class="quiz-header">
        <h2>üéì Solar Farm Knowledge Quiz</h2>
        <p>Test your understanding of solar farm components!</p>
        <button class="quiz-close" id="quizClose">‚úï</button>
      </div>
      <div class="quiz-progress">
        <div class="quiz-progress-bar" id="quizProgressBar"></div>
      </div>
      <div class="quiz-content" id="quizContent">
        <!-- Questions will be inserted here -->
      </div>
      <div class="quiz-footer">
        <div class="quiz-score" id="quizScore">Question 1 of 10</div>
        <button class="quiz-btn-action" id="quizNext">Next Question ‚Üí</button>
      </div>
    </div>
  </div>
  

  <script>
    let scene, camera, renderer, currentStep = 'module';
    let isTopView = false;
    let demoTrackerGroup = null;  // Reference to demo tracker display
    let demoCombinerGroup = null; // Reference to demo combiner display
    
    // Sun tracking & Day/Night cycle
    let sunLight, sunMesh, sunAngle = 0.25; // 0 = sunrise, 0.5 = noon, 1 = sunset
    let isDayCycleActive = false;
    let trackerRows = []; // Store tracker references for rotation
    let junctionBoxes = []; // Store junction box references with row info: {mesh, rowZ}
    let redCables = []; // Store red cable references with row info: {mesh, rowZ}
    let bearingPlates = []; // Store bearing plate references with row info: {mesh, rowZ, originalMat}
    let combinerBoxes = []; // Store combiner box references with row info: {mesh, rowZ, xCenter, originalMat}
    let inverterBoxes = []; // Store inverter box references with row info: {mesh, rowZ, xCenter, originalMat}
    
    // Electricity flow particles
    let electricityParticles = [];
    let isElectricityFlowActive = false;
    const flowPaths = []; // Store paths from panels to inverters
    
    // Camera control variables
    let targetX = 0, targetY = 10, targetZ = 0;
    let spherical = { radius: 200, theta: Math.PI / 4, phi: Math.PI / 3 };
    
    const defaultCam = { x: 140, y: 80, z: 180 };
    const topViewCam = { x: 0, y: 400, z: 10 };
    
    const contentData = {
      module: {
        title: "1. Solar Panel Module",
        subtitle: "Step 1: The Basic Building Block",
        content: `
          <div class="info-box">
            <h3>What is a Solar Module?</h3>
            <p>A solar panel (module) converts sunlight into electricity using photovoltaic cells.</p>
          </div>
          <div class="info-box">
            <h3>Explanation</h3>
            <p>‚Ä¢ Like a tile on your roof, but generates electricity</p>
            <p>‚Ä¢ Made of silicon cells (like computer chips)</p>
            <p>‚Ä¢ Produces DC electricity (like a battery)</p>
          </div>
          <div class="stats-grid">
            <div class="stat-card"><div class="stat-value">600W</div><div class="stat-label">Power Output</div></div>
            <div class="stat-card"><div class="stat-value">22%</div><div class="stat-label">Efficiency</div></div>
          </div>
        `,
        stats: `<div class="stat-card"><div class="stat-value">Step 1 of 6</div><div class="stat-label">Module ‚Üí String ‚Üí Tracker ‚Üí Combiner ‚Üí Cabling ‚Üí Inverter</div></div>`,
        cam: {x: 140, y: 11, z: -23},
        lookAt: {x: 140, y: 6, z: -27}
      },
      string: {
        title: "2. String Circuit",
        subtitle: "Step 2: Panel Interconnections",
        content: `
          <div class="info-box">
            <h3>How Panels Connect into Strings</h3>
            <p>Panels connect in series using <strong>MC4 connectors</strong> to form strings.</p>
          </div>
          <div class="info-box">
            <h3>The Connection Flow</h3>
            <p>1. <strong>Junction Box</strong> - On back of each panel (+/- terminals)</p>
            <p>2. <strong>Integrated Wires</strong> - Pre-attached DC cables with MC4 ends</p>
            <p>3. <strong>MC4 Interconnections</strong> - Connect panels together</p>
            <p>4. <strong>Routing</strong> - Cables run along mounting rails to inverter/combiner</p>
          </div>
          <button id="viewCablesBtn" class="view-demo-btn" style="background: linear-gradient(135deg, #cc3333, #ff5555); margin: 10px 0;">
            üîå View DC Cables (Back of Panel)
          </button>
          <div class="info-box" style="background: rgba(0,80,80,0.3); border-left: 3px solid #0fa;">
            <h3>üîç What You're Seeing (Highlight Guide)</h3>
            <p><span style="color:#0f8;">‚óè</span> <strong style="color:#0f8;">Green dots</strong> = MC4 connection points</p>
            <p><span style="color:#ffdd00;">‚óè</span> <strong style="color:#ffdd00;">Yellow boxes</strong> = Junction boxes on panel backs</p>
            <p><span style="color:#ff3333;">‚îÅ</span> <strong style="color:#ff3333;">Red lines</strong> = DC+ cable interconnections</p>
            <p><span style="color:#333333;">‚îÅ</span> <strong style="color:#666666;">Black lines</strong> = DC- cable interconnections</p>
            <p><span style="color:#0fa;">‚û§</span> <strong style="color:#0fa;">Arrows</strong> = Direction to inverter/combiner</p>
          </div>
          <div class="stats-grid">
            <div class="stat-card"><div class="stat-value">24</div><div class="stat-label">Panels/String</div></div>
            <div class="stat-card"><div class="stat-value">MC4</div><div class="stat-label">Connector Type</div></div>
          </div>
        `,
        stats: `<div class="stat-card"><div class="stat-value">Step 2 of 6</div><div class="stat-label">Look for MC4 connections along the mounting rails</div></div>`,
        cam: {x: 148, y: 8, z: -40},
        lookAt: {x: 140, y: 6.0, z: -45}
      },
      tracker: {
        title: "3. Solar Tracker",
        subtitle: "Step 3: Following the Sun",
        content: `
          <div class="info-box" style="background: rgba(0,255,170,0.15); border-left: 3px solid #00ffaa;">
            <h3>üëÅÔ∏è The Tracker Bearing Plate is Highlighted</h3>
            <p>Look for the <strong style="color:#00ffaa;">glowing cyan curved plate</strong> on the tracker ‚Äî this is the bearing that allows the panels to rotate!</p>
          </div>
          <div class="info-box">
            <h3>What is a Solar Tracker?</h3>
            <p>A device that orients solar panels to <strong>follow the sun's path</strong> across the sky, maximizing sunlight absorption and boosting energy production <strong>15-40%</strong> compared to fixed systems.</p>
          </div>
          <div class="info-box">
            <h3>How Trackers Work</h3>
            <p><strong>1. Sensing the Sun</strong> - Uses sensors or programmed algorithms (astronomical data) to know the sun's position</p>
            <p><strong>2. Movement</strong> - Motors slowly adjust the panel angle throughout the day to keep it facing the sun</p>
            <p><strong>3. Maximizing Output</strong> - By staying perpendicular, they reduce the "angle of incidence" = more light hits the panel</p>
          </div>
          <div class="info-box">
            <h3>Types of Trackers</h3>
            <p><strong>Single-Axis</strong> - Rotates east-to-west (common in large solar farms) ‚Üê <em>This is what you see here!</em></p>
            <p><strong>Dual-Axis</strong> - Rotates both east-west AND north-south (highest efficiency, higher cost)</p>
          </div>
          <div style="text-align:center; margin: 15px 0;">
            <button id="viewTrackerBtn" class="view-demo-btn">
              üîç VIEW TRACKER CLOSE-UP
            </button>
          </div>
          <div class="info-box">
            <h3>Industry Leading Partners</h3>
            <p><strong style="color:#ffdd00;">Nextracker</strong> - NX Horizon with TrueCapture‚Ñ¢</p>
            <p><strong style="color:#2255aa;">Array Technologies</strong> - DuraTrack HZ v3 with SmarTrack‚Ñ¢</p>
          </div>
          <div class="info-box" style="background: rgba(0,80,80,0.3); border-left: 3px solid #0fa;">
            <h3>üîç What You're Seeing</h3>
            <p><span style="color:#00ffaa;">‚ñ£</span> <strong style="color:#00ffaa;">Glowing cyan plate</strong> = Bearing plate (HIGHLIGHTED)</p>
            <p>The curved metal plate connects the torque tube to the post and allows rotation.</p>
            <p style="margin-top: 8px; font-size: 12px; color: #888;">Click "VIEW TRACKER CLOSE-UP" to see Nextracker & Array Technologies styles</p>
          </div>
          <div class="stats-grid">
            <div class="stat-card"><div class="stat-value">+25%</div><div class="stat-label">More Power vs Fixed</div></div>
            <div class="stat-card"><div class="stat-value">¬±60¬∞</div><div class="stat-label">Rotation Range</div></div>
          </div>
        `,
        stats: `<div class="stat-card"><div class="stat-value">Step 3 of 6</div><div class="stat-label">Single-axis tracker rotates east-to-west to follow the sun</div></div>`,
        cam: {x: 150, y: 7, z: -72},
        lookAt: {x: 140, y: 4, z: -63}
      },
      combiner: {
        title: "4. Combiner Box",
        subtitle: "Step 4: Combining Multiple Strings",
        content: `
          <div class="info-box">
            <h3>What is a Combiner Box?</h3>
            <p>An electrical enclosure that safely <strong>bundles multiple solar panel strings</strong> into a single, higher-current output for the inverter, adding crucial protection like fuses and surge suppression.</p>
          </div>
          <div class="info-box">
            <h3>Key Functions</h3>
            <p><strong>1. Aggregation</strong> - Combines multiple strings (parallel connections) into one output cable</p>
            <p><strong>2. Protection</strong> - Houses fuses, circuit breakers, and Surge Protection Devices (SPDs)</p>
            <p><strong>3. Organization</strong> - Centralized enclosure for wiring, improving safety & maintenance</p>
            <p><strong>4. Monitoring</strong> - Advanced boxes track string voltage, current, and temperature</p>
          </div>
          <div class="info-box">
            <h3>Types of Combiner Boxes</h3>
            <p><strong>DC Combiner</strong> - Most common, combines DC outputs before the inverter ‚Üê <em>This is what you see here!</em></p>
            <p><strong>AC Combiner</strong> - Combines AC outputs from multiple inverters</p>
          </div>
          <div style="text-align:center; margin: 15px 0;">
            <button id="viewCombinerBtn" class="view-demo-btn green">
              üîç VIEW COMBINER CLOSE-UP
            </button>
          </div>
          <div class="info-box" style="background: rgba(0,255,170,0.15); border-left: 3px solid #00ffaa;">
            <h3>üëÅÔ∏è The Combiner Box is Highlighted</h3>
            <p>Look for the <strong style="color:#00ffaa;">glowing cyan box</strong> ‚Äî this is the combiner that collects power from multiple panel strings!</p>
          </div>
          <div class="info-box" style="background: rgba(0,80,80,0.3); border-left: 3px solid #0fa;">
            <h3>üîç What You're Seeing</h3>
            <p><span style="color:#00ffaa;">‚ñ¢</span> <strong style="color:#00ffaa;">Glowing box</strong> = Combiner Box (HIGHLIGHTED)</p>
            <p><span style="color:#a33;">‚óè</span> <strong style="color:#f66;">Red cables</strong> = DC+ inputs from strings</p>
            <p><span style="color:#ff0;">‚ñÆ</span> <strong style="color:#ff0;">Yellow components</strong> = Fuses (overcurrent protection)</p>
            <p><span style="color:#0af;">‚ñÆ</span> <strong style="color:#0af;">Blue device</strong> = Surge Protection Device (SPD)</p>
          </div>
          <div class="stats-grid">
            <div class="stat-card"><div class="stat-value">24</div><div class="stat-label">String Inputs</div></div>
            <div class="stat-card"><div class="stat-value">1500V</div><div class="stat-label">Max Voltage</div></div>
          </div>
        `,
        stats: `<div class="stat-card"><div class="stat-value">Step 4 of 6</div><div class="stat-label">Strings combine here before going to inverter</div></div>`,
        cam: {x: 140, y: 3.5, z: -20},
        lookAt: {x: 140, y: 2.8, z: -24.5}
      },
      cabling: {
        title: "5. DC & AC Cabling",
        subtitle: "Step 5: Transporting the Power",
        content: `
          <div class="info-box">
            <h3>What is Cabling?</h3>
            <p>DC cables (red/blue) carry power from strings to inverters. Look for the cables running down the posts!</p>
          </div>
          <div class="stats-grid">
            <div class="stat-card"><div class="stat-value">10 AWG</div><div class="stat-label">Wire Size</div></div>
            <div class="stat-card"><div class="stat-value">2000V</div><div class="stat-label">DC Rating</div></div>
          </div>
        `,
        stats: `<div class="stat-card"><div class="stat-value">Step 5 of 6</div><div class="stat-label">Cabling ‚Üí Inverter</div></div>`,
        cam: {x: 155, y: 8, z: 60},
        lookAt: {x: 140, y: 3, z: 45}
      },
      inverter: {
        title: "6. String Inverters",
        subtitle: "Step 6: Converting to Grid Power",
        content: `
          <div class="info-box" style="background: rgba(0,255,170,0.15); border-left: 3px solid #00ffaa;">
            <h3>üëÅÔ∏è The Inverter is Highlighted</h3>
            <p>Look for the <strong style="color:#00ffaa;">glowing cyan boxes</strong> on the posts ‚Äî these are the string inverters that convert DC to AC power!</p>
          </div>
          <div class="info-box">
            <h3>What is a String Inverter?</h3>
            <p>String inverters convert DC from panels to AC for the grid. They're mounted on each tracker post for distributed conversion.</p>
          </div>
          <div class="info-box">
            <h3>Why on Every Post?</h3>
            <p>‚Ä¢ Reduces DC cable runs</p>
            <p>‚Ä¢ Better monitoring per string</p>
            <p>‚Ä¢ Easier maintenance access</p>
          </div>
          <div class="stats-grid">
            <div class="stat-card"><div class="stat-value">15kW</div><div class="stat-label">Per Inverter</div></div>
            <div class="stat-card"><div class="stat-value">98.5%</div><div class="stat-label">Efficiency</div></div>
          </div>
        `,
        stats: `<div class="stat-card"><div class="stat-value">Step 6 of 6</div><div class="stat-label">Zoom in to see inverters on posts!</div></div>`,
        cam: {x: 138, y: 4, z: -17},
        lookAt: {x: 135, y: 2.5, z: -27}
      }
    };

    function init() {
      setTimeout(() => document.getElementById('loading').style.display = 'none', 1000);
      init3D();
      setupListeners();
      updateContent();
      // Show initial highlight after a brief delay
      setTimeout(() => highlightComponent('module'), 100);
    }

    function init3D() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x7ec8e3);
      scene.fog = new THREE.Fog(0x7ec8e3, 300, 800);
      
      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
      camera.position.set(defaultCam.x, defaultCam.y, defaultCam.z);
      camera.lookAt(targetX, targetY, targetZ);
      
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.getElementById('canvas-container').appendChild(renderer.domElement);
      
      scene.add(new THREE.AmbientLight(0xffffff, 0.5));
      sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
      sunLight.position.set(100, 200, 80);
      sunLight.castShadow = true;
      sunLight.shadow.camera.left = -300;
      sunLight.shadow.camera.right = 300;
      sunLight.shadow.camera.top = 300;
      sunLight.shadow.camera.bottom = -300;
      sunLight.shadow.mapSize.width = 4096;
      sunLight.shadow.mapSize.height = 4096;
      scene.add(sunLight);
      
      // Create visible sun - BIGGER
      const sunGeo = new THREE.SphereGeometry(25, 32, 32);
      const sunMat = new THREE.MeshBasicMaterial({ 
        color: 0xffdd44,
        transparent: true,
        opacity: 1.0
      });
      sunMesh = new THREE.Mesh(sunGeo, sunMat);
      sunMesh.position.set(100, 200, 80);
      scene.add(sunMesh);
      
      // Sun glow - BIGGER
      const sunGlowGeo = new THREE.SphereGeometry(45, 32, 32);
      const sunGlowMat = new THREE.MeshBasicMaterial({ 
        color: 0xffaa00,
        transparent: true,
        opacity: 0.4
      });
      const sunGlow = new THREE.Mesh(sunGlowGeo, sunGlowMat);
      sunMesh.add(sunGlow);
      
      // Outer glow
      const sunGlowOuter = new THREE.Mesh(
        new THREE.SphereGeometry(70, 32, 32),
        new THREE.MeshBasicMaterial({ color: 0xffcc00, transparent: true, opacity: 0.15 })
      );
      sunMesh.add(sunGlowOuter);
      
      // Sun rays
      const rayMat = new THREE.MeshBasicMaterial({ 
        color: 0xffee66, 
        transparent: true, 
        opacity: 0.6 
      });
      for (let i = 0; i < 12; i++) {
        const rayGeo = new THREE.CylinderGeometry(0.5, 3, 80, 8);
        const ray = new THREE.Mesh(rayGeo, rayMat);
        ray.rotation.z = (i / 12) * Math.PI * 2;
        ray.position.x = Math.cos((i / 12) * Math.PI * 2) * 50;
        ray.position.y = Math.sin((i / 12) * Math.PI * 2) * 50;
        sunMesh.add(ray);
      }
      
      // Ground
      const groundCanvas = document.createElement('canvas');
      groundCanvas.width = 512;
      groundCanvas.height = 512;
      const gCtx = groundCanvas.getContext('2d');
      gCtx.fillStyle = '#5a8a50';
      gCtx.fillRect(0, 0, 512, 512);
      for (let i = 0; i < 8000; i++) {
        gCtx.fillStyle = `rgba(${60 + Math.random() * 50}, ${100 + Math.random() * 60}, ${50 + Math.random() * 40}, 0.4)`;
        gCtx.fillRect(Math.random() * 512, Math.random() * 512, 2, 4);
      }
      const groundTexture = new THREE.CanvasTexture(groundCanvas);
      groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
      groundTexture.repeat.set(30, 30);
      
      const ground = new THREE.Mesh(
        new THREE.PlaneGeometry(1200, 1200),
        new THREE.MeshStandardMaterial({ map: groundTexture, color: 0x6a9a5a })
      );
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = 0;
      ground.receiveShadow = true;
      scene.add(ground);
      
      // Dirt road
      const road = new THREE.Mesh(
        new THREE.PlaneGeometry(15, 400),
        new THREE.MeshStandardMaterial({ color: 0xc4a86a })
      );
      road.rotation.x = -Math.PI / 2;
      road.position.set(0, 0.1, 0);
      scene.add(road);
      
      createTrees();
      createFarm();
      createHighlights();
      createMarkers();
      animate();
    }
    
    // === HIGHLIGHT SYSTEM FOR EDUCATIONAL STEPS ===
    let highlightGroup;
    let activeHighlight = null;
    let highlightTime = 0;
    
    const highlightPositions = {
      module: { x: 140, y: 6, z: -27, scale: 1.0, elongated: false },       // Solar panel surface
      string: { x: 140, y: 6.0, z: -45, scale: 1.2, elongated: true, length: 30 },  // MC4 interconnections
      tracker: { x: 140, y: 4, z: -63, scale: 1.0, elongated: false, isTracker: true },       // Torque tube and bearing
      combiner: { x: 140, y: 2.8, z: -24.5, scale: 1.0, elongated: false, isCombiner: true },       // Combiner box on post
      cabling: { x: 140, y: 3, z: 45, scale: 1.5, elongated: false, isCabling: true },  // DC cables
      inverter: { x: 135, y: 2.5, z: -27, scale: 1.0, elongated: false, isInverter: true }        // String inverters on posts
    };
    
    function createHighlights() {
      highlightGroup = new THREE.Group();
      scene.add(highlightGroup);
      
      // Create highlight ring for each step
      Object.keys(highlightPositions).forEach(step => {
        const pos = highlightPositions[step];
        const ringGroup = new THREE.Group();
        ringGroup.userData.step = step;
        
        if (pos.elongated) {
          // ELONGATED HIGHLIGHT (for string/MC4 interconnections) - smaller for close-up
          // Shows panels connected via MC4 connectors along mounting rails
          
          // Mounting rail representation
          const railGeo = new THREE.BoxGeometry(pos.length, 0.08, 0.4);
          const railMat = new THREE.MeshBasicMaterial({ 
            color: 0x666666,
            transparent: true, 
            opacity: 0.6
          });
          const rail = new THREE.Mesh(railGeo, railMat);
          rail.position.set(pos.x, pos.y - 0.2, pos.z);
          ringGroup.add(rail);
          
          // MC4 connection points along the rail (where panels connect)
          const numConnections = 5;
          for (let mc = 0; mc < numConnections; mc++) {
            const mcX = pos.x - pos.length/2 + 3 + mc * 6;
            
            // MC4 connector glow
            const mc4Geo = new THREE.SphereGeometry(0.2, 12, 12);
            const mc4Mat = new THREE.MeshBasicMaterial({ 
              color: 0x00ff88, // Green for connection points
              transparent: true, 
              opacity: 0.8
            });
            const mc4 = new THREE.Mesh(mc4Geo, mc4Mat);
            mc4.position.set(mcX, pos.y - 0.1, pos.z);
            mc4.userData.isMC4 = true;
            ringGroup.add(mc4);
            
            // Cable line between MC4 points
            if (mc < numConnections - 1) {
              const cableGeo = new THREE.BoxGeometry(5, 0.08, 0.08);
              const cableMat = new THREE.MeshBasicMaterial({ 
                color: 0xaa3333, // Red for DC+
                transparent: true, 
                opacity: 0.7
              });
              const cable = new THREE.Mesh(cableGeo, cableMat);
              cable.position.set(mcX + 3, pos.y - 0.08, pos.z - 0.1);
              ringGroup.add(cable);
            }
          }
          
          // Junction box indicators above (on panel backs)
          for (let jb = 0; jb < 4; jb++) {
            const jboxGeo = new THREE.BoxGeometry(0.6, 0.25, 0.4);
            const jboxMat = new THREE.MeshBasicMaterial({ 
              color: 0xffdd00, // Yellow for junction boxes
              transparent: true, 
              opacity: 0.7
            });
            const jbox = new THREE.Mesh(jboxGeo, jboxMat);
            jbox.position.set(pos.x - pos.length/2 + 4 + jb * 7, pos.y + 0.3, pos.z);
            ringGroup.add(jbox);
          }
          
          // Arrow indicators at each end - pointing to combiner/inverter
          const arrowGeo = new THREE.ConeGeometry(0.5, 1.5, 8);
          const arrowMat = new THREE.MeshBasicMaterial({ 
            color: 0x00ffaa, 
            transparent: true, 
            opacity: 1.0
          });
          
          // Left arrow (to combiner/inverter)
          const leftArrow = new THREE.Mesh(arrowGeo, arrowMat);
          leftArrow.position.set(pos.x - pos.length/2 - 2, pos.y + 0.5, pos.z);
          leftArrow.rotation.z = -Math.PI / 2;
          leftArrow.userData.baseX = pos.x - pos.length/2 - 2;
          ringGroup.add(leftArrow);
          
          // Right arrow
          const rightArrow = new THREE.Mesh(arrowGeo, arrowMat);
          rightArrow.position.set(pos.x + pos.length/2 + 2, pos.y + 0.5, pos.z);
          rightArrow.rotation.z = Math.PI / 2;
          rightArrow.userData.baseX = pos.x + pos.length/2 + 2;
          ringGroup.add(rightArrow);
          
          // Add glowing arrow trail for left arrow
          const trailMat = new THREE.MeshBasicMaterial({ 
            color: 0x00ffaa, 
            transparent: true, 
            opacity: 0.4
          });
          for (let t = 1; t <= 2; t++) {
            const trailArrow = new THREE.Mesh(new THREE.ConeGeometry(0.35, 1, 6), trailMat.clone());
            trailArrow.position.set(pos.x - pos.length/2 - 2 + t * 1.2, pos.y + 0.5, pos.z);
            trailArrow.rotation.z = -Math.PI / 2;
            trailArrow.material.opacity = 0.3 - t * 0.1;
            ringGroup.add(trailArrow);
          }
          
          // Add glowing arrow trail for right arrow
          for (let t = 1; t <= 2; t++) {
            const trailArrow = new THREE.Mesh(new THREE.ConeGeometry(0.35, 1, 6), trailMat.clone());
            trailArrow.position.set(pos.x + pos.length/2 + 2 - t * 1.2, pos.y + 0.5, pos.z);
            trailArrow.rotation.z = Math.PI / 2;
            trailArrow.material.opacity = 0.3 - t * 0.1;
            ringGroup.add(trailArrow);
          }
          
          // Subtle vertical indicator
          const beamGeo = new THREE.BoxGeometry(pos.length * 0.3, 2.5, 0.05);
          const beamMat = new THREE.MeshBasicMaterial({ 
            color: 0x00ff88, 
            transparent: true, 
            opacity: 0.08,
            side: THREE.DoubleSide
          });
          const beam = new THREE.Mesh(beamGeo, beamMat);
          beam.position.set(pos.x, pos.y + 1.5, pos.z);
          ringGroup.add(beam);
          
        } else {
          // ARROW HIGHLIGHT (pointing down at component)
          
          // Special highlight for cabling - shows cable runs
          if (pos.isCabling) {
            // Multiple cable line highlights - smaller for close-up
            const cableMat = new THREE.MeshBasicMaterial({ 
              color: 0xff4444, 
              transparent: true, 
              opacity: 0.8
            });
            const cableMatBlack = new THREE.MeshBasicMaterial({ 
              color: 0x4444ff, 
              transparent: true, 
              opacity: 0.8
            });
            
            // Horizontal cable runs (red and blue for DC+ and DC-)
            for (let c = 0; c < 3; c++) {
              const cableGeo = new THREE.CylinderGeometry(0.15, 0.15, 40, 8);
              const cable = new THREE.Mesh(cableGeo, c % 2 === 0 ? cableMat.clone() : cableMatBlack.clone());
              cable.rotation.z = Math.PI / 2;
              cable.position.set(pos.x, pos.y + c * 0.4, pos.z + (c - 1) * 1);
              ringGroup.add(cable);
            }
            
            // Glowing pulses along cables
            for (let p = 0; p < 6; p++) {
              const pulseGeo = new THREE.SphereGeometry(0.3, 16, 16);
              const pulseMat = new THREE.MeshBasicMaterial({ 
                color: p % 2 === 0 ? 0xff6666 : 0x6666ff, 
                transparent: true, 
                opacity: 0.9
              });
              const pulse = new THREE.Mesh(pulseGeo, pulseMat);
              pulse.position.set(pos.x - 15 + p * 6, pos.y + (p % 3) * 0.4, pos.z + ((p % 3) - 1) * 1);
              pulse.userData.isCablePulse = true;
              pulse.userData.baseX = pos.x - 15 + p * 6;
              ringGroup.add(pulse);
            }
            
            // Large label arrow
            const mainArrowGeo = new THREE.ConeGeometry(0.6, 2, 8);
            const mainArrowMat = new THREE.MeshBasicMaterial({ 
              color: 0xffaa00, 
              transparent: true, 
              opacity: 0.95
            });
            const mainArrow = new THREE.Mesh(mainArrowGeo, mainArrowMat);
            mainArrow.rotation.x = Math.PI;
            mainArrow.position.set(pos.x, pos.y + 4, pos.z);
            mainArrow.userData.isMainArrow = true;
            mainArrow.userData.baseY = pos.y + 4;
            ringGroup.add(mainArrow);
            
            // Vertical drop cables visualization
            for (let d = 0; d < 4; d++) {
              const dropGeo = new THREE.CylinderGeometry(0.08, 0.08, 2, 8);
              const dropMat = new THREE.MeshBasicMaterial({ 
                color: d % 2 === 0 ? 0xff4444 : 0x4444ff, 
                transparent: true, 
                opacity: 0.7
              });
              const drop = new THREE.Mesh(dropGeo, dropMat);
              drop.position.set(pos.x - 12 + d * 8, pos.y + 2.5, pos.z);
              ringGroup.add(drop);
            }
            
          } else if (pos.isTracker) {
            // TRACKER HIGHLIGHT - Outline created dynamically in highlightComponent
            // Nothing needed here - the bearing plates glow when step is selected
            
          } else if (pos.isCombiner) {
            // COMBINER HIGHLIGHT - Highlight created dynamically in highlightComponent
            // Nothing needed here - the combiner boxes glow when step is selected
            
          } else if (pos.isInverter) {
            // INVERTER HIGHLIGHT - Highlight created dynamically in highlightComponent
            // Nothing needed here - the inverter boxes glow when step is selected
            
          } else {
            // Standard arrow highlight - smaller for close-up views
            // Main downward pointing arrow
            const mainArrowGeo = new THREE.ConeGeometry(0.4, 1.2, 8);
            const mainArrowMat = new THREE.MeshBasicMaterial({ 
              color: 0x00ffaa, 
              transparent: true, 
              opacity: 0.9
            });
            const mainArrow = new THREE.Mesh(mainArrowGeo, mainArrowMat);
            mainArrow.rotation.x = Math.PI; // Point downward
            mainArrow.position.set(pos.x, pos.y + 2.5, pos.z);
            mainArrow.userData.isMainArrow = true;
            mainArrow.userData.baseY = pos.y + 2.5;
            ringGroup.add(mainArrow);
            
            // Trail arrows above (creating motion effect)
            for (let t = 1; t <= 3; t++) {
              const trailArrow = new THREE.Mesh(
                new THREE.ConeGeometry(0.3 - t * 0.05, 0.8, 6),
                new THREE.MeshBasicMaterial({ 
                  color: 0x00ffaa, 
                  transparent: true, 
                  opacity: 0.5 - t * 0.12
                })
              );
              trailArrow.rotation.x = Math.PI;
              trailArrow.position.set(pos.x, pos.y + 2.5 + t * 1, pos.z);
              ringGroup.add(trailArrow);
            }
            
            // Four arrows pointing inward from sides
            for (let i = 0; i < 4; i++) {
              const angle = (i / 4) * Math.PI * 2;
              const arrowGeo = new THREE.ConeGeometry(0.25, 0.8, 6);
              const arrowMat = new THREE.MeshBasicMaterial({ 
                color: 0x00ffaa, 
                transparent: true, 
                opacity: 0.8
              });
              const arrow = new THREE.Mesh(arrowGeo, arrowMat);
              const dist = pos.scale * 1.5;
              arrow.position.set(
                pos.x + Math.cos(angle) * dist,
                pos.y + 0.5,
                pos.z + Math.sin(angle) * dist
              );
              // Point arrows inward toward center
              arrow.rotation.x = Math.PI / 2;
              arrow.rotation.z = angle + Math.PI / 2;
              arrow.userData.baseAngle = angle;
              arrow.userData.baseDist = dist;
              ringGroup.add(arrow);
            }
          }
        }
        
        ringGroup.visible = false;
        highlightGroup.add(ringGroup);
      });
    }
    
    function highlightComponent(step) {
      // Hide all highlights
      highlightGroup.children.forEach(group => {
        group.visible = false;
      });
      
      // Remove any tracker outline meshes
      if (window.trackerOutline) {
        scene.remove(window.trackerOutline);
        window.trackerOutline = null;
      }
      
      // Restore bearing plates to original material
      bearingPlates.forEach(item => {
        if (item.isHighlighted) {
          item.mesh.material = item.originalMat;
          item.isHighlighted = false;
        }
      });
      
      // Restore combiner boxes to original material
      combinerBoxes.forEach(item => {
        if (item.isHighlighted) {
          item.mesh.material = item.originalMat;
          item.isHighlighted = false;
        }
      });
      
      // Restore inverter boxes to original material
      inverterBoxes.forEach(item => {
        if (item.isHighlighted) {
          item.mesh.material = item.originalMat;
          item.isHighlighted = false;
        }
      });
      
      // Show the highlight for the current step
      const highlight = highlightGroup.children.find(g => g.userData.step === step);
      if (highlight) {
        highlight.visible = true;
        activeHighlight = highlight;
        highlightTime = 0;
      }
      
      // If tracker step, make the bearing plate at z=-63 glow
      if (step === 'tracker') {
        const targetZ = -63;
        const glowMat = new THREE.MeshBasicMaterial({ 
          color: 0x00ffaa, 
          transparent: true, 
          opacity: 0.9,
          side: THREE.DoubleSide
        });
        
        bearingPlates.forEach(item => {
          // Highlight bearing plates on the right block (x > 0) at the target row
          if (Math.abs(item.rowZ - targetZ) < 1 && item.xCenter > 0) {
            item.mesh.material = glowMat;
            item.isHighlighted = true;
          }
        });
      }
      
      // If combiner step, make the combiner boxes at z=-27 glow
      if (step === 'combiner') {
        const targetZ = -27;
        const glowMat = new THREE.MeshBasicMaterial({ 
          color: 0x00ffaa, 
          transparent: true, 
          opacity: 0.9
        });
        
        combinerBoxes.forEach(item => {
          // Highlight combiner boxes on the right block (x > 0) at the target row
          if (Math.abs(item.rowZ - targetZ) < 1 && item.xCenter > 0) {
            item.mesh.material = glowMat;
            item.isHighlighted = true;
          }
        });
      }
      
      // If inverter step, make the inverter boxes at z=-27 glow
      if (step === 'inverter') {
        const targetZ = -27;
        const glowMat = new THREE.MeshBasicMaterial({ 
          color: 0x00ffaa, 
          transparent: true, 
          opacity: 0.9
        });
        
        inverterBoxes.forEach(item => {
          // Highlight inverters on the right block (x > 0) at the target row
          if (Math.abs(item.rowZ - targetZ) < 1 && item.xCenter > 0) {
            item.mesh.material = glowMat;
            item.isHighlighted = true;
          }
        });
      }
    }
    
    function animateHighlights() {
      if (!activeHighlight || !activeHighlight.visible) return;
      
      highlightTime += 0.05;
      const step = activeHighlight.userData.step;
      const pos = highlightPositions[step];
      
      activeHighlight.children.forEach(child => {
        if (child.userData.isMC4) {
          // MC4 connection points pulse
          const pulse = 1 + Math.sin(highlightTime * 3) * 0.2;
          child.scale.set(pulse, pulse, pulse);
          child.material.opacity = 0.5 + Math.sin(highlightTime * 3) * 0.3;
        }
        if (child.userData.isCablePulse) {
          // Cable pulse animation - move along cable
          const baseX = child.userData.baseX;
          child.position.x = baseX + Math.sin(highlightTime * 2 + baseX * 0.1) * 1.5;
          child.material.opacity = 0.6 + Math.sin(highlightTime * 4 + baseX * 0.1) * 0.4;
          const scale = 0.8 + Math.sin(highlightTime * 3) * 0.2;
          child.scale.set(scale, scale, scale);
        }
        if (child.geometry.type === 'CylinderGeometry') {
          // Cable highlights pulse
          child.material.opacity = 0.4 + Math.sin(highlightTime * 2) * 0.2;
        }
        if (child.geometry.type === 'ConeGeometry') {
          // Arrows animation - make them pulse and move
          if (child.userData.isMainArrow) {
            // Main downward arrow bobs up and down - smaller movement
            const bob = Math.sin(highlightTime * 3) * 0.3;
            child.position.y = child.userData.baseY + bob;
            child.material.opacity = 0.7 + Math.sin(highlightTime * 2) * 0.3;
            const scale = 1 + Math.sin(highlightTime * 2) * 0.1;
            child.scale.set(scale, scale, scale);
          } else if (child.userData.baseAngle !== undefined) {
            // Side arrows pulse inward/outward - smaller movement
            const pulseDist = child.userData.baseDist + Math.sin(highlightTime * 3) * 0.2;
            child.position.x = pos.x + Math.cos(child.userData.baseAngle) * pulseDist;
            child.position.z = pos.z + Math.sin(child.userData.baseAngle) * pulseDist;
            child.material.opacity = 0.6 + Math.sin(highlightTime * 2) * 0.3;
            const scale = 1 + Math.sin(highlightTime * 2) * 0.15;
            child.scale.set(scale, scale, scale);
          } else if (child.userData.baseX !== undefined) {
            // Elongated arrows pulse horizontally - smaller movement
            const dir = child.userData.baseX < pos.x ? 1 : -1;
            child.position.x = child.userData.baseX + Math.sin(highlightTime * 3) * 0.8 * dir;
            child.material.opacity = 0.8 + Math.sin(highlightTime * 2) * 0.2;
            const scale = 1 + Math.sin(highlightTime * 2) * 0.15;
            child.scale.set(scale, scale, scale);
          }
        }
        if (child.geometry.type === 'BoxGeometry') {
          // Box highlights pulse (for string highlight elements)
          child.material.opacity = 0.05 + Math.sin(highlightTime * 1.5) * 0.03;
        }
      });
    }

    function createTrees() {
      const trunkMat = new THREE.MeshStandardMaterial({ color: 0x4a3520 });
      const foliageMat = new THREE.MeshStandardMaterial({ color: 0x1a5a30 });
      
      for (let i = 0; i < 60; i++) {
        const tree = new THREE.Group();
        const x = -400 + i * 13 + Math.random() * 5;
        const z = -220 - Math.random() * 60;
        
        const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 1, 10, 8), trunkMat);
        trunk.position.y = 5;
        trunk.castShadow = true;
        tree.add(trunk);
        
        const height = 16 + Math.random() * 10;
        const foliage = new THREE.Mesh(new THREE.ConeGeometry(5 + Math.random() * 2, height, 8), foliageMat);
        foliage.position.y = 10 + height / 2;
        foliage.castShadow = true;
        tree.add(foliage);
        
        tree.position.set(x, 0, z);
        scene.add(tree);
      }
    }

    function createFarm() {
      // Panel texture
      const panelCanvas = document.createElement('canvas');
      panelCanvas.width = 256;
      panelCanvas.height = 256;
      const pCtx = panelCanvas.getContext('2d');
      
      pCtx.fillStyle = '#4a5a8a';
      pCtx.fillRect(0, 0, 256, 256);
      
      const cols = 6, rows = 10;
      const cellW = 256 / cols, cellH = 256 / rows;
      
      pCtx.strokeStyle = '#ffffff';
      pCtx.lineWidth = 1.5;
      for (let c = 0; c <= cols; c++) {
        pCtx.beginPath();
        pCtx.moveTo(c * cellW, 0);
        pCtx.lineTo(c * cellW, 256);
        pCtx.stroke();
      }
      for (let r = 0; r <= rows; r++) {
        pCtx.beginPath();
        pCtx.moveTo(0, r * cellH);
        pCtx.lineTo(256, r * cellH);
        pCtx.stroke();
      }
      
      const panelTexture = new THREE.CanvasTexture(panelCanvas);
      
      // Materials
      const panelMat = new THREE.MeshStandardMaterial({ map: panelTexture, metalness: 0.7, roughness: 0.05, envMapIntensity: 2.0 });
      const frameMat = new THREE.MeshStandardMaterial({ color: 0xd0d0d0, metalness: 0.6, roughness: 0.4 });
      const torqueMat = new THREE.MeshStandardMaterial({ color: 0x505560, metalness: 0.7, roughness: 0.3 });
      const postMat = new THREE.MeshStandardMaterial({ color: 0x606868, metalness: 0.5, roughness: 0.5 });
      const inverterMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, metalness: 0.6, roughness: 0.4 });
      const inverterGrayMat = new THREE.MeshStandardMaterial({ color: 0x3a3a3a, metalness: 0.5, roughness: 0.5 });
      const ventMat = new THREE.MeshStandardMaterial({ color: 0x252525, metalness: 0.3, roughness: 0.6 });
      
      // Tracker parameters
      const panelW = 5.5;  // Longer panels
      const panelH = 2.2;  // Slightly taller too
      const panelGap = 0.15;
      const panelsPerRow = 40;  // Back to original
      const rowWidth = panelH * 2 + 0.25;
      const pileSpacing = 18;
      const pileHeight = 5;
      const tilt = 0.3;
      const torqueRadius = 0.6;
      
      const numRows = 14;  // More rows going down
      const rowSpacing = 18;
      
      // Left block
      for (let row = 0; row < numRows; row++) {
        const zPos = row * rowSpacing - ((numRows - 1) * rowSpacing) / 2;
        if (Math.abs(zPos) < 12) continue;
        createTrackerRow(-140, zPos, panelW, panelH, panelGap, panelsPerRow, pileSpacing, pileHeight, tilt, torqueRadius, panelMat, frameMat, torqueMat, postMat, inverterMat, inverterGrayMat, ventMat);
      }
      
      // Right block
      for (let row = 0; row < numRows; row++) {
        const zPos = row * rowSpacing - ((numRows - 1) * rowSpacing) / 2;
        if (Math.abs(zPos) < 12) continue;
        createTrackerRow(140, zPos, panelW, panelH, panelGap, panelsPerRow, pileSpacing, pileHeight, tilt, torqueRadius, panelMat, frameMat, torqueMat, postMat, inverterMat, inverterGrayMat, ventMat);
      }
      
      // SUBSTATION
      const substation = new THREE.Group();
      
      const building = new THREE.Mesh(
        new THREE.BoxGeometry(15, 8, 10),
        new THREE.MeshStandardMaterial({ color: 0xf5f5f5 })
      );
      building.position.y = 4;
      building.castShadow = true;
      substation.add(building);
      
      const roof = new THREE.Mesh(
        new THREE.BoxGeometry(17, 1.2, 12),
        new THREE.MeshStandardMaterial({ color: 0x3b82f6 })
      );
      roof.position.y = 8.6;
      substation.add(roof);
      
      const door = new THREE.Mesh(
        new THREE.BoxGeometry(3, 5, 0.2),
        new THREE.MeshStandardMaterial({ color: 0x6b2176 })
      );
      door.position.set(0, 2.5, 5.2);
      substation.add(door);
      
      // === REALISTIC WOODEN UTILITY POLE ===
      const poleGroup = new THREE.Group();
      
      const woodPoleMat = new THREE.MeshStandardMaterial({ 
        color: 0x5a4030, 
        roughness: 0.9,
        metalness: 0.0
      });
      const steelMat = new THREE.MeshStandardMaterial({ color: 0x666666, metalness: 0.7, roughness: 0.4 });
      const ceramicMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.4, metalness: 0.1 });
      const wireMat2 = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.8, roughness: 0.2 });
      
      // Main pole (tapered wooden pole)
      const mainPole = new THREE.Mesh(
        new THREE.CylinderGeometry(0.2, 0.35, 18, 8),
        woodPoleMat
      );
      mainPole.position.y = 9;
      mainPole.castShadow = true;
      poleGroup.add(mainPole);
      
      // Top crossarm
      const crossarm1 = new THREE.Mesh(
        new THREE.BoxGeometry(5, 0.25, 0.2),
        woodPoleMat
      );
      crossarm1.position.y = 16;
      poleGroup.add(crossarm1);
      
      // Second crossarm (lower)
      const crossarm2 = new THREE.Mesh(
        new THREE.BoxGeometry(4, 0.22, 0.18),
        woodPoleMat
      );
      crossarm2.position.y = 14;
      poleGroup.add(crossarm2);
      
      // Third crossarm (lowest)
      const crossarm3 = new THREE.Mesh(
        new THREE.BoxGeometry(3, 0.2, 0.15),
        woodPoleMat
      );
      crossarm3.position.y = 12;
      poleGroup.add(crossarm3);
      
      // Insulators on top crossarm (3 phase)
      [-2, 0, 2].forEach(x => {
        const insulator = new THREE.Mesh(
          new THREE.CylinderGeometry(0.12, 0.15, 0.3, 8),
          ceramicMat
        );
        insulator.position.set(x, 16.2, 0);
        poleGroup.add(insulator);
        
        // Pin on top of insulator
        const pin = new THREE.Mesh(
          new THREE.CylinderGeometry(0.03, 0.03, 0.15, 6),
          steelMat
        );
        pin.position.set(x, 16.4, 0);
        poleGroup.add(pin);
      });
      
      // Insulators on second crossarm
      [-1.5, 1.5].forEach(x => {
        const insulator2 = new THREE.Mesh(
          new THREE.CylinderGeometry(0.1, 0.13, 0.25, 8),
          ceramicMat
        );
        insulator2.position.set(x, 14.18, 0);
        poleGroup.add(insulator2);
      });
      
      // Insulators on third crossarm
      [-1, 1].forEach(x => {
        const insulator3 = new THREE.Mesh(
          new THREE.CylinderGeometry(0.08, 0.1, 0.2, 8),
          ceramicMat
        );
        insulator3.position.set(x, 12.15, 0);
        poleGroup.add(insulator3);
      });
      
      // Transformer can on pole
      const transformer = new THREE.Mesh(
        new THREE.CylinderGeometry(0.5, 0.5, 1.5, 12),
        new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.6, roughness: 0.4 })
      );
      transformer.position.set(0.8, 10, 0);
      poleGroup.add(transformer);
      
      // Transformer mounting bracket
      const bracket = new THREE.Mesh(
        new THREE.BoxGeometry(0.8, 0.1, 0.3),
        steelMat
      );
      bracket.position.set(0.4, 10.8, 0);
      poleGroup.add(bracket);
      
      // Power lines extending outward
      [-2, 0, 2].forEach((x, i) => {
        const wireLine = new THREE.Mesh(
          new THREE.CylinderGeometry(0.02, 0.02, 60, 4),
          wireMat2
        );
        wireLine.rotation.x = Math.PI / 2;
        wireLine.position.set(x, 16.35 - i * 0.02, -30);
        poleGroup.add(wireLine);
      });
      
      // Pole number tag
      const tag = new THREE.Mesh(
        new THREE.BoxGeometry(0.4, 0.25, 0.05),
        new THREE.MeshStandardMaterial({ color: 0xffff00 })
      );
      tag.position.set(0, 4, 0.2);
      poleGroup.add(tag);
      
      poleGroup.position.set(20, 0, -5);
      substation.add(poleGroup);
      
      substation.position.set(0, 0, 0);
      scene.add(substation);
      
      // === DEMO TRACKER DISPLAY MODEL ===
      // Professional museum-style tracker exhibit
      const demoTracker = new THREE.Group();
      
      // === DISPLAY PLATFORM ===
      const demoPad = new THREE.Mesh(
        new THREE.BoxGeometry(16, 0.4, 14),
        new THREE.MeshStandardMaterial({ color: 0x2a3a4a, roughness: 0.6, metalness: 0.3 })
      );
      demoPad.position.y = 0.2;
      demoTracker.add(demoPad);
      
      // Platform edge trim (accent color)
      const edgeTrim = new THREE.Mesh(
        new THREE.BoxGeometry(16.2, 0.15, 14.2),
        new THREE.MeshStandardMaterial({ color: 0xff1493, metalness: 0.6 })
      );
      edgeTrim.position.y = 0.42;
      demoTracker.add(edgeTrim);
      
      // === INFO BOARD (positioned to the left) ===
      const boardGroup = new THREE.Group();
      
      // Board backing (facing forward)
      const boardBack = new THREE.Mesh(
        new THREE.BoxGeometry(5, 6, 0.15),
        new THREE.MeshStandardMaterial({ color: 0x1a2a3a, metalness: 0.2 })
      );
      boardGroup.add(boardBack);
      
      // Board frame
      const trackerFrameMat = new THREE.MeshStandardMaterial({ color: 0x38bdf8, metalness: 0.6 });
      const frameTop = new THREE.Mesh(new THREE.BoxGeometry(5.1, 0.15, 0.2), trackerFrameMat);
      frameTop.position.y = 3;
      boardGroup.add(frameTop);
      const frameBottom = new THREE.Mesh(new THREE.BoxGeometry(5.1, 0.15, 0.2), trackerFrameMat);
      frameBottom.position.y = -3;
      boardGroup.add(frameBottom);
      
      // Info board content
      const infoBoardCanvas = document.createElement('canvas');
      infoBoardCanvas.width = 512;
      infoBoardCanvas.height = 600;
      const ibCtx = infoBoardCanvas.getContext('2d');
      
      ibCtx.fillStyle = '#0f1a24';
      ibCtx.fillRect(0, 0, 512, 600);
      
      ibCtx.fillStyle = '#ff1493';
      ibCtx.font = 'bold 36px Arial';
      ibCtx.textAlign = 'center';
      ibCtx.fillText('TRACKER SYSTEM', 256, 50);
      
      ibCtx.fillStyle = '#38bdf8';
      ibCtx.font = '18px Arial';
      ibCtx.fillText('Single-Axis Solar Tracking', 256, 80);
      
      ibCtx.strokeStyle = '#38bdf8';
      ibCtx.lineWidth = 2;
      ibCtx.beginPath();
      ibCtx.moveTo(40, 100);
      ibCtx.lineTo(472, 100);
      ibCtx.stroke();
      
      // Left - Nextracker
      ibCtx.fillStyle = '#ff6600';
      ibCtx.font = 'bold 20px Arial';
      ibCtx.textAlign = 'left';
      ibCtx.fillText('‚óÄ NEXTRACKER', 50, 140);
      ibCtx.fillStyle = '#94a3b8';
      ibCtx.font = '14px Arial';
      ibCtx.fillText('‚Ä¢ Compact bearing design', 50, 165);
      ibCtx.fillText('‚Ä¢ Orange X logo badge', 50, 185);
      ibCtx.fillText('‚Ä¢ TrueCapture‚Ñ¢ tech', 50, 205);
      
      // Right - Array
      ibCtx.fillStyle = '#38bdf8';
      ibCtx.font = 'bold 20px Arial';
      ibCtx.fillText('ARRAY TECH ‚ñ∂', 280, 140);
      ibCtx.fillStyle = '#94a3b8';
      ibCtx.font = '14px Arial';
      ibCtx.fillText('‚Ä¢ Shield plate design', 280, 165);
      ibCtx.fillText('‚Ä¢ Flame-shaped cutouts', 280, 185);
      ibCtx.fillText('‚Ä¢ DuraTrack HZ v3', 280, 205);
      
      // Components
      ibCtx.fillStyle = '#38bdf8';
      ibCtx.font = 'bold 18px Arial';
      ibCtx.textAlign = 'center';
      ibCtx.fillText('KEY COMPONENTS', 256, 260);
      
      ibCtx.font = '14px Arial';
      ibCtx.textAlign = 'left';
      ibCtx.fillStyle = '#64748b';
      ibCtx.fillText('Torque Tube', 50, 295);
      ibCtx.fillStyle = '#94a3b8';
      ibCtx.fillText('Steel tube connecting panels', 170, 295);
      
      ibCtx.fillStyle = '#64748b';
      ibCtx.fillText('Bearing', 50, 325);
      ibCtx.fillStyle = '#94a3b8';
      ibCtx.fillText('Rotation mechanism', 170, 325);
      
      ibCtx.fillStyle = '#64748b';
      ibCtx.fillText('W-Beam Post', 50, 355);
      ibCtx.fillStyle = '#94a3b8';
      ibCtx.fillText('Driven pile foundation', 170, 355);
      
      // Stats boxes
      ibCtx.fillStyle = '#1e293b';
      ibCtx.fillRect(40, 400, 200, 70);
      ibCtx.fillRect(270, 400, 200, 70);
      
      ibCtx.fillStyle = '#ff1493';
      ibCtx.font = 'bold 28px Arial';
      ibCtx.textAlign = 'center';
      ibCtx.fillText('+25%', 140, 445);
      ibCtx.fillText('¬±60¬∞', 370, 445);
      
      ibCtx.fillStyle = '#64748b';
      ibCtx.font = '12px Arial';
      ibCtx.fillText('MORE ENERGY', 140, 465);
      ibCtx.fillText('ROTATION', 370, 465);
      
      ibCtx.fillStyle = '#475569';
      ibCtx.font = '12px Arial';
      ibCtx.fillText('Panels follow sun east to west daily', 256, 520);
      
      const infoBoardTexture = new THREE.CanvasTexture(infoBoardCanvas);
      const infoBoardMesh = new THREE.Mesh(
        new THREE.PlaneGeometry(4.8, 5.7),
        new THREE.MeshBasicMaterial({ map: infoBoardTexture })
      );
      // Face forward (toward camera)
      infoBoardMesh.position.z = 0.1;
      boardGroup.add(infoBoardMesh);
      
      // Position board to the far left, facing forward
      boardGroup.position.set(-10, 3.5, 6);
      boardGroup.rotation.y = 0; // Face forward
      demoTracker.add(boardGroup);
      
      // === TRACKER COMPONENTS ===
      const demoPostMat = new THREE.MeshStandardMaterial({ color: 0x666666, metalness: 0.5, roughness: 0.4 });
      const demoPostHeight = 5;
      
      // === BEARING LABELS ===
      // Nextracker label (below left bearing) - BIG AND VISIBLE
      const nexLabel = document.createElement('canvas');
      nexLabel.width = 512;
      nexLabel.height = 128;
      const nexCtx = nexLabel.getContext('2d');
      // Dark background for contrast
      nexCtx.fillStyle = '#0a1520';
      nexCtx.fillRect(0, 0, 512, 128);
      // Orange border
      nexCtx.strokeStyle = '#ff6600';
      nexCtx.lineWidth = 6;
      nexCtx.strokeRect(3, 3, 506, 122);
      // Orange text
      nexCtx.fillStyle = '#ff6600';
      nexCtx.font = 'bold 56px Arial';
      nexCtx.textAlign = 'center';
      nexCtx.fillText('NEXTRACKER', 256, 82);
      const nexLabelTexture = new THREE.CanvasTexture(nexLabel);
      const nexLabelMesh = new THREE.Mesh(
        new THREE.PlaneGeometry(4, 1),
        new THREE.MeshBasicMaterial({ map: nexLabelTexture, transparent: false })
      );
      nexLabelMesh.position.set(-2, 1, 3);
      demoTracker.add(nexLabelMesh);
      
      // Array Technologies label (below right bearing) - BIG AND VISIBLE
      const arrLabel = document.createElement('canvas');
      arrLabel.width = 512;
      arrLabel.height = 128;
      const arrCtx = arrLabel.getContext('2d');
      // Dark background for contrast
      arrCtx.fillStyle = '#0a1520';
      arrCtx.fillRect(0, 0, 512, 128);
      // Blue border
      arrCtx.strokeStyle = '#38bdf8';
      arrCtx.lineWidth = 6;
      arrCtx.strokeRect(3, 3, 506, 122);
      // Blue text
      arrCtx.fillStyle = '#38bdf8';
      arrCtx.font = 'bold 36px Arial';
      arrCtx.textAlign = 'center';
      arrCtx.fillText('ARRAY TECHNOLOGIES', 256, 78);
      const arrLabelTexture = new THREE.CanvasTexture(arrLabel);
      const arrLabelMesh = new THREE.Mesh(
        new THREE.PlaneGeometry(4, 1),
        new THREE.MeshBasicMaterial({ map: arrLabelTexture, transparent: false })
      );
      arrLabelMesh.position.set(3, 1, 3);
      demoTracker.add(arrLabelMesh);
      
      const demoPostWeb = new THREE.Mesh(
        new THREE.BoxGeometry(0.25, demoPostHeight, 0.6),
        demoPostMat
      );
      demoPostWeb.position.set(0, demoPostHeight / 2, 0);
      demoPostWeb.castShadow = true;
      demoTracker.add(demoPostWeb);
      
      const demoFlange1 = new THREE.Mesh(
        new THREE.BoxGeometry(0.6, demoPostHeight, 0.1),
        demoPostMat
      );
      demoFlange1.position.set(0, demoPostHeight / 2, 0.28);
      demoTracker.add(demoFlange1);
      
      const demoFlange2 = new THREE.Mesh(
        new THREE.BoxGeometry(0.6, demoPostHeight, 0.1),
        demoPostMat
      );
      demoFlange2.position.set(0, demoPostHeight / 2, -0.28);
      demoTracker.add(demoFlange2);
      
      const demoTubeMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.6, roughness: 0.3 });
      const demoTube = new THREE.Mesh(
        new THREE.CylinderGeometry(0.35, 0.35, 10, 16),
        demoTubeMat
      );
      demoTube.rotation.z = Math.PI / 2;
      demoTube.position.y = demoPostHeight;
      demoTracker.add(demoTube);
      
      // === NEXTRACKER BEARING (left) ===
      const nexClampMat = new THREE.MeshStandardMaterial({ color: 0x505050, metalness: 0.75, roughness: 0.25 });
      
      const nexBearingBox = new THREE.Mesh(
        new THREE.BoxGeometry(0.6, 0.9, 0.8),
        nexClampMat
      );
      nexBearingBox.position.set(-2, demoPostHeight, 0);
      demoTracker.add(nexBearingBox);
      
      const nexEar1 = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.2, 0.2), nexClampMat);
      nexEar1.position.set(-2, demoPostHeight + 0.4, 0.45);
      demoTracker.add(nexEar1);
      
      const nexEar2 = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.2, 0.2), nexClampMat);
      nexEar2.position.set(-2, demoPostHeight + 0.4, -0.45);
      demoTracker.add(nexEar2);
      
      const orangeMat = new THREE.MeshStandardMaterial({ color: 0xff6600, emissive: 0xff4400, emissiveIntensity: 0.15 });
      const nexBadge = new THREE.Mesh(
        new THREE.CylinderGeometry(0.35, 0.35, 0.1, 24),
        orangeMat
      );
      nexBadge.rotation.x = Math.PI / 2;
      nexBadge.position.set(-2, demoPostHeight - 0.2, 0.5);
      demoTracker.add(nexBadge);
      
      const whiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
      const xBar1 = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.4, 0.03), whiteMat);
      xBar1.rotation.z = Math.PI / 4;
      xBar1.rotation.x = Math.PI / 2;
      xBar1.position.set(-2, demoPostHeight - 0.2, 0.56);
      demoTracker.add(xBar1);
      
      const xBar2 = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.4, 0.03), whiteMat);
      xBar2.rotation.z = -Math.PI / 4;
      xBar2.rotation.x = Math.PI / 2;
      xBar2.position.set(-2, demoPostHeight - 0.2, 0.56);
      demoTracker.add(xBar2);
      
      // === ARRAY TECHNOLOGIES STYLE BEARING (right side) ===
      // Half-circle plate - FLAT EDGE VERTICAL, curve bulges to side
      const darkGalvMat = new THREE.MeshStandardMaterial({ color: 0x808080, metalness: 0.6, roughness: 0.3 });
      const boltMat = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, metalness: 0.9 });
      
      const fanRadius = 2.5;
      const fanThickness = 0.1;
      
      // Create half-circle with FLAT EDGE VERTICAL, curve bulging sideways
      const halfCircleShape = new THREE.Shape();
      halfCircleShape.moveTo(0, -fanRadius); // Bottom of vertical flat edge
      halfCircleShape.lineTo(0, fanRadius);   // Top of vertical flat edge
      halfCircleShape.absarc(0, 0, fanRadius, Math.PI/2, -Math.PI/2, true); // Curve bulges to +X
      
      const extrudeSettings = { depth: fanThickness, bevelEnabled: false };
      const halfCircleGeo = new THREE.ExtrudeGeometry(halfCircleShape, extrudeSettings);
      
      // Create canvas texture with "ARRAY" text
      const arrayFanCanvas = document.createElement('canvas');
      arrayFanCanvas.width = 512;
      arrayFanCanvas.height = 512;
      const afCtx = arrayFanCanvas.getContext('2d');
      
      // Gray metallic background
      afCtx.fillStyle = '#b8b8b8';
      afCtx.fillRect(0, 0, 512, 512);
      
      // Add subtle texture
      afCtx.fillStyle = '#a8a8a8';
      for (let i = 0; i < 150; i++) {
        afCtx.fillRect(Math.random() * 512, Math.random() * 512, 2, 2);
      }
      
      // Draw "ARRAY" vertically
      afCtx.fillStyle = '#505050';
      afCtx.font = 'bold 72px Arial';
      afCtx.textAlign = 'center';
      ['A', 'R', 'R', 'A', 'Y'].forEach((letter, idx) => {
        afCtx.fillText(letter, 256, 100 + idx * 75);
      });
      
      // Perforations along curve
      afCtx.fillStyle = '#303030';
      for (let i = 0; i < 14; i++) {
        const angle = -Math.PI/2 + (i / 13) * Math.PI;
        const cx = 256 + Math.cos(angle) * 200;
        const cy = 256 + Math.sin(angle) * 200;
        afCtx.beginPath();
        afCtx.arc(cx, cy, 10, 0, Math.PI * 2);
        afCtx.fill();
      }
      
      const arrayFanTexture = new THREE.CanvasTexture(arrayFanCanvas);
      
      const plateMat = new THREE.MeshStandardMaterial({ 
        map: arrayFanTexture,
        metalness: 0.55, 
        roughness: 0.35,
        side: THREE.DoubleSide
      });
      
      const halfCirclePlate = new THREE.Mesh(halfCircleGeo, plateMat);
      // Position so torque tube goes through center, curve bulges outward (+Z)
      halfCirclePlate.rotation.y = Math.PI / 2;
      halfCirclePlate.position.set(2, demoPostHeight, 0);
      demoTracker.add(halfCirclePlate);
      
      // Center tube clamp/bearing housing
      const clampHousing = new THREE.Mesh(
        new THREE.CylinderGeometry(0.5, 0.5, 0.6, 24),
        darkGalvMat
      );
      clampHousing.rotation.z = Math.PI / 2;
      clampHousing.position.set(2.0, demoPostHeight, 0);
      demoTracker.add(clampHousing);
      
      // Central pivot bolt
      const pivotBolt = new THREE.Mesh(
        new THREE.CylinderGeometry(0.15, 0.15, 0.7, 12),
        boltMat
      );
      pivotBolt.rotation.z = Math.PI / 2;
      pivotBolt.position.set(2, demoPostHeight, 0);
      demoTracker.add(pivotBolt);
      
      // Mounting bolts on plate
      const plateBoltPositions = [
        { y: 0.6, z: 0.5 }, { y: 0.6, z: -0.5 },
        { y: -0.6, z: 0.5 }, { y: -0.6, z: -0.5 },
        { y: 1.2, z: 0.3 }, { y: 1.2, z: -0.3 },
        { y: -1.2, z: 0.3 }, { y: -1.2, z: -0.3 },
        { y: 1.8, z: 0 }, { y: -1.8, z: 0 }
      ];
      plateBoltPositions.forEach(bp => {
        const bolt = new THREE.Mesh(
          new THREE.CylinderGeometry(0.05, 0.05, 0.16, 6),
          boltMat
        );
        bolt.rotation.z = Math.PI / 2;
        bolt.position.set(2 + 0.08, demoPostHeight + bp.y, bp.z);
        demoTracker.add(bolt);
      });
      
      // Small demo panels on the torque tube
      const demoPanelMat = new THREE.MeshStandardMaterial({ color: 0x1a3a5c, metalness: 0.4, roughness: 0.3 });
      for (let dp = -2; dp <= 2; dp++) {
        const demoPanel = new THREE.Mesh(
          new THREE.BoxGeometry(1.8, 0.08, 1),
          demoPanelMat
        );
        demoPanel.position.set(dp * 2, demoPostHeight + 0.4, 0);
        demoTracker.add(demoPanel);
      }
      
      // Position the demo tracker
      demoTracker.position.set(0, 0, 50);
      demoTracker.visible = false; // Hidden by default - shown via detail view
      // Don't add to scene yet - will be added when user clicks to view
      demoTrackerGroup = demoTracker; // Save reference for later
      
      // === DEMO COMBINER BOX DISPLAY MODEL ===
      // Professional museum-style combiner exhibit
      const demoCombiner = new THREE.Group();
      
      // === DISPLAY PLATFORM ===
      const combinerPad = new THREE.Mesh(
        new THREE.BoxGeometry(14, 0.4, 12),
        new THREE.MeshStandardMaterial({ color: 0x2a3a4a, roughness: 0.6, metalness: 0.3 })
      );
      combinerPad.position.y = 0.2;
      demoCombiner.add(combinerPad);
      
      // Platform edge trim (accent color - green for combiner)
      const combinerEdgeTrim = new THREE.Mesh(
        new THREE.BoxGeometry(14.2, 0.15, 12.2),
        new THREE.MeshStandardMaterial({ color: 0x10b981, metalness: 0.6 })
      );
      combinerEdgeTrim.position.y = 0.42;
      demoCombiner.add(combinerEdgeTrim);
      
      // === INFO BOARD (positioned to the left side) ===
      const combinerBoardGroup = new THREE.Group();
      
      // Board backing (facing forward)
      const combinerBoardBack = new THREE.Mesh(
        new THREE.BoxGeometry(5, 6, 0.15),
        new THREE.MeshStandardMaterial({ color: 0x1a2a3a, metalness: 0.2 })
      );
      combinerBoardGroup.add(combinerBoardBack);
      
      // Board frame
      const combinerFrameMat = new THREE.MeshStandardMaterial({ color: 0x10b981, metalness: 0.6 });
      const cFrameTop = new THREE.Mesh(new THREE.BoxGeometry(5.1, 0.15, 0.2), combinerFrameMat);
      cFrameTop.position.y = 3;
      combinerBoardGroup.add(cFrameTop);
      const cFrameBottom = new THREE.Mesh(new THREE.BoxGeometry(5.1, 0.15, 0.2), combinerFrameMat);
      cFrameBottom.position.y = -3;
      combinerBoardGroup.add(cFrameBottom);
      
      // Combiner info board content
      const combinerInfoCanvas = document.createElement('canvas');
      combinerInfoCanvas.width = 512;
      combinerInfoCanvas.height = 600;
      const ciCtx = combinerInfoCanvas.getContext('2d');
      
      ciCtx.fillStyle = '#0f1a24';
      ciCtx.fillRect(0, 0, 512, 600);
      
      ciCtx.fillStyle = '#10b981';
      ciCtx.font = 'bold 32px Arial';
      ciCtx.textAlign = 'center';
      ciCtx.fillText('DC COMBINER BOX', 256, 50);
      
      ciCtx.fillStyle = '#38bdf8';
      ciCtx.font = '16px Arial';
      ciCtx.fillText('Electrical Distribution Panel', 256, 78);
      
      ciCtx.strokeStyle = '#10b981';
      ciCtx.lineWidth = 2;
      ciCtx.beginPath();
      ciCtx.moveTo(40, 100);
      ciCtx.lineTo(472, 100);
      ciCtx.stroke();
      
      // Component Guide
      ciCtx.fillStyle = '#fff';
      ciCtx.font = 'bold 16px Arial';
      ciCtx.textAlign = 'left';
      ciCtx.fillText('COMPONENT GUIDE', 50, 130);
      
      ciCtx.font = '14px Arial';
      
      // Red
      ciCtx.fillStyle = '#f66';
      ciCtx.fillRect(50, 150, 16, 16);
      ciCtx.fillStyle = '#94a3b8';
      ciCtx.fillText('DC+ String Inputs (Red)', 75, 163);
      
      // Black
      ciCtx.fillStyle = '#444';
      ciCtx.fillRect(50, 180, 16, 16);
      ciCtx.fillStyle = '#94a3b8';
      ciCtx.fillText('DC- Terminals (Black)', 75, 193);
      
      // Yellow
      ciCtx.fillStyle = '#fc0';
      ciCtx.fillRect(50, 210, 16, 16);
      ciCtx.fillStyle = '#94a3b8';
      ciCtx.fillText('Fuses - 15A (Yellow)', 75, 223);
      
      // Blue
      ciCtx.fillStyle = '#08f';
      ciCtx.fillRect(50, 240, 16, 16);
      ciCtx.fillStyle = '#94a3b8';
      ciCtx.fillText('Surge Protection (Blue)', 75, 253);
      
      // Copper
      ciCtx.fillStyle = '#b87333';
      ciCtx.fillRect(50, 270, 16, 16);
      ciCtx.fillStyle = '#94a3b8';
      ciCtx.fillText('Bus Bars (Copper)', 75, 283);
      
      // Green light
      ciCtx.fillStyle = '#0f0';
      ciCtx.beginPath();
      ciCtx.arc(58, 308, 8, 0, Math.PI * 2);
      ciCtx.fill();
      ciCtx.fillStyle = '#94a3b8';
      ciCtx.fillText('SPD Status OK (Green)', 75, 313);
      
      // Key Functions
      ciCtx.fillStyle = '#fff';
      ciCtx.font = 'bold 16px Arial';
      ciCtx.fillText('KEY FUNCTIONS', 50, 360);
      
      ciCtx.font = '13px Arial';
      ciCtx.fillStyle = '#64748b';
      ciCtx.fillText('1.', 50, 385);
      ciCtx.fillStyle = '#94a3b8';
      ciCtx.fillText('Aggregates multiple strings', 70, 385);
      
      ciCtx.fillStyle = '#64748b';
      ciCtx.fillText('2.', 50, 408);
      ciCtx.fillStyle = '#94a3b8';
      ciCtx.fillText('Overcurrent protection (fuses)', 70, 408);
      
      ciCtx.fillStyle = '#64748b';
      ciCtx.fillText('3.', 50, 431);
      ciCtx.fillStyle = '#94a3b8';
      ciCtx.fillText('Surge protection (SPD)', 70, 431);
      
      ciCtx.fillStyle = '#64748b';
      ciCtx.fillText('4.', 50, 454);
      ciCtx.fillStyle = '#94a3b8';
      ciCtx.fillText('Output to inverter', 70, 454);
      
      // Stats
      ciCtx.fillStyle = '#1e293b';
      ciCtx.fillRect(40, 485, 200, 60);
      ciCtx.fillRect(270, 485, 200, 60);
      
      ciCtx.fillStyle = '#10b981';
      ciCtx.font = 'bold 24px Arial';
      ciCtx.textAlign = 'center';
      ciCtx.fillText('8 STRINGS', 140, 522);
      ciCtx.fillText('1500V DC', 370, 522);
      
      ciCtx.fillStyle = '#64748b';
      ciCtx.font = '11px Arial';
      ciCtx.fillText('INPUT CAPACITY', 140, 540);
      ciCtx.fillText('MAX VOLTAGE', 370, 540);
      
      const combinerInfoTexture = new THREE.CanvasTexture(combinerInfoCanvas);
      const combinerInfoMesh = new THREE.Mesh(
        new THREE.PlaneGeometry(4.8, 5.7),
        new THREE.MeshBasicMaterial({ map: combinerInfoTexture })
      );
      // Face forward (toward camera)
      combinerInfoMesh.position.z = 0.1;
      combinerBoardGroup.add(combinerInfoMesh);
      
      // Position board to the right side, facing forward
      combinerBoardGroup.position.set(6, 3.5, 4);
      combinerBoardGroup.rotation.y = 0;
      demoCombiner.add(combinerBoardGroup);
      
      // === COMBINER BOX COMPONENTS ===
      // Mounting post
      const combinerPostMat = new THREE.MeshStandardMaterial({ color: 0x666666, metalness: 0.5, roughness: 0.4 });
      const combinerPost = new THREE.Mesh(
        new THREE.BoxGeometry(0.3, 4, 0.3),
        combinerPostMat
      );
      combinerPost.position.set(-1.5, 2, 0);
      combinerPost.castShadow = true;
      demoCombiner.add(combinerPost);
      
      // === MAIN ENCLOSURE (NEMA rated box) - OPEN DOOR VIEW ===
      const enclosureMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.4, roughness: 0.5 });
      const enclosureDarkMat = new THREE.MeshStandardMaterial({ color: 0x999999, metalness: 0.5, roughness: 0.4 });
      
      // Main box body (back, sides, top, bottom - no front)
      const boxWidth = 3.5;
      const boxHeight = 4.5;
      const boxDepth = 1.0;
      
      // Back panel
      const backPanel = new THREE.Mesh(
        new THREE.BoxGeometry(boxWidth, boxHeight, 0.1),
        enclosureMat
      );
      backPanel.position.set(0, 2.5, -boxDepth / 2);
      demoCombiner.add(backPanel);
      
      // Left side panel
      const leftPanel = new THREE.Mesh(
        new THREE.BoxGeometry(0.1, boxHeight, boxDepth),
        enclosureMat
      );
      leftPanel.position.set(-boxWidth / 2, 2.5, 0);
      demoCombiner.add(leftPanel);
      
      // Right side panel
      const rightPanel = new THREE.Mesh(
        new THREE.BoxGeometry(0.1, boxHeight, boxDepth),
        enclosureMat
      );
      rightPanel.position.set(boxWidth / 2, 2.5, 0);
      demoCombiner.add(rightPanel);
      
      // Top panel
      const topPanel = new THREE.Mesh(
        new THREE.BoxGeometry(boxWidth, 0.1, boxDepth),
        enclosureMat
      );
      topPanel.position.set(0, 2.5 + boxHeight / 2, 0);
      demoCombiner.add(topPanel);
      
      // Bottom panel
      const bottomPanel = new THREE.Mesh(
        new THREE.BoxGeometry(boxWidth, 0.1, boxDepth),
        enclosureMat
      );
      bottomPanel.position.set(0, 2.5 - boxHeight / 2, 0);
      demoCombiner.add(bottomPanel);
      
      // === OPEN DOOR (swung to the right side) ===
      const doorGroup = new THREE.Group();
      
      // Door panel
      const doorPanel = new THREE.Mesh(
        new THREE.BoxGeometry(boxWidth - 0.2, boxHeight - 0.2, 0.12),
        enclosureDarkMat
      );
      doorGroup.add(doorPanel);
      
      // Door handle on inside
      const handleMat = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.8 });
      const doorHandle = new THREE.Mesh(
        new THREE.BoxGeometry(0.12, 0.5, 0.12),
        handleMat
      );
      doorHandle.position.set(-boxWidth / 2 + 0.4, 0, -0.1);
      doorGroup.add(doorHandle);
      
      // Warning label on inside of door
      const warningCanvas = document.createElement('canvas');
      warningCanvas.width = 256;
      warningCanvas.height = 128;
      const warnCtx = warningCanvas.getContext('2d');
      warnCtx.fillStyle = '#ffcc00';
      warnCtx.fillRect(0, 0, 256, 128);
      warnCtx.fillStyle = '#000';
      warnCtx.font = 'bold 24px Arial';
      warnCtx.textAlign = 'center';
      warnCtx.fillText('‚ö° DANGER', 128, 40);
      warnCtx.font = '16px Arial';
      warnCtx.fillText('HIGH VOLTAGE', 128, 70);
      warnCtx.fillText('1500V DC', 128, 95);
      const warnTexture = new THREE.CanvasTexture(warningCanvas);
      const warnLabel = new THREE.Mesh(
        new THREE.PlaneGeometry(1.2, 0.6),
        new THREE.MeshBasicMaterial({ map: warnTexture })
      );
      warnLabel.position.set(0, 1.2, -0.08);
      warnLabel.rotation.y = Math.PI;
      doorGroup.add(warnLabel);
      
      // Position door - swung open 110 degrees to the right
      doorGroup.position.set(boxWidth / 2 - 0.1, 2.5, boxDepth / 2);
      doorGroup.rotation.y = -Math.PI * 0.6; // Open angle
      demoCombiner.add(doorGroup);
      
      // Door hinge pins
      const hingeMat = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.8 });
      const hingeTop = new THREE.Mesh(
        new THREE.CylinderGeometry(0.08, 0.08, 0.3, 8),
        hingeMat
      );
      hingeTop.position.set(boxWidth / 2 - 0.05, 4.2, boxDepth / 2);
      demoCombiner.add(hingeTop);
      
      const hingeBottom = new THREE.Mesh(
        new THREE.CylinderGeometry(0.08, 0.08, 0.3, 8),
        hingeMat
      );
      hingeBottom.position.set(boxWidth / 2 - 0.05, 0.8, boxDepth / 2);
      demoCombiner.add(hingeBottom);
      
      // === INTERNAL BACKPLATE (gray mounting plate) ===
      const backplateMat = new THREE.MeshStandardMaterial({ color: 0x666666, metalness: 0.3 });
      const backplate = new THREE.Mesh(
        new THREE.BoxGeometry(boxWidth - 0.3, boxHeight - 0.3, 0.08),
        backplateMat
      );
      backplate.position.set(0, 2.5, -boxDepth / 2 + 0.15);
      demoCombiner.add(backplate);
      
      // === DIN RAILS (for mounting components) ===
      const dinRailMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.6 });
      for (let r = 0; r < 3; r++) {
        const dinRail = new THREE.Mesh(
          new THREE.BoxGeometry(boxWidth - 0.5, 0.15, 0.12),
          dinRailMat
        );
        dinRail.position.set(0, 3.8 - r * 1.2, -boxDepth / 2 + 0.25);
        demoCombiner.add(dinRail);
      }
      
      // === DC INPUT TERMINALS (Red & Black - visible from front) ===
      const dcPlusMat = new THREE.MeshStandardMaterial({ color: 0xcc3333, emissive: 0x331111 });
      const dcMinusMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
      
      // String inputs - 8 pairs arranged in two rows
      for (let i = 0; i < 8; i++) {
        const row = Math.floor(i / 4);
        const col = i % 4;
        const xPos = -1.2 + col * 0.55;
        const yPos = 3.7 - row * 0.7;
        
        // DC+ terminal block (red)
        const dcPlusTerminal = new THREE.Mesh(
          new THREE.BoxGeometry(0.2, 0.25, 0.35),
          dcPlusMat
        );
        dcPlusTerminal.position.set(xPos, yPos, -boxDepth / 2 + 0.4);
        demoCombiner.add(dcPlusTerminal);
        
        // DC- terminal block (black) next to it
        const dcMinusTerminal = new THREE.Mesh(
          new THREE.BoxGeometry(0.2, 0.25, 0.35),
          dcMinusMat
        );
        dcMinusTerminal.position.set(xPos + 0.25, yPos, -boxDepth / 2 + 0.4);
        demoCombiner.add(dcMinusTerminal);
        
        // Input cable coming in from top (red)
        const inputCable = new THREE.Mesh(
          new THREE.CylinderGeometry(0.04, 0.04, 0.8, 8),
          dcPlusMat
        );
        inputCable.position.set(xPos, yPos + 0.5, -boxDepth / 2 + 0.4);
        demoCombiner.add(inputCable);
        
        // String number label
        const strNum = i + 1;
        const strCanvas = document.createElement('canvas');
        strCanvas.width = 64;
        strCanvas.height = 64;
        const strCtx = strCanvas.getContext('2d');
        strCtx.fillStyle = '#fff';
        strCtx.font = 'bold 32px Arial';
        strCtx.textAlign = 'center';
        strCtx.fillText(strNum.toString(), 32, 42);
        const strTexture = new THREE.CanvasTexture(strCanvas);
        const strLabel = new THREE.Mesh(
          new THREE.PlaneGeometry(0.25, 0.25),
          new THREE.MeshBasicMaterial({ map: strTexture, transparent: true })
        );
        strLabel.position.set(xPos + 0.1, yPos - 0.25, -boxDepth / 2 + 0.58);
        demoCombiner.add(strLabel);
      }
      
      // === FUSE HOLDERS WITH YELLOW FUSES ===
      const fuseMat = new THREE.MeshStandardMaterial({ color: 0xffcc00, emissive: 0x665500, emissiveIntensity: 0.4 });
      const fuseHolderMat = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.6 });
      
      for (let i = 0; i < 8; i++) {
        const row = Math.floor(i / 4);
        const col = i % 4;
        const xPos = -1.1 + col * 0.55;
        const yPos = 2.4 - row * 0.6;
        
        // Fuse holder base (dark gray)
        const fuseHolder = new THREE.Mesh(
          new THREE.BoxGeometry(0.4, 0.35, 0.35),
          fuseHolderMat
        );
        fuseHolder.position.set(xPos, yPos, -boxDepth / 2 + 0.35);
        demoCombiner.add(fuseHolder);
        
        // Fuse (bright yellow cylinder - stands out)
        const fuse = new THREE.Mesh(
          new THREE.CylinderGeometry(0.08, 0.08, 0.5, 12),
          fuseMat
        );
        fuse.rotation.z = Math.PI / 2;
        fuse.position.set(xPos, yPos + 0.05, -boxDepth / 2 + 0.5);
        demoCombiner.add(fuse);
        
        // Fuse rating label
        if (col === 0) {
          const fuseRatingCanvas = document.createElement('canvas');
          fuseRatingCanvas.width = 128;
          fuseRatingCanvas.height = 32;
          const frCtx = fuseRatingCanvas.getContext('2d');
          frCtx.fillStyle = '#ffcc00';
          frCtx.font = 'bold 18px Arial';
          frCtx.fillText('15A FUSES', 5, 22);
          const frTexture = new THREE.CanvasTexture(fuseRatingCanvas);
          const frLabel = new THREE.Mesh(
            new THREE.PlaneGeometry(0.8, 0.2),
            new THREE.MeshBasicMaterial({ map: frTexture, transparent: true })
          );
          frLabel.position.set(xPos + 0.8, yPos + 0.35, -boxDepth / 2 + 0.6);
          demoCombiner.add(frLabel);
        }
      }
      
      // === SURGE PROTECTION DEVICE (SPD - Blue, prominent) ===
      const spdMat = new THREE.MeshStandardMaterial({ color: 0x0066cc, emissive: 0x003366, emissiveIntensity: 0.3 });
      
      // SPD housing (larger, more visible)
      const spd = new THREE.Mesh(
        new THREE.BoxGeometry(0.8, 1.4, 0.5),
        spdMat
      );
      spd.position.set(1.1, 2.2, -boxDepth / 2 + 0.45);
      demoCombiner.add(spd);
      
      // SPD indicator window
      const spdWindowMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
      const spdWindow = new THREE.Mesh(
        new THREE.BoxGeometry(0.4, 0.3, 0.1),
        spdWindowMat
      );
      spdWindow.position.set(1.1, 2.6, -boxDepth / 2 + 0.72);
      demoCombiner.add(spdWindow);
      
      // SPD indicator light (green = OK)
      const spdLightMat = new THREE.MeshStandardMaterial({ color: 0x00ff00, emissive: 0x00ff00, emissiveIntensity: 1.0 });
      const spdLight = new THREE.Mesh(
        new THREE.SphereGeometry(0.1, 16, 16),
        spdLightMat
      );
      spdLight.position.set(1.1, 2.6, -boxDepth / 2 + 0.78);
      demoCombiner.add(spdLight);
      
      // SPD label
      const spdLabelCanvas = document.createElement('canvas');
      spdLabelCanvas.width = 128;
      spdLabelCanvas.height = 64;
      const spdLCtx = spdLabelCanvas.getContext('2d');
      spdLCtx.fillStyle = '#fff';
      spdLCtx.font = 'bold 16px Arial';
      spdLCtx.textAlign = 'center';
      spdLCtx.fillText('SPD', 64, 25);
      spdLCtx.font = '12px Arial';
      spdLCtx.fillText('Type 2', 64, 45);
      const spdLTexture = new THREE.CanvasTexture(spdLabelCanvas);
      const spdLLabel = new THREE.Mesh(
        new THREE.PlaneGeometry(0.5, 0.3),
        new THREE.MeshBasicMaterial({ map: spdLTexture, transparent: true })
      );
      spdLLabel.position.set(1.1, 1.7, -boxDepth / 2 + 0.72);
      demoCombiner.add(spdLLabel);
      
      // === BUS BARS (Copper - positive and negative) ===
      const copperMat = new THREE.MeshStandardMaterial({ color: 0xb87333, metalness: 0.85, roughness: 0.15 });
      
      // Positive bus bar (copper colored)
      const posBusBar = new THREE.Mesh(
        new THREE.BoxGeometry(0.2, 3.5, 0.1),
        copperMat
      );
      posBusBar.position.set(0.5, 2.3, -boxDepth / 2 + 0.25);
      demoCombiner.add(posBusBar);
      
      // Bus bar label +
      const busLabelPlusCanvas = document.createElement('canvas');
      busLabelPlusCanvas.width = 64;
      busLabelPlusCanvas.height = 64;
      const bpCtx = busLabelPlusCanvas.getContext('2d');
      bpCtx.fillStyle = '#c73';
      bpCtx.font = 'bold 48px Arial';
      bpCtx.textAlign = 'center';
      bpCtx.fillText('+', 32, 48);
      const bpTexture = new THREE.CanvasTexture(busLabelPlusCanvas);
      const bpLabel = new THREE.Mesh(
        new THREE.PlaneGeometry(0.3, 0.3),
        new THREE.MeshBasicMaterial({ map: bpTexture, transparent: true })
      );
      bpLabel.position.set(0.5, 4.2, -boxDepth / 2 + 0.35);
      demoCombiner.add(bpLabel);
      
      // Negative bus bar (darker)
      const negBusBar = new THREE.Mesh(
        new THREE.BoxGeometry(0.2, 3.5, 0.1),
        new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.7, roughness: 0.3 })
      );
      negBusBar.position.set(0.8, 2.3, -boxDepth / 2 + 0.25);
      demoCombiner.add(negBusBar);
      
      // Bus bar label -
      const busLabelMinusCanvas = document.createElement('canvas');
      busLabelMinusCanvas.width = 64;
      busLabelMinusCanvas.height = 64;
      const bmCtx = busLabelMinusCanvas.getContext('2d');
      bmCtx.fillStyle = '#666';
      bmCtx.font = 'bold 48px Arial';
      bmCtx.textAlign = 'center';
      bmCtx.fillText('-', 32, 48);
      const bmTexture = new THREE.CanvasTexture(busLabelMinusCanvas);
      const bmLabel = new THREE.Mesh(
        new THREE.PlaneGeometry(0.3, 0.3),
        new THREE.MeshBasicMaterial({ map: bmTexture, transparent: true })
      );
      bmLabel.position.set(0.8, 4.2, -boxDepth / 2 + 0.35);
      demoCombiner.add(bmLabel);
      
      // === OUTPUT CABLES (to inverter - bottom) ===
      // Large output cable (DC+)
      const outputCablePlus = new THREE.Mesh(
        new THREE.CylinderGeometry(0.12, 0.12, 1.5, 12),
        dcPlusMat
      );
      outputCablePlus.position.set(0.5, 0.3, 0.5);
      outputCablePlus.rotation.x = Math.PI / 2;
      demoCombiner.add(outputCablePlus);
      
      // Large output cable (DC-)
      const outputCableMinus = new THREE.Mesh(
        new THREE.CylinderGeometry(0.12, 0.12, 1.5, 12),
        dcMinusMat
      );
      outputCableMinus.position.set(0.8, 0.3, 0.5);
      outputCableMinus.rotation.x = Math.PI / 2;
      demoCombiner.add(outputCableMinus);
      
      // Position the demo combiner
      demoCombiner.position.set(0, 0, 80);
      demoCombiner.visible = false; // Hidden by default - shown via detail view
      // Don't add to scene yet - will be added when user clicks to view
      demoCombinerGroup = demoCombiner; // Save reference for later
      
      // BARBED WIRE FENCE
      const fencePostMat = new THREE.MeshStandardMaterial({ color: 0x4a3520, metalness: 0.3, roughness: 0.7 }); // Wood posts
      const wireMat = new THREE.MeshStandardMaterial({ color: 0x3a3a3a, metalness: 0.8, roughness: 0.3 });
      
      const fenceH = 4;
      const postSpacing = 10;
      const fenceMinX = -280, fenceMaxX = 280, fenceMinZ = -140, fenceMaxZ = 200;
      const wireHeights = [0.5, 1.2, 2.0, 2.8, 3.6]; // 5 strands of barbed wire
      
      function createBarbedWireSide(startX, startZ, endX, endZ) {
        const dx = endX - startX;
        const dz = endZ - startZ;
        const length = Math.sqrt(dx * dx + dz * dz);
        const numPosts = Math.floor(length / postSpacing) + 1;
        const angle = Math.atan2(dz, dx);
        
        // Posts
        for (let i = 0; i <= numPosts; i++) {
          const t = i / numPosts;
          const x = startX + dx * t;
          const z = startZ + dz * t;
          
          // Wooden fence post (T-post or wood post style)
          const post = new THREE.Mesh(
            new THREE.BoxGeometry(0.15, fenceH, 0.15),
            fencePostMat
          );
          post.position.set(x, fenceH / 2, z);
          post.castShadow = true;
          scene.add(post);
          
          // Post top (pointed)
          const postTop = new THREE.Mesh(
            new THREE.ConeGeometry(0.12, 0.3, 4),
            fencePostMat
          );
          postTop.position.set(x, fenceH + 0.15, z);
          postTop.rotation.y = Math.PI / 4;
          scene.add(postTop);
        }
        
        // Barbed wire strands
        wireHeights.forEach(h => {
          const wire = new THREE.Mesh(
            new THREE.CylinderGeometry(0.02, 0.02, length, 6),
            wireMat
          );
          wire.position.set((startX + endX) / 2, h, (startZ + endZ) / 2);
          wire.rotation.z = Math.PI / 2;
          wire.rotation.y = -angle;
          scene.add(wire);
        });
      }
      
      // Create all four sides
      createBarbedWireSide(fenceMinX, fenceMinZ, fenceMaxX, fenceMinZ);
      createBarbedWireSide(fenceMaxX, fenceMinZ, fenceMaxX, fenceMaxZ);
      createBarbedWireSide(fenceMaxX, fenceMaxZ, fenceMinX, fenceMaxZ);
      createBarbedWireSide(fenceMinX, fenceMaxZ, fenceMinX, fenceMinZ);
    }
    
    function createTrackerRow(xCenter, zPos, panelW, panelH, panelGap, panelsPerRow, pileSpacing, pileHeight, tilt, torqueRadius, panelMat, frameMat, torqueMat, postMat, inverterMat, inverterGrayMat, ventMat) {
      const tracker = new THREE.Group();
      const rowLength = panelsPerRow * (panelW + panelGap);
      
      // THICK TORQUE TUBE
      const torqueTube = new THREE.Mesh(
        new THREE.CylinderGeometry(torqueRadius, torqueRadius, rowLength + 3, 16),
        torqueMat
      );
      torqueTube.rotation.z = Math.PI / 2;
      torqueTube.position.y = pileHeight;
      torqueTube.castShadow = true;
      tracker.add(torqueTube);
      
      // POSTS with INVERTERS ON EVERY POST
      const numPiles = Math.floor(rowLength / pileSpacing) + 1;
      for (let i = 0; i <= numPiles; i++) {
        const px = -rowLength / 2 + i * pileSpacing;
        if (Math.abs(px) > rowLength / 2 + 2) continue;
        
        // W-beam post
        const pileWeb = new THREE.Mesh(
          new THREE.BoxGeometry(0.2, pileHeight + 0.4, 0.5),
          postMat
        );
        pileWeb.position.set(px, pileHeight / 2 - 0.2, 0);
        pileWeb.castShadow = true;
        tracker.add(pileWeb);
        
        // Flanges
        const flange1 = new THREE.Mesh(
          new THREE.BoxGeometry(0.5, pileHeight + 0.4, 0.08),
          postMat
        );
        flange1.position.set(px, pileHeight / 2 - 0.2, 0.22);
        tracker.add(flange1);
        
        const flange2 = new THREE.Mesh(
          new THREE.BoxGeometry(0.5, pileHeight + 0.4, 0.08),
          postMat
        );
        flange2.position.set(px, pileHeight / 2 - 0.2, -0.22);
        tracker.add(flange2);
        
        // === REALISTIC TRACKER BEARING ASSEMBLY ===
        // Alternates between Array Technologies and Nextracker styles
        const isArrayStyle = i % 2 === 0; // Alternate styles
        
        const galvanizedMat = new THREE.MeshStandardMaterial({ color: 0xa5a5a5, metalness: 0.65, roughness: 0.25 });
        const darkGalvMat = new THREE.MeshStandardMaterial({ color: 0x707070, metalness: 0.6, roughness: 0.3 });
        const boltMat = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, metalness: 0.9, roughness: 0.15 });
        
        if (isArrayStyle) {
          // === ARRAY TECHNOLOGIES STYLE ===
          // Half-circle plate - FLAT EDGE VERTICAL, curve bulges to side
          
          const clampMat = new THREE.MeshStandardMaterial({ color: 0x909090, metalness: 0.7, roughness: 0.25 });
          
          // Tube clamp housing
          const clampRadius = torqueRadius + 0.12;
          const tubeClamp = new THREE.Mesh(
            new THREE.CylinderGeometry(clampRadius + 0.08, clampRadius + 0.08, 0.4, 20),
            clampMat
          );
          tubeClamp.rotation.z = Math.PI / 2;
          tubeClamp.position.set(px, pileHeight, 0);
          tracker.add(tubeClamp);
          
          const fanRadius = 1.8;
          const fanThickness = 0.06;
          
          // Create half-circle with FLAT EDGE VERTICAL, curve bulging sideways
          const halfCircleShape = new THREE.Shape();
          halfCircleShape.moveTo(0, -fanRadius); // Bottom of vertical flat edge
          halfCircleShape.lineTo(0, fanRadius);   // Top of vertical flat edge
          halfCircleShape.absarc(0, 0, fanRadius, Math.PI/2, -Math.PI/2, true); // Curve bulges to +X
          
          const extrudeSettings = { depth: fanThickness, bevelEnabled: false };
          const halfCircleGeo = new THREE.ExtrudeGeometry(halfCircleShape, extrudeSettings);
          
          // Create canvas texture with "ARRAY" text
          const arrayCanvas = document.createElement('canvas');
          arrayCanvas.width = 256;
          arrayCanvas.height = 256;
          const actx = arrayCanvas.getContext('2d');
          
          // Gray metallic background
          actx.fillStyle = '#b0b0b0';
          actx.fillRect(0, 0, 256, 256);
          
          // Draw "ARRAY" vertically
          actx.fillStyle = '#606060';
          actx.font = 'bold 36px Arial';
          actx.textAlign = 'center';
          ['A', 'R', 'R', 'A', 'Y'].forEach((letter, idx) => {
            actx.fillText(letter, 128, 55 + idx * 38);
          });
          
          // Perforations along curve
          actx.fillStyle = '#404040';
          for (let i = 0; i < 10; i++) {
            const angle = -Math.PI/2 + (i / 9) * Math.PI;
            actx.beginPath();
            actx.arc(128 + Math.cos(angle) * 100, 128 + Math.sin(angle) * 100, 6, 0, Math.PI * 2);
            actx.fill();
          }
          
          const arrayTexture = new THREE.CanvasTexture(arrayCanvas);
          
          const plateMat = new THREE.MeshStandardMaterial({ 
            map: arrayTexture,
            metalness: 0.5, 
            roughness: 0.4,
            side: THREE.DoubleSide
          });
          
          const halfCirclePlate = new THREE.Mesh(halfCircleGeo, plateMat);
          // Position so torque tube goes through center, curve bulges outward
          halfCirclePlate.rotation.y = Math.PI / 2;
          halfCirclePlate.position.set(px, pileHeight, 0);
          tracker.add(halfCirclePlate);
          
          // Store reference for highlighting
          bearingPlates.push({ mesh: halfCirclePlate, rowZ: zPos, xCenter: xCenter, originalMat: plateMat, isHighlighted: false });
          
          // Center bearing bolt
          const pivotBolt = new THREE.Mesh(
            new THREE.CylinderGeometry(0.1, 0.1, 0.4, 12),
            boltMat
          );
          pivotBolt.rotation.z = Math.PI / 2;
          pivotBolt.position.set(px, pileHeight, 0);
          tracker.add(pivotBolt);
          
          // Mounting bolts
          const boltPositions = [
            { y: 0.5, z: 0.3 }, { y: 0.5, z: -0.3 },
            { y: -0.5, z: 0.3 }, { y: -0.5, z: -0.3 },
            { y: 1.0, z: 0 }, { y: -1.0, z: 0 }
          ];
          boltPositions.forEach(bp => {
            const bolt = new THREE.Mesh(
              new THREE.CylinderGeometry(0.035, 0.035, 0.12, 6),
              boltMat
            );
            bolt.rotation.z = Math.PI / 2;
            bolt.position.set(px + 0.05, pileHeight + bp.y, bp.z);
            tracker.add(bolt);
          });
          
        } else {
          // === NEXTRACKER STYLE ===
          // Compact bearing with prominent orange X badge (matches reference image)
          
          const housingRadius = torqueRadius + 0.25;
          const nexClampMat = new THREE.MeshStandardMaterial({ color: 0x505050, metalness: 0.75, roughness: 0.25 });
          
          // Bearing housing (rectangular box style like in reference)
          const bearingBox = new THREE.Mesh(
            new THREE.BoxGeometry(0.5, 0.7, 0.6),
            nexClampMat
          );
          bearingBox.position.set(px, pileHeight, 0);
          tracker.add(bearingBox);
          
          // Clamp ears extending to sides
          const earMat = new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.7, roughness: 0.3 });
          const leftEar = new THREE.Mesh(
            new THREE.BoxGeometry(0.35, 0.15, 0.15),
            earMat
          );
          leftEar.position.set(px, pileHeight + 0.3, 0.35);
          tracker.add(leftEar);
          
          const rightEar = new THREE.Mesh(
            new THREE.BoxGeometry(0.35, 0.15, 0.15),
            earMat
          );
          rightEar.position.set(px, pileHeight + 0.3, -0.35);
          tracker.add(rightEar);
          
          // Vertical support bracket below bearing
          const vBracket = new THREE.Mesh(
            new THREE.BoxGeometry(0.15, 0.6, 0.4),
            nexClampMat
          );
          vBracket.position.set(px, pileHeight - 0.55, 0);
          tracker.add(vBracket);
          
          // === ORANGE NEXTRACKER BADGE WITH X LOGO ===
          const orangeMat = new THREE.MeshStandardMaterial({ 
            color: 0xff6600, 
            emissive: 0xff4400, 
            emissiveIntensity: 0.1,
            metalness: 0.3,
            roughness: 0.5
          });
          
          // Orange circular badge (prominent like in reference)
          const badgeRadius = 0.22;
          const badge = new THREE.Mesh(
            new THREE.CylinderGeometry(badgeRadius, badgeRadius, 0.06, 24),
            orangeMat
          );
          badge.rotation.x = Math.PI / 2;
          badge.position.set(px, pileHeight - 0.15, 0.35);
          tracker.add(badge);
          
          // White X logo on badge
          const whiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 0.1, roughness: 0.7 });
          
          // X bar 1 (diagonal)
          const xBar1 = new THREE.Mesh(
            new THREE.BoxGeometry(0.05, 0.28, 0.02),
            whiteMat
          );
          xBar1.rotation.z = Math.PI / 4;
          xBar1.rotation.x = Math.PI / 2;
          xBar1.position.set(px, pileHeight - 0.15, 0.39);
          tracker.add(xBar1);
          
          // X bar 2 (diagonal other way)
          const xBar2 = new THREE.Mesh(
            new THREE.BoxGeometry(0.05, 0.28, 0.02),
            whiteMat
          );
          xBar2.rotation.z = -Math.PI / 4;
          xBar2.rotation.x = Math.PI / 2;
          xBar2.position.set(px, pileHeight - 0.15, 0.39);
          tracker.add(xBar2);
          
          // Small mounting bolts
          [-0.2, 0.2].forEach(zOff => {
            const topBolt = new THREE.Mesh(
              new THREE.CylinderGeometry(0.03, 0.03, 0.12, 6),
              boltMat
            );
            topBolt.position.set(px, pileHeight + 0.4, zOff);
            tracker.add(topBolt);
          });
        }
        
        // Post cap (top of W-beam) - both styles
        const capMat = new THREE.MeshStandardMaterial({ color: 0x777777, metalness: 0.6, roughness: 0.35 });
        const postCap = new THREE.Mesh(
          new THREE.BoxGeometry(0.55, 0.1, 0.6),
          capMat
        );
        postCap.position.set(px, pileHeight + 0.55, 0);
        tracker.add(postCap);
        
        // === STRING INVERTER ON EVERY POST - BIGGER ===
        const invY = pileHeight * 0.5;
        
        // Main inverter enclosure - BIGGER
        const inverterBody = new THREE.Mesh(
          new THREE.BoxGeometry(1.8, 1.3, 0.55),
          inverterMat
        );
        inverterBody.position.set(px, invY, 0.95);
        inverterBody.castShadow = true;
        tracker.add(inverterBody);
        
        // Store reference for highlighting
        inverterBoxes.push({ mesh: inverterBody, rowZ: zPos, xCenter: xCenter, px: px, originalMat: inverterMat, isHighlighted: false });
        
        // Front panel (lighter gray) - BIGGER
        const frontPanel = new THREE.Mesh(
          new THREE.BoxGeometry(1.5, 1.0, 0.03),
          inverterGrayMat
        );
        frontPanel.position.set(px, invY, 1.24);
        tracker.add(frontPanel);
        
        // Vent grilles (top) - BIGGER
        const ventTop = new THREE.Mesh(
          new THREE.BoxGeometry(1.3, 0.2, 0.56),
          ventMat
        );
        ventTop.position.set(px, invY + 0.58, 0.95);
        tracker.add(ventTop);
        
        // Vent grilles (bottom) - BIGGER
        const ventBottom = new THREE.Mesh(
          new THREE.BoxGeometry(1.3, 0.15, 0.56),
          ventMat
        );
        ventBottom.position.set(px, invY - 0.6, 0.95);
        tracker.add(ventBottom);
        
        // Display screen - BIGGER
        const screen = new THREE.Mesh(
          new THREE.BoxGeometry(0.65, 0.4, 0.03),
          new THREE.MeshStandardMaterial({ color: 0x1a4a1a, emissive: 0x0a3a0a, emissiveIntensity: 0.4 })
        );
        screen.position.set(px - 0.3, invY + 0.2, 1.26);
        tracker.add(screen);
        
        // LED indicators (3 LEDs) - BIGGER
        const ledColors = [0x00ff00, 0x00ff00, 0xffaa00];
        for (let l = 0; l < 3; l++) {
          const led = new THREE.Mesh(
            new THREE.SphereGeometry(0.06, 10, 10),
            new THREE.MeshStandardMaterial({ color: ledColors[l], emissive: ledColors[l], emissiveIntensity: 1.0 })
          );
          led.position.set(px + 0.45, invY + 0.32 - l * 0.16, 1.26);
          tracker.add(led);
        }
        
        // Brand label area - BIGGER
        const label = new THREE.Mesh(
          new THREE.BoxGeometry(0.8, 0.18, 0.015),
          new THREE.MeshStandardMaterial({ color: 0xffffff })
        );
        label.position.set(px, invY - 0.32, 1.26);
        tracker.add(label);
        
        // === WIRING HARNESS - BIGGER AND BRIGHTER ===
        const cableMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.8 });
        const redCableMat = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0x660000, emissiveIntensity: 0.5, roughness: 0.4 });
        const blueCableMat = new THREE.MeshStandardMaterial({ color: 0x0088ff, emissive: 0x003366, emissiveIntensity: 0.5, roughness: 0.4 });
        const greenCableMat = new THREE.MeshStandardMaterial({ color: 0x00ff00, emissive: 0x006600, emissiveIntensity: 0.5, roughness: 0.4 });
        const conduitMat = new THREE.MeshStandardMaterial({ color: 0x606060, metalness: 0.5, roughness: 0.4 });
        const cableTieMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.5 });
        
        // Main conduit coming down from panels to inverter - BIGGER
        const mainConduit = new THREE.Mesh(
          new THREE.CylinderGeometry(0.18, 0.18, 2.8, 12),
          conduitMat
        );
        mainConduit.position.set(px - 0.55, invY + 1.6, 0.7);
        tracker.add(mainConduit);
        
        // Conduit bend (horizontal section into inverter) - BIGGER
        const conduitBend = new THREE.Mesh(
          new THREE.CylinderGeometry(0.18, 0.18, 0.6, 12),
          conduitMat
        );
        conduitBend.rotation.x = Math.PI / 2;
        conduitBend.position.set(px - 0.55, invY + 0.35, 0.9);
        tracker.add(conduitBend);
        
        // DC input cables - MUCH THICKER AND BRIGHTER
        // Red DC+ cable running along side - MOVED OUT FOR VISIBILITY
        const dcCableRed = new THREE.Mesh(
          new THREE.CylinderGeometry(0.1, 0.1, 2.5, 10),
          redCableMat
        );
        dcCableRed.position.set(px - 0.85, invY + 1.5, 1.2);
        tracker.add(dcCableRed);
        
        // Red cable horizontal run to inverter
        const dcCableRedH = new THREE.Mesh(
          new THREE.CylinderGeometry(0.1, 0.1, 0.45, 10),
          redCableMat
        );
        dcCableRedH.rotation.z = Math.PI / 2;
        dcCableRedH.position.set(px - 0.65, invY + 0.3, 1.2);
        tracker.add(dcCableRedH);
        
        // Red cable into inverter
        const dcCableRedIn = new THREE.Mesh(
          new THREE.CylinderGeometry(0.1, 0.1, 0.3, 10),
          redCableMat
        );
        dcCableRedIn.rotation.x = Math.PI / 2;
        dcCableRedIn.position.set(px - 0.45, invY + 0.3, 1.05);
        tracker.add(dcCableRedIn);
        
        // Blue DC- cable running along side
        const dcCableBlue = new THREE.Mesh(
          new THREE.CylinderGeometry(0.1, 0.1, 2.5, 10),
          blueCableMat
        );
        dcCableBlue.position.set(px - 0.65, invY + 1.5, 1.2);
        tracker.add(dcCableBlue);
        
        // Blue cable horizontal run to inverter
        const dcCableBlueH = new THREE.Mesh(
          new THREE.CylinderGeometry(0.1, 0.1, 0.45, 10),
          blueCableMat
        );
        dcCableBlueH.rotation.z = Math.PI / 2;
        dcCableBlueH.position.set(px - 0.45, invY + 0.05, 1.2);
        tracker.add(dcCableBlueH);
        
        // Blue cable into inverter
        const dcCableBlueIn = new THREE.Mesh(
          new THREE.CylinderGeometry(0.1, 0.1, 0.3, 10),
          blueCableMat
        );
        dcCableBlueIn.rotation.x = Math.PI / 2;
        dcCableBlueIn.position.set(px - 0.25, invY + 0.05, 1.05);
        tracker.add(dcCableBlueIn);
        
        // DC disconnect box - BIGGER
        const dcDisconnect = new THREE.Mesh(
          new THREE.BoxGeometry(0.5, 0.55, 0.28),
          new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.5, roughness: 0.5 })
        );
        dcDisconnect.position.set(px - 0.75, invY - 0.1, 0.8);
        tracker.add(dcDisconnect);
        
        // Disconnect handle - BIGGER
        const dcHandle = new THREE.Mesh(
          new THREE.BoxGeometry(0.22, 0.12, 0.08),
          new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0x550000 })
        );
        dcHandle.position.set(px - 0.75, invY + 0.0, 0.95);
        tracker.add(dcHandle);
        
        // AC output conduit (going down post to ground) - BIGGER
        const acConduit = new THREE.Mesh(
          new THREE.CylinderGeometry(0.14, 0.14, invY - 0.1, 12),
          conduitMat
        );
        acConduit.position.set(px + 0.6, (invY - 0.1) / 2, 0.75);
        tracker.add(acConduit);
        
        // AC conduit elbow at inverter - BIGGER
        const acElbow = new THREE.Mesh(
          new THREE.CylinderGeometry(0.14, 0.14, 0.45, 12),
          conduitMat
        );
        acElbow.rotation.x = Math.PI / 2;
        acElbow.position.set(px + 0.6, invY - 0.35, 0.95);
        tracker.add(acElbow);
        
        // Ground wire (bright green) running down post - MUCH THICKER
        const groundWire = new THREE.Mesh(
          new THREE.CylinderGeometry(0.07, 0.07, pileHeight, 10),
          greenCableMat
        );
        groundWire.position.set(px + 0.3, pileHeight / 2, 0.48);
        tracker.add(groundWire);
        
        // Ground wire horizontal to inverter - BIGGER
        const groundWireH = new THREE.Mesh(
          new THREE.CylinderGeometry(0.07, 0.07, 0.6, 10),
          greenCableMat
        );
        groundWireH.rotation.x = Math.PI / 2;
        groundWireH.position.set(px + 0.3, invY - 0.4, 0.75);
        tracker.add(groundWireH);
        
        // Ground lug on post - BIGGER
        const groundLug = new THREE.Mesh(
          new THREE.BoxGeometry(0.2, 0.2, 0.12),
          new THREE.MeshStandardMaterial({ color: 0x00dd00, emissive: 0x004400, metalness: 0.6, roughness: 0.3 })
        );
        groundLug.position.set(px + 0.3, 0.35, 0.42);
        tracker.add(groundLug);
        
        // CABLE TIES / CLAMPS - MUCH LARGER AND VISIBLE
        // Cable ties on DC cables - in front where visible - BIGGER
        for (let ct = 0; ct < 4; ct++) {
          const cableTie = new THREE.Mesh(
            new THREE.TorusGeometry(0.2, 0.045, 10, 20),
            cableTieMat
          );
          cableTie.position.set(px - 0.75, invY + 0.5 + ct * 0.55, 1.2);
          cableTie.rotation.y = Math.PI / 2;
          tracker.add(cableTie);
        }
        
        // Cable clamps on conduit (metal) - BIGGER
        for (let cc = 0; cc < 3; cc++) {
          const clamp = new THREE.Mesh(
            new THREE.TorusGeometry(0.22, 0.05, 10, 20),
            new THREE.MeshStandardMaterial({ color: 0x999999, metalness: 0.7, roughness: 0.3 })
          );
          clamp.position.set(px - 0.55, invY + 0.85 + cc * 0.65, 0.7);
          clamp.rotation.y = Math.PI / 2;
          tracker.add(clamp);
          
          // Clamp screw - BIGGER
          const screw = new THREE.Mesh(
            new THREE.CylinderGeometry(0.035, 0.035, 0.14, 8),
            new THREE.MeshStandardMaterial({ color: 0x777777, metalness: 0.8 })
          );
          screw.rotation.x = Math.PI / 2;
          screw.position.set(px - 0.55, invY + 0.85 + cc * 0.65, 0.95);
          tracker.add(screw);
        }
        
        // Cable ties on ground wire - BIGGER
        for (let gt = 0; gt < 3; gt++) {
          const groundTie = new THREE.Mesh(
            new THREE.TorusGeometry(0.12, 0.035, 10, 16),
            greenCableMat
          );
          groundTie.position.set(px + 0.3, 0.9 + gt * 1.3, 0.48);
          groundTie.rotation.y = Math.PI / 2;
          tracker.add(groundTie);
        }
        
        // Mounting bracket - BIGGER
        const bracket = new THREE.Mesh(
          new THREE.BoxGeometry(0.18, 0.9, 0.65),
          postMat
        );
        bracket.position.set(px, invY, 0.55);
        tracker.add(bracket);
      }
      
      // PANEL TABLE
      const panelTable = new THREE.Group();
      panelTable.position.y = pileHeight;
      
      // Purlins
      const purlinPositions = [-panelH - 0.12, 0, panelH + 0.12];
      purlinPositions.forEach(pz => {
        const purlin = new THREE.Mesh(
          new THREE.BoxGeometry(rowLength + 2, 0.12, 0.08),
          postMat
        );
        purlin.position.set(0, torqueRadius + 0.08, pz);
        tracker.add(purlin);
      });
      
      // INDIVIDUAL PANELS
      for (let p = 0; p < panelsPerRow; p++) {
        const px = (p - (panelsPerRow - 1) / 2) * (panelW + panelGap);
        
        // Upper panel
        const panelUpper = new THREE.Mesh(
          new THREE.BoxGeometry(panelW, 0.06, panelH),
          panelMat
        );
        panelUpper.position.set(px, torqueRadius + 0.15, -panelH / 2 - 0.12);
        panelUpper.castShadow = true;
        panelUpper.receiveShadow = true;
        panelTable.add(panelUpper);
        
        // Lower panel
        const panelLower = new THREE.Mesh(
          new THREE.BoxGeometry(panelW, 0.06, panelH),
          panelMat
        );
        panelLower.position.set(px, torqueRadius + 0.15, panelH / 2 + 0.12);
        panelLower.castShadow = true;
        panelLower.receiveShadow = true;
        panelTable.add(panelLower);
        
        // === BACK OF PANEL WIRING - LARGER AND BRIGHTER ===
        const backWireRed = new THREE.MeshStandardMaterial({ 
          color: 0xff2200, 
          roughness: 0.4, 
          metalness: 0.2,
          emissive: 0xff0000,
          emissiveIntensity: 0.6
        }); // Bright red DC+ cable - highly visible
        const backWireBlack = new THREE.MeshStandardMaterial({ 
          color: 0x111111, 
          roughness: 0.5, 
          metalness: 0.1,
          emissive: 0x050505,
          emissiveIntensity: 0.2
        }); // Realistic black insulated wire (DC-)
        const mc4Mat = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.5, roughness: 0.4 });
        const junctionMat = new THREE.MeshStandardMaterial({ color: 0xffdd00, roughness: 0.3, emissive: 0xffaa00, emissiveIntensity: 0.5 });
        
        // Junction box on back of upper panel - attached to panel back - BIGGER
        const jBoxUpper = new THREE.Mesh(
          new THREE.BoxGeometry(0.7, 0.18, 0.4),
          junctionMat
        );
        jBoxUpper.position.set(px, torqueRadius + 0.09, -panelH / 2 - 0.15);
        jBoxUpper.visible = false; // Hidden by default, shown on String step
        panelTable.add(jBoxUpper);
        junctionBoxes.push({ mesh: jBoxUpper, rowZ: zPos });
        
        // Junction box on back of lower panel - attached to panel back - BIGGER
        const jBoxLower = new THREE.Mesh(
          new THREE.BoxGeometry(0.7, 0.18, 0.4),
          junctionMat
        );
        jBoxLower.position.set(px, torqueRadius + 0.09, panelH / 2 + 0.15);
        jBoxLower.visible = false; // Hidden by default, shown on String step
        panelTable.add(jBoxLower);
        junctionBoxes.push({ mesh: jBoxLower, rowZ: zPos });
        
        // RIGHT SIDE - WIRE HARNESS (panels on right half)
        if (px > 0) {
          // === MC4 INTERCONNECTION CABLES (panel-to-panel) ===
          // These are the short cables that connect one panel to the next
          if (p > 0) {
            // Red interconnection cable from this panel's - to previous panel's +
            const interConnectRed = new THREE.Mesh(
              new THREE.CylinderGeometry(0.1, 0.1, panelW - 0.3, 12),
              backWireRed
            );
            interConnectRed.rotation.z = Math.PI / 2;
            interConnectRed.position.set(px - panelW / 2, torqueRadius + 0.02, panelH / 2 + 0.22);
            interConnectRed.visible = false; // Hidden by default
            panelTable.add(interConnectRed);
            redCables.push({ mesh: interConnectRed, rowZ: zPos });
            
            // Black interconnection cable 
            const interConnectBlack = new THREE.Mesh(
              new THREE.CylinderGeometry(0.1, 0.1, panelW - 0.3, 12),
              backWireBlack
            );
            interConnectBlack.rotation.z = Math.PI / 2;
            interConnectBlack.position.set(px - panelW / 2, torqueRadius - 0.06, panelH / 2 + 0.22);
            interConnectBlack.visible = false; // Hidden by default
            panelTable.add(interConnectBlack);
            redCables.push({ mesh: interConnectBlack, rowZ: zPos });
            
            // MC4 connector pair (where two panels connect)
            const mc4Pair = new THREE.Mesh(
              new THREE.CylinderGeometry(0.08, 0.08, 0.2, 8),
              new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.6, roughness: 0.3 })
            );
            mc4Pair.rotation.z = Math.PI / 2;
            mc4Pair.position.set(px - panelW / 2, torqueRadius - 0.02, panelH / 2 + 0.22);
            mc4Pair.visible = false; // Hidden by default
            panelTable.add(mc4Pair);
            redCables.push({ mesh: mc4Pair, rowZ: zPos });
          }
          
          // Harness cable bundle running horizontally along mounting rail
          if (p % 4 === 0) {
            // Main harness trunk cable - RED - MUCH THICKER
            const harnessTrunkRed = new THREE.Mesh(
              new THREE.CylinderGeometry(0.15, 0.15, panelW * 4, 12),
              backWireRed
            );
            harnessTrunkRed.rotation.z = Math.PI / 2;
            harnessTrunkRed.position.set(px + panelW * 1.5, torqueRadius + 0.0, panelH / 2 + 0.18);
            harnessTrunkRed.visible = false; // Hidden by default
            panelTable.add(harnessTrunkRed);
            redCables.push({ mesh: harnessTrunkRed, rowZ: zPos });
            
            // Main harness trunk cable - BLACK - MUCH THICKER
            const harnessTrunkBlack = new THREE.Mesh(
              new THREE.CylinderGeometry(0.15, 0.15, panelW * 4, 12),
              backWireBlack
            );
            harnessTrunkBlack.rotation.z = Math.PI / 2;
            harnessTrunkBlack.position.set(px + panelW * 1.5, torqueRadius - 0.08, panelH / 2 + 0.18);
            harnessTrunkBlack.visible = false; // Hidden by default
            panelTable.add(harnessTrunkBlack);
            redCables.push({ mesh: harnessTrunkBlack, rowZ: zPos });
            
            // === CAB CLIP attached to purlin holding harness ===
            const cabMat = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0x880000, emissiveIntensity: 0.6, roughness: 0.3 });
            
            // CAB mounting bracket attached to purlin
            const cabBracket = new THREE.Mesh(
              new THREE.BoxGeometry(0.2, 0.15, 0.12),
              cabMat
            );
            cabBracket.position.set(px + panelW * 1.5, torqueRadius + 0.08, panelH / 2 + 0.12);
            cabBracket.visible = false; // Hidden by default
            panelTable.add(cabBracket);
            redCables.push({ mesh: cabBracket, rowZ: zPos });
            
            // CAB clip loop holding cables
            const cabLoop = new THREE.Mesh(
              new THREE.TorusGeometry(0.14, 0.04, 8, 16, Math.PI * 1.4),
              cabMat
            );
            cabLoop.position.set(px + panelW * 1.5, torqueRadius - 0.04, panelH / 2 + 0.18);
            cabLoop.rotation.y = Math.PI / 2;
            cabLoop.rotation.z = -Math.PI / 5;
            cabLoop.visible = false; // Hidden by default
            panelTable.add(cabLoop);
            redCables.push({ mesh: cabLoop, rowZ: zPos });
          }
          
          // Drop cables from junction box to harness - THICKER
          const dropRed = new THREE.Mesh(
            new THREE.CylinderGeometry(0.05, 0.05, 0.25, 12),
            backWireRed
          );
          dropRed.position.set(px + 0.15, torqueRadius - 0.02, panelH / 2 + 0.18);
          dropRed.visible = false; // Hidden by default
          panelTable.add(dropRed);
          redCables.push({ mesh: dropRed, rowZ: zPos });
          
          const dropBlack = new THREE.Mesh(
            new THREE.CylinderGeometry(0.05, 0.05, 0.25, 12),
            backWireBlack
          );
          dropBlack.position.set(px - 0.15, torqueRadius - 0.02, panelH / 2 + 0.18);
          dropBlack.visible = false; // Hidden by default
          panelTable.add(dropBlack);
          redCables.push({ mesh: dropBlack, rowZ: zPos });
          
          // MC4 connectors at junction box - BIGGER
          const mc4Red = new THREE.Mesh(
            new THREE.CylinderGeometry(0.06, 0.05, 0.18, 8),
            mc4Mat
          );
          mc4Red.position.set(px + 0.15, torqueRadius + 0.06, panelH / 2 + 0.2);
          mc4Red.visible = false; // Hidden by default
          panelTable.add(mc4Red);
          redCables.push({ mesh: mc4Red, rowZ: zPos });
          
          const mc4Black = new THREE.Mesh(
            new THREE.CylinderGeometry(0.06, 0.05, 0.18, 8),
            mc4Mat
          );
          mc4Black.position.set(px - 0.15, torqueRadius + 0.06, panelH / 2 + 0.2);
          mc4Black.visible = false; // Hidden by default
          panelTable.add(mc4Black);
          redCables.push({ mesh: mc4Black, rowZ: zPos });
        }
        
        // LEFT SIDE - STRING HOME RUNS (panels on left half)
        if (px < 0) {
          // === MC4 INTERCONNECTION CABLES (panel-to-panel) ===
          if (p > 0) {
            // Red interconnection cable between panels
            const interConnectRedL = new THREE.Mesh(
              new THREE.CylinderGeometry(0.1, 0.1, panelW - 0.3, 12),
              backWireRed
            );
            interConnectRedL.rotation.z = Math.PI / 2;
            interConnectRedL.position.set(px - panelW / 2, torqueRadius + 0.02, -panelH / 2 - 0.22);
            interConnectRedL.visible = false; // Hidden by default
            panelTable.add(interConnectRedL);
            redCables.push({ mesh: interConnectRedL, rowZ: zPos });
            
            // Black interconnection cable 
            const interConnectBlackL = new THREE.Mesh(
              new THREE.CylinderGeometry(0.1, 0.1, panelW - 0.3, 12),
              backWireBlack
            );
            interConnectBlackL.rotation.z = Math.PI / 2;
            interConnectBlackL.position.set(px - panelW / 2, torqueRadius - 0.06, -panelH / 2 - 0.22);
            interConnectBlackL.visible = false; // Hidden by default
            panelTable.add(interConnectBlackL);
            redCables.push({ mesh: interConnectBlackL, rowZ: zPos });
            
            // MC4 connector pair (where two panels connect)
            const mc4PairL = new THREE.Mesh(
              new THREE.CylinderGeometry(0.08, 0.08, 0.2, 8),
              new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.6, roughness: 0.3 })
            );
            mc4PairL.rotation.z = Math.PI / 2;
            mc4PairL.position.set(px - panelW / 2, torqueRadius - 0.02, -panelH / 2 - 0.22);
            mc4PairL.visible = false; // Hidden by default
            panelTable.add(mc4PairL);
            redCables.push({ mesh: mc4PairL, rowZ: zPos });
          }
          
          // Individual string home run cables running to end of row
          const stringIndex = Math.abs(Math.floor(px / (panelW * 3)));
          const cableOffset = (stringIndex % 4) * 0.08;
          
          // Home run RED cable running toward row end - attached under purlin
          const homeRunRed = new THREE.Mesh(
            new THREE.CylinderGeometry(0.12, 0.12, Math.abs(px) + panelW, 12),
            backWireRed
          );
          homeRunRed.rotation.z = Math.PI / 2;
          homeRunRed.position.set(px / 2 - panelW / 2, torqueRadius + 0.0 - cableOffset, -panelH / 2 - 0.18);
          homeRunRed.visible = false; // Hidden by default
          panelTable.add(homeRunRed);
          redCables.push({ mesh: homeRunRed, rowZ: zPos });
          
          // Home run BLACK cable - THICKER
          const homeRunBlack = new THREE.Mesh(
            new THREE.CylinderGeometry(0.12, 0.12, Math.abs(px) + panelW, 12),
            backWireBlack
          );
          homeRunBlack.rotation.z = Math.PI / 2;
          homeRunBlack.position.set(px / 2 - panelW / 2, torqueRadius - 0.1 - cableOffset, -panelH / 2 - 0.18);
          homeRunBlack.visible = false; // Hidden by default
          panelTable.add(homeRunBlack);
          redCables.push({ mesh: homeRunBlack, rowZ: zPos });
          
          // CAB clip only at every 4th panel to reduce clutter
          if (p % 4 === 0) {
            const cabMatHR = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0x880000, emissiveIntensity: 0.6, roughness: 0.3 });
            
            // CAB bracket attached to purlin
            const cabBracketHR = new THREE.Mesh(
              new THREE.BoxGeometry(0.18, 0.12, 0.1),
              cabMatHR
            );
            cabBracketHR.position.set(px, torqueRadius + 0.08, -panelH / 2 - 0.12);
            cabBracketHR.visible = false; // Hidden by default
            panelTable.add(cabBracketHR);
            redCables.push({ mesh: cabBracketHR, rowZ: zPos });
            
            // CAB loop holding cables
            const cabLoopHR = new THREE.Mesh(
              new THREE.TorusGeometry(0.12, 0.035, 8, 14, Math.PI * 1.4),
              cabMatHR
            );
            cabLoopHR.position.set(px, torqueRadius - 0.05 - cableOffset, -panelH / 2 - 0.18);
            cabLoopHR.rotation.y = Math.PI / 2;
            cabLoopHR.rotation.z = -Math.PI / 5;
            cabLoopHR.visible = false; // Hidden by default
            panelTable.add(cabLoopHR);
            redCables.push({ mesh: cabLoopHR, rowZ: zPos });
          }
          
          // Drop cable from panel to home run - THICKER
          const dropRedHR = new THREE.Mesh(
            new THREE.CylinderGeometry(0.05, 0.05, 0.2, 12),
            backWireRed
          );
          dropRedHR.position.set(px + 0.12, torqueRadius + 0.02, -panelH / 2 - 0.15);
          dropRedHR.visible = false; // Hidden by default
          panelTable.add(dropRedHR);
          redCables.push({ mesh: dropRedHR, rowZ: zPos });
          
          const dropBlackHR = new THREE.Mesh(
            new THREE.CylinderGeometry(0.05, 0.05, 0.2, 12),
            backWireBlack
          );
          dropBlackHR.position.set(px - 0.12, torqueRadius + 0.02, -panelH / 2 - 0.15);
          dropBlackHR.visible = false; // Hidden by default
          panelTable.add(dropBlackHR);
          redCables.push({ mesh: dropBlackHR, rowZ: zPos });
          
          // MC4 connectors - BIGGER
          const mc4RedHR = new THREE.Mesh(
            new THREE.CylinderGeometry(0.05, 0.04, 0.15, 8),
            mc4Mat
          );
          mc4RedHR.rotation.x = Math.PI / 2;
          mc4RedHR.position.set(px + 0.12, torqueRadius + 0.0, -panelH / 2 - 0.28);
          mc4RedHR.visible = false; // Hidden by default
          panelTable.add(mc4RedHR);
          redCables.push({ mesh: mc4RedHR, rowZ: zPos });
          
          const mc4BlackHR = new THREE.Mesh(
            new THREE.CylinderGeometry(0.05, 0.04, 0.15, 8),
            mc4Mat
          );
          mc4BlackHR.rotation.x = Math.PI / 2;
          mc4BlackHR.position.set(px - 0.12, torqueRadius - 0.08, -panelH / 2 - 0.28);
          mc4BlackHR.visible = false; // Hidden by default
          panelTable.add(mc4BlackHR);
          redCables.push({ mesh: mc4BlackHR, rowZ: zPos });
        }
        
        // Frames
        const frameThick = 0.1;
        const fUT = new THREE.Mesh(new THREE.BoxGeometry(panelW + 0.08, frameThick, frameThick), frameMat);
        fUT.position.set(px, torqueRadius + 0.15, -panelH - 0.12);
        panelTable.add(fUT);
        
        const fUB = new THREE.Mesh(new THREE.BoxGeometry(panelW + 0.08, frameThick, frameThick), frameMat);
        fUB.position.set(px, torqueRadius + 0.15, -0.12);
        panelTable.add(fUB);
        
        const fLT = new THREE.Mesh(new THREE.BoxGeometry(panelW + 0.08, frameThick, frameThick), frameMat);
        fLT.position.set(px, torqueRadius + 0.15, 0.12);
        panelTable.add(fLT);
        
        const fLB = new THREE.Mesh(new THREE.BoxGeometry(panelW + 0.08, frameThick, frameThick), frameMat);
        fLB.position.set(px, torqueRadius + 0.15, panelH + 0.12);
        panelTable.add(fLB);
        
        const sideLen = panelH * 2 + 0.34;
        const fL = new THREE.Mesh(new THREE.BoxGeometry(frameThick, frameThick, sideLen), frameMat);
        fL.position.set(px - panelW / 2, torqueRadius + 0.15, 0);
        panelTable.add(fL);
        
        const fR = new THREE.Mesh(new THREE.BoxGeometry(frameThick, frameThick, sideLen), frameMat);
        fR.position.set(px + panelW / 2, torqueRadius + 0.15, 0);
        panelTable.add(fR);
      }
      
      panelTable.rotation.x = tilt;
      tracker.add(panelTable);
      
      // Store reference for sun tracking
      tracker.userData.panelTable = panelTable;
      tracker.userData.baseTilt = tilt;
      
      // === WIRE MANAGEMENT SYSTEM - attached to posts ===
      const cableTrayMat = new THREE.MeshStandardMaterial({ color: 0x505050, metalness: 0.5, roughness: 0.4 });
      const messengerMat = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.6, roughness: 0.4 });
      
      // Cable tray running along the row - positioned at post level
      const cableTray = new THREE.Mesh(
        new THREE.BoxGeometry(rowLength * 0.9, 0.1, 0.5),
        cableTrayMat
      );
      cableTray.position.set(0, pileHeight - 0.8, 1.5);
      tracker.add(cableTray);
      
      // Tray sides
      const traySide1 = new THREE.Mesh(
        new THREE.BoxGeometry(rowLength * 0.9, 0.2, 0.06),
        cableTrayMat
      );
      traySide1.position.set(0, pileHeight - 0.65, 1.73);
      tracker.add(traySide1);
      
      const traySide2 = new THREE.Mesh(
        new THREE.BoxGeometry(rowLength * 0.9, 0.2, 0.06),
        cableTrayMat
      );
      traySide2.position.set(0, pileHeight - 0.65, 1.27);
      tracker.add(traySide2);
      
      // Messenger wire (catenary support) - attached between posts
      const messengerWire = new THREE.Mesh(
        new THREE.CylinderGeometry(0.03, 0.03, rowLength, 12),
        messengerMat
      );
      messengerWire.rotation.z = Math.PI / 2;
      messengerWire.position.set(0, pileHeight + 0.2, 1.8);
      tracker.add(messengerWire);
      
      // Bundled home run cables in tray (visible RED and BLACK)
      const trayBundleRed = new THREE.Mesh(
        new THREE.CylinderGeometry(0.1, 0.1, rowLength * 0.85, 12),
        new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0x550000, emissiveIntensity: 0.4, roughness: 0.5 })
      );
      trayBundleRed.rotation.z = Math.PI / 2;
      trayBundleRed.position.set(0, pileHeight - 0.68, 1.58);
      tracker.add(trayBundleRed);
      
      const trayBundleBlack = new THREE.Mesh(
        new THREE.CylinderGeometry(0.1, 0.1, rowLength * 0.85, 12),
        new THREE.MeshStandardMaterial({ color: 0x222222, emissive: 0x111111, roughness: 0.5 })
      );
      trayBundleBlack.rotation.z = Math.PI / 2;
      trayBundleBlack.position.set(0, pileHeight - 0.68, 1.42);
      tracker.add(trayBundleBlack);
      
      // Tray support brackets at each post
      for (let i = 0; i <= numPiles; i++) {
        const bpx = -rowLength / 2 + i * pileSpacing;
        if (Math.abs(bpx) > rowLength / 2 + 2) continue;
        
        // Tray bracket attached to post
        const trayBracket = new THREE.Mesh(
          new THREE.BoxGeometry(0.12, 0.5, 0.6),
          cableTrayMat
        );
        trayBracket.position.set(bpx, pileHeight - 0.55, 1.5);
        tracker.add(trayBracket);
        
        // === CAB CLIP on cable tray - attached to bracket ===
        const cabTrayMat = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0x880000, emissiveIntensity: 0.6, roughness: 0.25 });
        
        // CAB clip holding main bundle - attached to tray bracket
        const cabTray1 = new THREE.Mesh(
          new THREE.TorusGeometry(0.15, 0.04, 10, 18, Math.PI * 1.3),
          cabTrayMat
        );
        cabTray1.position.set(bpx, pileHeight - 0.68, 1.5);
        cabTray1.rotation.z = Math.PI / 2;
        cabTray1.rotation.y = Math.PI / 6;
        tracker.add(cabTray1);
        
        // CAB mounting tab on bracket
        const cabTab = new THREE.Mesh(
          new THREE.BoxGeometry(0.08, 0.12, 0.2),
          cabTrayMat
        );
        cabTab.position.set(bpx, pileHeight - 0.5, 1.5);
        tracker.add(cabTab);
      }
      
      // === REALISTIC SLEW DRIVE MOTOR (End of row) ===
      const motorGroup = new THREE.Group();
      const motorMat = new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.6, roughness: 0.4 });
      const gearMat = new THREE.MeshStandardMaterial({ color: 0x666666, metalness: 0.7, roughness: 0.3 });
      
      // Motor housing (cylindrical)
      const motorHousing = new THREE.Mesh(
        new THREE.CylinderGeometry(0.4, 0.4, 0.8, 16),
        motorMat
      );
      motorHousing.rotation.z = Math.PI / 2;
      motorHousing.position.set(-0.6, 0, 0);
      motorGroup.add(motorHousing);
      
      // Motor end cap
      const motorCap = new THREE.Mesh(
        new THREE.CylinderGeometry(0.35, 0.4, 0.15, 16),
        motorMat
      );
      motorCap.rotation.z = Math.PI / 2;
      motorCap.position.set(-1.05, 0, 0);
      motorGroup.add(motorCap);
      
      // Gearbox (larger cylinder)
      const gearbox = new THREE.Mesh(
        new THREE.CylinderGeometry(0.5, 0.5, 0.6, 16),
        gearMat
      );
      gearbox.rotation.z = Math.PI / 2;
      gearbox.position.set(0, 0, 0);
      motorGroup.add(gearbox);
      
      // Gearbox housing ribs
      for (let rib = 0; rib < 8; rib++) {
        const ribAngle = (rib / 8) * Math.PI * 2;
        const ribMesh = new THREE.Mesh(
          new THREE.BoxGeometry(0.55, 0.05, 0.08),
          gearMat
        );
        ribMesh.position.set(0, Math.cos(ribAngle) * 0.45, Math.sin(ribAngle) * 0.45);
        ribMesh.rotation.x = ribAngle;
        motorGroup.add(ribMesh);
      }
      
      // Output flange (connects to torque tube)
      const outputFlange = new THREE.Mesh(
        new THREE.CylinderGeometry(0.3, 0.4, 0.3, 16),
        gearMat
      );
      outputFlange.rotation.z = Math.PI / 2;
      outputFlange.position.set(0.4, 0, 0);
      motorGroup.add(outputFlange);
      
      // Mounting bracket
      const mountBracket = new THREE.Mesh(
        new THREE.BoxGeometry(0.15, 1.2, 0.8),
        new THREE.MeshStandardMaterial({ color: 0x777777, metalness: 0.6, roughness: 0.35 })
      );
      mountBracket.position.set(0.1, -0.7, 0);
      motorGroup.add(mountBracket);
      
      // Controller box on motor
      const controlBox = new THREE.Mesh(
        new THREE.BoxGeometry(0.4, 0.25, 0.3),
        new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.5, roughness: 0.5 })
      );
      controlBox.position.set(-0.3, 0.5, 0);
      motorGroup.add(controlBox);
      
      // LED indicator
      const motorLED = new THREE.Mesh(
        new THREE.SphereGeometry(0.04, 8, 8),
        new THREE.MeshStandardMaterial({ color: 0x00ff00, emissive: 0x00ff00, emissiveIntensity: 0.5 })
      );
      motorLED.position.set(-0.15, 0.55, 0.15);
      motorGroup.add(motorLED);
      
      // Motor support post
      const motorPostMain = new THREE.Mesh(
        new THREE.BoxGeometry(0.2, pileHeight + 0.4, 0.5),
        postMat
      );
      motorPostMain.position.set(0, -pileHeight / 2 + 0.2, 0);
      motorGroup.add(motorPostMain);
      
      // Post flanges
      const motorFlange1 = new THREE.Mesh(
        new THREE.BoxGeometry(0.5, pileHeight + 0.4, 0.08),
        postMat
      );
      motorFlange1.position.set(0, -pileHeight / 2 + 0.2, 0.22);
      motorGroup.add(motorFlange1);
      
      const motorFlange2 = new THREE.Mesh(
        new THREE.BoxGeometry(0.5, pileHeight + 0.4, 0.08),
        postMat
      );
      motorFlange2.position.set(0, -pileHeight / 2 + 0.2, -0.22);
      motorGroup.add(motorFlange2);
      
      motorGroup.position.set(-rowLength / 2 - 1.5, pileHeight, 0);
      tracker.add(motorGroup);
      
      // === COMBINER BOXES - Multiple Locations ===
      const combinerBodyMat = new THREE.MeshStandardMaterial({ color: 0xe8e8e8, metalness: 0.3, roughness: 0.5 }); // Light gray/white box
      const combinerDoorMat = new THREE.MeshStandardMaterial({ color: 0xd0d0d0, metalness: 0.4, roughness: 0.4 });
      const strutMat = new THREE.MeshStandardMaterial({ color: 0x606060, metalness: 0.6, roughness: 0.4 });
      const warningMat = new THREE.MeshStandardMaterial({ color: 0xffcc00, emissive: 0x332200 }); // Yellow warning
      
      // === END OF ROW COMBINER BOX (Left end) ===
      const endCBX = new THREE.Group();
      
      // Mounting post/strut for end combiner
      const endPost = new THREE.Mesh(
        new THREE.BoxGeometry(0.15, 3.5, 0.15),
        strutMat
      );
      endPost.position.set(0, 1.75, 0);
      endCBX.add(endPost);
      
      // Cross strut
      const endCrossStrut = new THREE.Mesh(
        new THREE.BoxGeometry(0.8, 0.1, 0.1),
        strutMat
      );
      endCrossStrut.position.set(0.3, 2.8, 0);
      endCBX.add(endCrossStrut);
      
      // Main combiner enclosure - white/gray box
      const endCombinerBody = new THREE.Mesh(
        new THREE.BoxGeometry(1.0, 1.4, 0.5),
        combinerBodyMat
      );
      endCombinerBody.position.set(0.4, 2.8, 0);
      endCombinerBody.castShadow = true;
      endCBX.add(endCombinerBody);
      
      // Store reference for highlighting
      combinerBoxes.push({ mesh: endCombinerBody, rowZ: zPos, xCenter: xCenter, originalMat: combinerBodyMat, isHighlighted: false });
      
      // Door/front panel
      const endCombinerDoor = new THREE.Mesh(
        new THREE.BoxGeometry(0.9, 1.3, 0.03),
        combinerDoorMat
      );
      endCombinerDoor.position.set(0.4, 2.8, 0.27);
      endCBX.add(endCombinerDoor);
      
      // Warning label (yellow triangle)
      const endWarning = new THREE.Mesh(
        new THREE.BoxGeometry(0.25, 0.25, 0.02),
        warningMat
      );
      endWarning.position.set(0.4, 3.2, 0.29);
      endCBX.add(endWarning);
      
      // "PV COMBINER BOX" label area
      const endLabel = new THREE.Mesh(
        new THREE.BoxGeometry(0.6, 0.15, 0.02),
        new THREE.MeshStandardMaterial({ color: 0xffffff })
      );
      endLabel.position.set(0.4, 2.5, 0.29);
      endCBX.add(endLabel);
      
      // Door handle/latch
      const endHandle = new THREE.Mesh(
        new THREE.BoxGeometry(0.08, 0.2, 0.05),
        strutMat
      );
      endHandle.position.set(0.75, 2.8, 0.29);
      endCBX.add(endHandle);
      
      // Cable glands at bottom (where cables enter)
      for (let g = 0; g < 4; g++) {
        const gland = new THREE.Mesh(
          new THREE.CylinderGeometry(0.06, 0.06, 0.15, 8),
          new THREE.MeshStandardMaterial({ color: 0x333333 })
        );
        gland.position.set(0.15 + g * 0.18, 2.0, 0);
        endCBX.add(gland);
        
        // Cables going into glands
        const glandCable = new THREE.Mesh(
          new THREE.CylinderGeometry(0.04, 0.04, 0.8, 8),
          new THREE.MeshStandardMaterial({ color: g % 2 === 0 ? 0xff0000 : 0x111111, emissive: g % 2 === 0 ? 0x330000 : 0x000000 })
        );
        glandCable.position.set(0.15 + g * 0.18, 1.5, 0);
        endCBX.add(glandCable);
      }
      
      // Feeder cable coming out (larger, going to inverter/transformer)
      const feederConduit = new THREE.Mesh(
        new THREE.CylinderGeometry(0.1, 0.1, 1.5, 10),
        new THREE.MeshStandardMaterial({ color: 0x505050, metalness: 0.5 })
      );
      feederConduit.position.set(0.4, 1.3, 0);
      endCBX.add(feederConduit);
      
      // Position end combiner at left end of row
      endCBX.position.set(-rowLength / 2 - 3, 0, 0);
      tracker.add(endCBX);
      
      // Underground conduit run from end combiner (going to central collection)
      const undergroundRun = new THREE.Mesh(
        new THREE.CylinderGeometry(0.12, 0.12, 15, 10),
        new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.4 })
      );
      undergroundRun.rotation.x = Math.PI / 2;
      undergroundRun.position.set(-rowLength / 2 - 3, 0.15, 7.5);
      tracker.add(undergroundRun);
      
      // Conduit markers/risers along underground run
      for (let m = 0; m < 3; m++) {
        const marker = new THREE.Mesh(
          new THREE.CylinderGeometry(0.08, 0.08, 0.4, 8),
          new THREE.MeshStandardMaterial({ color: 0xff6600 }) // Orange marker
        );
        marker.position.set(-rowLength / 2 - 3, 0.35, 3 + m * 5);
        tracker.add(marker);
      }
      
      // === MIDDLE OF ROW COMBINER BOX ===
      const midCBX = new THREE.Group();
      
      // I-beam/strut rack mounting
      const iBeamWeb = new THREE.Mesh(
        new THREE.BoxGeometry(0.08, 2.0, 0.4),
        strutMat
      );
      iBeamWeb.position.set(0, 1.0, 0);
      midCBX.add(iBeamWeb);
      
      // I-beam flanges
      const iBeamFlange1 = new THREE.Mesh(
        new THREE.BoxGeometry(0.25, 2.0, 0.06),
        strutMat
      );
      iBeamFlange1.position.set(0, 1.0, 0.17);
      midCBX.add(iBeamFlange1);
      
      const iBeamFlange2 = new THREE.Mesh(
        new THREE.BoxGeometry(0.25, 2.0, 0.06),
        strutMat
      );
      iBeamFlange2.position.set(0, 1.0, -0.17);
      midCBX.add(iBeamFlange2);
      
      // Mounting bracket
      const midBracket = new THREE.Mesh(
        new THREE.BoxGeometry(0.6, 0.1, 0.5),
        strutMat
      );
      midBracket.position.set(0.25, 2.2, 0);
      midCBX.add(midBracket);
      
      // Main combiner box body
      const midCombinerBody = new THREE.Mesh(
        new THREE.BoxGeometry(0.9, 1.2, 0.45),
        combinerBodyMat
      );
      midCombinerBody.position.set(0.35, 2.8, 0);
      midCombinerBody.castShadow = true;
      midCBX.add(midCombinerBody);
      
      // Store reference for highlighting
      combinerBoxes.push({ mesh: midCombinerBody, rowZ: zPos, xCenter: xCenter, originalMat: combinerBodyMat, isHighlighted: false });
      
      // Door
      const midCombinerDoor = new THREE.Mesh(
        new THREE.BoxGeometry(0.8, 1.1, 0.03),
        combinerDoorMat
      );
      midCombinerDoor.position.set(0.35, 2.8, 0.25);
      midCBX.add(midCombinerDoor);
      
      // Warning sign
      const midWarning = new THREE.Mesh(
        new THREE.BoxGeometry(0.22, 0.22, 0.02),
        warningMat
      );
      midWarning.position.set(0.35, 3.15, 0.27);
      midCBX.add(midWarning);
      
      // Red disconnect handle
      const midDisconnect = new THREE.Mesh(
        new THREE.BoxGeometry(0.15, 0.08, 0.06),
        new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0x440000 })
      );
      midDisconnect.position.set(0.35, 2.45, 0.27);
      midCBX.add(midDisconnect);
      
      // Cable glands
      for (let g = 0; g < 3; g++) {
        const gland = new THREE.Mesh(
          new THREE.CylinderGeometry(0.055, 0.055, 0.12, 8),
          new THREE.MeshStandardMaterial({ color: 0x2a2a2a })
        );
        gland.position.set(0.1 + g * 0.2, 2.15, 0);
        midCBX.add(gland);
      }
      
      // Cables coming from panels (red/black pairs) - going UP to panel level
      for (let c = 0; c < 3; c++) {
        // Vertical cable section
        const cableRedV = new THREE.Mesh(
          new THREE.CylinderGeometry(0.04, 0.04, 1.5, 8),
          new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0x550000 })
        );
        cableRedV.position.set(0.0 + c * 0.25, 3.8, 0.1);
        midCBX.add(cableRedV);
        
        const cableBlackV = new THREE.Mesh(
          new THREE.CylinderGeometry(0.04, 0.04, 1.5, 8),
          new THREE.MeshStandardMaterial({ color: 0x111111 })
        );
        cableBlackV.position.set(0.1 + c * 0.25, 3.8, 0.1);
        midCBX.add(cableBlackV);
        
        // Horizontal section into combiner
        const cableRedH = new THREE.Mesh(
          new THREE.CylinderGeometry(0.04, 0.04, 0.4, 8),
          new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0x550000 })
        );
        cableRedH.rotation.z = Math.PI / 4;
        cableRedH.position.set(0.15 + c * 0.2, 3.1, 0.1);
        midCBX.add(cableRedH);
      }
      
      // Underground conduit stub
      const undergroundStub = new THREE.Mesh(
        new THREE.CylinderGeometry(0.12, 0.12, 0.6, 10),
        new THREE.MeshStandardMaterial({ color: 0x606060 })
      );
      undergroundStub.position.set(0.35, 0.3, 0);
      midCBX.add(undergroundStub);
      
      // Position middle combiner under panels (middle of row) - visible location
      midCBX.position.set(0, 0, 2.5);
      tracker.add(midCBX);
      
      // Add a second middle combiner on opposite side for visibility
      const midCBX2 = midCBX.clone();
      midCBX2.position.set(rowLength * 0.3, 0, 2.5);
      tracker.add(midCBX2);
      
      // === SECOND END OF ROW COMBINER (Right end) ===
      const endCBX2 = endCBX.clone();
      endCBX2.position.set(rowLength / 2 + 3, 0, 0);
      endCBX2.rotation.y = Math.PI; // Face opposite direction
      tracker.add(endCBX2);
      
      // === ABOVE GROUND TRANSITION BOX (standalone between rows) ===
      // Add transition boxes randomly to show variety
      if (Math.random() < 0.3) {
        const transitionBox = new THREE.Group();
        
        // Tall mounting post
        const transPost = new THREE.Mesh(
          new THREE.CylinderGeometry(0.12, 0.12, 5, 10),
          strutMat
        );
        transPost.position.set(0, 2.5, 0);
        transitionBox.add(transPost);
        
        // Support brace
        const transBrace = new THREE.Mesh(
          new THREE.CylinderGeometry(0.06, 0.06, 2, 8),
          strutMat
        );
        transBrace.position.set(0.5, 1.5, 0);
        transBrace.rotation.z = Math.PI / 4;
        transitionBox.add(transBrace);
        
        // Large combiner enclosure (like in photos)
        const transBody = new THREE.Mesh(
          new THREE.BoxGeometry(1.2, 1.6, 0.6),
          combinerBodyMat
        );
        transBody.position.set(0, 4.2, 0.3);
        transBody.castShadow = true;
        transitionBox.add(transBody);
        
        // Door
        const transDoor = new THREE.Mesh(
          new THREE.BoxGeometry(1.1, 1.5, 0.03),
          combinerDoorMat
        );
        transDoor.position.set(0, 4.2, 0.62);
        transitionBox.add(transDoor);
        
        // Warning label
        const transWarning = new THREE.Mesh(
          new THREE.BoxGeometry(0.3, 0.3, 0.02),
          warningMat
        );
        transWarning.position.set(0, 4.7, 0.64);
        transitionBox.add(transWarning);
        
        // Multiple cable entries at bottom
        for (let e = 0; e < 6; e++) {
          const entry = new THREE.Mesh(
            new THREE.CylinderGeometry(0.07, 0.07, 0.2, 8),
            new THREE.MeshStandardMaterial({ color: 0x333333 })
          );
          entry.position.set(-0.4 + e * 0.16, 3.3, 0.3);
          transitionBox.add(entry);
        }
        
        // Underground conduit
        const underConduit = new THREE.Mesh(
          new THREE.CylinderGeometry(0.15, 0.15, 1.0, 10),
          new THREE.MeshStandardMaterial({ color: 0x505050 })
        );
        underConduit.position.set(0, 0.5, 0);
        transitionBox.add(underConduit);
        
        // Position between rows
        transitionBox.position.set(rowLength / 2 + 8, 0, zPos + 9);
        scene.add(transitionBox);
      }
      
      tracker.position.set(xCenter, 0, zPos);
      scene.add(tracker);
      trackerRows.push(tracker); // Store reference for sun tracking
    }

    // === COMPONENT INFO DATA - DETAILED ===
    const componentInfo = {
      'solar-panel': {
        title: 'Photovoltaic Panel',
        category: 'Power Generation',
        desc: 'Photovoltaic modules convert sunlight directly into electricity using semiconductor cells. Each panel contains 60-72 monocrystalline silicon cells connected in series. When photons hit the cells, they knock electrons loose from atoms in the semiconductor material, creating an electrical current. Modern panels achieve efficiencies of 20-23%, meaning they convert that percentage of incoming sunlight into usable electricity.',
        specs: [
          { label: 'Power Output', value: '400-600W' },
          { label: 'Voltage (Vmp)', value: '30-50V DC' },
          { label: 'Current (Imp)', value: '10-14A' },
          { label: 'Efficiency', value: '20-23%' },
          { label: 'Cell Type', value: 'Monocrystalline' },
          { label: 'Dimensions', value: '2m x 1m x 40mm' },
          { label: 'Weight', value: '20-25 kg' },
          { label: 'Warranty', value: '25 years' }
        ],
        fact: 'A single solar panel can prevent approximately 1 ton of CO2 emissions per year compared to coal-generated electricity. Over its 25-30 year lifespan, one panel offsets 25-30 tons of carbon dioxide.',
        related: ['junction-box', 'mc4-connector', 'wire-harness']
      },
      'torque-tube': {
        title: 'Torque Tube',
        category: 'Structural System',
        desc: 'The main structural shaft running the length of each tracker row. It serves as the primary rotating element that tilts all panels simultaneously to follow the sun. Made from high-strength galvanized steel, the tube must withstand significant torsional loads. Systems from Nextracker and Array Technologies use proprietary bearing designs for smooth rotation.',
        specs: [
          { label: 'Material', value: 'Galvanized Steel' },
          { label: 'Diameter', value: '4-6 inches' },
          { label: 'Wall Thickness', value: '0.125-0.25"' },
          { label: 'Rotation Range', value: '¬±60¬∞' },
          { label: 'Length', value: 'Up to 90m' },
          { label: 'Corrosion Protection', value: 'Hot-dip galvanized' }
        ],
        fact: 'Single-axis trackers can increase energy production by 25-35% compared to fixed-tilt systems. Nextracker\'s NX Horizon and Array\'s DuraTrack HZ are among the most deployed tracker systems worldwide.',
        related: ['driven-pile', 'tracker-motor', 'solar-panel']
      },
      'driven-pile': {
        title: 'Support Structure',
        category: 'Foundation System',
        desc: 'Steel posts driven directly into the ground to support the tracker structure. The W-beam shape provides an excellent strength-to-weight ratio and can be installed without concrete foundations in most soil conditions. This reduces installation time and cost while providing reliable long-term support for the solar array.',
        specs: [
          { label: 'Material', value: 'Galvanized W-beam' },
          { label: 'Embed Depth', value: '4-8 feet' },
          { label: 'Above Ground', value: '5-8 feet' },
          { label: 'Post Spacing', value: '15-20 feet' },
          { label: 'Load Capacity', value: '5,000+ lbs' },
          { label: 'Design Life', value: '30+ years' }
        ],
        fact: 'Driven pile foundations can be installed at a rate of 200-400 piles per day with specialized equipment, making them the fastest foundation method for utility-scale solar.',
        related: ['torque-tube', 'string-inverter']
      },
      'string-inverter': {
        title: 'String Inverter',
        category: 'Power Conversion',
        desc: 'String inverters convert DC electricity from solar panels into AC electricity compatible with the utility grid. They connect multiple panels in series (a "string") and include Maximum Power Point Tracking (MPPT) technology to continuously optimize energy harvest as conditions change throughout the day.',
        specs: [
          { label: 'DC Input', value: '600-1500V' },
          { label: 'AC Output', value: '480V 3-phase' },
          { label: 'Efficiency', value: '98-99%' },
          { label: 'MPPT Channels', value: '2-6' },
          { label: 'Power Rating', value: '50-125 kW' },
          { label: 'Protection', value: 'IP65 rated' },
          { label: 'Communication', value: 'WiFi/RS485' },
          { label: 'Cooling', value: 'Natural convection' }
        ],
        fact: 'Modern inverters are so efficient that less than 2% of the solar energy is lost during DC to AC conversion. They also provide grid support functions like reactive power control.',
        related: ['dc-cables', 'ac-conduit', 'combiner-box']
      },
      'combiner-box': {
        title: 'Combiner Box',
        category: 'Electrical Distribution',
        desc: 'An electrical enclosure that safely bundles multiple solar panel strings into a single, higher-current output for the inverter. Contains fuses for overcurrent protection, Surge Protection Devices (SPDs) for voltage spikes, and bus bars to aggregate DC power. Essential for large arrays where string counts exceed inverter input limits.',
        specs: [
          { label: 'Function', value: 'Aggregates strings' },
          { label: 'String Inputs', value: '8-32 strings' },
          { label: 'Protection', value: 'Fuses + SPD' },
          { label: 'Voltage Rating', value: '1500V DC' },
          { label: 'Enclosure', value: 'NEMA 4X rated' },
          { label: 'Monitoring', value: 'Optional per-string' }
        ],
        fact: 'Combiner boxes provide critical protection: fuses prevent overcurrent damage, SPDs protect against lightning and voltage spikes, and optional monitoring can detect underperforming strings within minutes.',
        related: ['home-run', 'dc-cables', 'string-inverter']
      },
      'wire-harness': {
        title: 'String Wiring System',
        category: 'Panel Interconnection',
        desc: 'The wiring that connects panels into strings starts at the junction box on the back of each panel. Pre-attached positive and negative DC cables extend from the junction box, ending in MC4 connectors. These MC4 connectors interconnect panels to form strings. Wiring runs along the mounting system (under panel rails) for protection, then routes to inverters or combiner boxes via UV-resistant conduit.',
        specs: [
          { label: 'Origin', value: 'Junction box (panel back)' },
          { label: 'Cable Type', value: 'Pre-attached DC wires' },
          { label: 'Connectors', value: 'MC4 (plug & play)' },
          { label: 'Routing', value: 'Along mounting rails' },
          { label: 'Protection', value: 'UV-resistant conduit' },
          { label: 'Destination', value: 'Inverter / Combiner' }
        ],
        fact: 'MC4 connectors are the industry standard for solar interconnections. The "MC" stands for Multi-Contact (the manufacturer) and "4" refers to the 4mm contact pin diameter.',
        related: ['junction-box', 'mc4-connector', 'string-inverter', 'combiner-box']
      },
      'home-run': {
        title: 'String Home Run',
        category: 'DC Collection',
        desc: 'After panels are interconnected via MC4 connectors, the main cables from each string are routed to the inverter or combiner box. These "home run" cables travel via UV-resistant conduit or along cable trays for protection. Proper routing meets safety codes and protects against environmental damage.',
        specs: [
          { label: 'From', value: 'End of string' },
          { label: 'To', value: 'Inverter / Combiner' },
          { label: 'Protection', value: 'UV conduit / armored' },
          { label: 'Wire Size', value: '10-12 AWG' },
          { label: 'Voltage Rating', value: '2000V DC' },
          { label: 'Color Code', value: 'Red +, Black -' }
        ],
        fact: 'Home run cables are often routed through UV-resistant conduit or armored cable to protect them from environmental damage and meet NEC safety codes.',
        related: ['combiner-box', 'string-inverter', 'wire-harness', 'mc4-connector']
      },
      'cab-clip': {
        title: 'CAB Clips',
        category: 'Cable Management',
        desc: 'Cable Attachment Brackets (CABs) are specialized clips that secure DC cables to the racking structure. They organize cable routing, prevent damage from wind-induced movement, and maintain proper cable bend radius. Essential for NEC-compliant installations and long-term reliability.',
        specs: [
          { label: 'Material', value: 'UV-stable polymer' },
          { label: 'Cable Capacity', value: '2-8 cables' },
          { label: 'Installation', value: 'Snap-on / bolt' },
          { label: 'Temperature', value: '-40¬∞C to 85¬∞C' },
          { label: 'UV Life', value: '25+ years' },
          { label: 'Reusable', value: 'Yes' }
        ],
        fact: 'Improperly secured cables are a leading cause of solar system failures. CABs prevent chafing, animal damage, and connector pull-out from cable movement.',
        related: ['wire-harness', 'home-run', 'dc-cables']
      },
      'mc4-connector': {
        title: 'MC4 Connector',
        category: 'Panel Interconnection',
        desc: 'MC4 (Multi-Contact 4mm) connectors are used to interconnect panels into strings. Pre-attached cables from each panel\'s junction box end in MC4 connectors - male on one cable, female on the other. Simply plug them together to connect panels in series. The weatherproof design allows connections to run along mounting rails.',
        specs: [
          { label: 'Purpose', value: 'Panel interconnection' },
          { label: 'Current Rating', value: '30-40A' },
          { label: 'Voltage Rating', value: '1500V DC' },
          { label: 'IP Rating', value: 'IP68 waterproof' },
          { label: 'Installation', value: 'Plug & play' },
          { label: 'Lifespan', value: '25+ years outdoor' }
        ],
        fact: 'MC4 connectors form the "links" that chain panels together into strings. The interconnection wiring runs along the mounting system under the panel rails for protection and neatness.',
        related: ['junction-box', 'solar-panel', 'wire-harness', 'combiner-box']
      },
      'junction-box': {
        title: 'Junction Box',
        category: 'Panel Component',
        desc: 'Mounted on the back of each solar panel, the junction box contains the positive (+) and negative (-) terminals where integrated wires originate. Most modern panels come with pre-attached DC cables that extend from the junction box and end in MC4 connectors. These cables are used to interconnect panels into strings.',
        specs: [
          { label: 'Location', value: 'Back of panel' },
          { label: 'Contains', value: '+/- terminals' },
          { label: 'Bypass Diodes', value: '3 per panel' },
          { label: 'Output', value: 'Pre-attached DC cables' },
          { label: 'Cable Ends', value: 'MC4 connectors' },
          { label: 'IP Rating', value: 'IP67 weatherproof' }
        ],
        fact: 'The junction box is the starting point for string wiring. Pre-attached cables with MC4 connectors make installation fast and reliable - just plug panels together!',
        related: ['solar-panel', 'mc4-connector', 'wire-harness']
      },
      'cable-tray': {
        title: 'Cable Tray',
        category: 'Cable Management',
        desc: 'Structural support systems for routing large cable bundles across the solar field. Trays protect cables from physical damage, organize the DC and AC collection systems, and provide clear access paths for maintenance. Various types include ladder tray, solid bottom, and wire basket.',
        specs: [
          { label: 'Types', value: 'Ladder/Solid/Basket' },
          { label: 'Material', value: 'Aluminum or Steel' },
          { label: 'Width', value: '6-24 inches' },
          { label: 'Support Spacing', value: '5-10 feet' },
          { label: 'Load Rating', value: '50-100 lbs/ft' },
          { label: 'Finish', value: 'Hot-dip galvanized' }
        ],
        fact: 'Properly designed cable tray systems allow for future expansion and make troubleshooting much easier by keeping cables organized and accessible.',
        related: ['dc-cables', 'ac-conduit', 'cab-clip']
      },
      'ground-wire': {
        title: 'Equipment Grounding',
        category: 'Safety System',
        desc: 'The equipment grounding system bonds all metal components to earth ground, providing a safe path for fault currents and protecting personnel from electric shock. Required by the National Electrical Code (NEC) for all PV systems. Includes ground rods, conductors, and bonding jumpers.',
        specs: [
          { label: 'Conductor Size', value: '6-10 AWG copper' },
          { label: 'Color', value: 'Green or bare' },
          { label: 'Ground Rods', value: '8ft min copper' },
          { label: 'Resistance', value: '<25 ohms' },
          { label: 'Connections', value: 'Listed lugs' },
          { label: 'Bonding', value: 'All metal parts' }
        ],
        fact: 'Lightning strikes on solar arrays are relatively common. A proper grounding system safely dissipates millions of volts to earth in microseconds.',
        related: ['driven-pile', 'string-inverter', 'combiner-box']
      },
      'dc-cables': {
        title: 'DC Cables',
        category: 'Power Transmission',
        desc: 'Specialized photovoltaic cables designed for the unique demands of solar installations. PV wire must withstand high DC voltages, UV exposure, extreme temperatures, and decades of outdoor service. Red indicates positive (+) and black indicates negative (-) polarity.',
        specs: [
          { label: 'Type', value: 'PV Wire / USE-2' },
          { label: 'Voltage', value: '2000V DC' },
          { label: 'Temperature', value: '90¬∞C rated' },
          { label: 'UV Resistant', value: 'Yes' },
          { label: 'Sunlight Resistant', value: 'Yes' },
          { label: 'Direct Burial', value: 'Yes' }
        ],
        fact: 'DC arcs are more dangerous than AC arcs because they don\'t self-extinguish at zero-crossing. This is why proper DC-rated equipment and installation practices are critical.',
        related: ['string-inverter', 'combiner-box', 'mc4-connector']
      },
      'ac-conduit': {
        title: 'AC Conduit',
        category: 'Power Transmission',
        desc: 'Metal or PVC conduit protecting AC output cables from the inverter to the point of interconnection. Carries 3-phase AC power at 480V or higher to transformers and switchgear. Must be properly grounded, weatherproofed, and sized for the current load.',
        specs: [
          { label: 'Material', value: 'EMT / RMC / PVC' },
          { label: 'Size', value: '1-4 inches' },
          { label: 'Voltage', value: '480V 3-phase' },
          { label: 'Fill Ratio', value: '40% max' },
          { label: 'Supports', value: 'Every 10 feet' },
          { label: 'Fittings', value: 'Weatherproof' }
        ],
        fact: 'The AC collection system typically accounts for 10-15% of total project costs but is critical for efficiently moving power from distributed inverters to the substation.',
        related: ['string-inverter', 'cable-tray', 'ground-wire']
      },
      'tracker-motor': {
        title: 'Tracker Drive System',
        category: 'Motion Control',
        desc: 'The motor and gearbox assembly that rotates the torque tube to follow the sun. Uses sensors or astronomical algorithms to determine sun position, then motors slowly adjust panel angle throughout the day. By keeping panels perpendicular to sunlight, trackers boost energy production 15-40% vs fixed systems.',
        specs: [
          { label: 'Sensing', value: 'Sensors or algorithms' },
          { label: 'Movement', value: 'Slew drive motor' },
          { label: 'Rotation Range', value: '¬±60¬∞ (single-axis)' },
          { label: 'Speed', value: '0.5-1¬∞/minute' },
          { label: 'Control', value: 'GPS + astronomical data' },
          { label: 'Power Boost', value: '+15-40% vs fixed' }
        ],
        fact: 'Trackers use "backtracking" algorithms in morning/evening to prevent row-to-row shading. Instead of pointing directly at the low sun, they angle slightly away to avoid shadows from neighboring rows - maximizing total farm output.',
        related: ['torque-tube', 'solar-panel', 'driven-pile']
      },
      'substation': {
        title: 'Substation',
        category: 'Grid Connection',
        desc: 'The central collection point where power from all inverters is combined and voltage is stepped up for transmission. Contains main power transformers, medium-voltage switchgear, protection relays, revenue metering, and SCADA communication equipment for remote monitoring and control.',
        specs: [
          { label: 'Transformer', value: '34.5kV step-up' },
          { label: 'Switchgear', value: 'Medium voltage' },
          { label: 'Protection', value: 'Digital relays' },
          { label: 'Metering', value: 'Revenue grade' },
          { label: 'Communication', value: 'SCADA/DNP3' },
          { label: 'Grounding', value: 'Ground grid' }
        ],
        fact: 'A typical 100MW solar farm substation handles enough power to supply approximately 20,000 homes during peak production.',
        related: ['string-inverter', 'ac-conduit']
      },
      'free-space': {
        title: 'Inter-Row Spacing',
        category: 'Site Design',
        desc: 'The spacing between tracker rows is carefully calculated to minimize shading while maximizing land use. This "pitch" distance depends on the site latitude, tracker height, and acceptable shading losses. Proper spacing ensures panels don\'t shade each other during morning and afternoon hours.',
        specs: [
          { label: 'Row Pitch', value: '18-25 feet' },
          { label: 'GCR', value: '30-45%' },
          { label: 'Shading Loss', value: '<2% target' },
          { label: 'Access Width', value: '12ft minimum' },
          { label: 'Mowing', value: 'Required clearance' },
          { label: 'Drainage', value: 'Grade consideration' }
        ],
        fact: 'Ground Coverage Ratio (GCR) is the percentage of land covered by panels. Higher GCR means more power per acre but increases row-to-row shading losses.',
        related: ['solar-panel', 'torque-tube', 'driven-pile']
      },
      'did-you-know': {
        title: 'Solar Farm Facts',
        category: 'Education',
        desc: 'Utility-scale solar farms are one of the fastest-growing sources of electricity generation worldwide. A typical 100MW solar farm covers about 500-700 acres and can power approximately 20,000 homes. Solar panels have no moving parts (except trackers) and require minimal maintenance over their 25-30 year lifespan.',
        specs: [
          { label: 'Land Use', value: '5-7 acres/MW' },
          { label: 'Homes Powered', value: '200 per MW' },
          { label: 'CO2 Avoided', value: '1,400 tons/MW/yr' },
          { label: 'Water Use', value: 'Minimal' },
          { label: 'Jobs Created', value: '5-7 per MW' },
          { label: 'Construction', value: '6-12 months' }
        ],
        fact: 'The cost of solar electricity has dropped 89% since 2010, making it now cheaper than coal and natural gas in most regions of the world.',
        related: ['solar-panel', 'string-inverter', 'substation']
      },
      'perimeter-fence': {
        title: 'Perimeter Fence',
        category: 'Site Security',
        desc: 'A security fence surrounds the entire solar farm to prevent unauthorized access, protect valuable equipment from theft and vandalism, and ensure public safety. The fence also keeps wildlife and livestock from damaging panels or electrical equipment.',
        specs: [
          { label: 'Height', value: '6-8 feet' },
          { label: 'Type', value: 'Chain-link/Barbed wire' },
          { label: 'Top Wire', value: '3-strand barbed' },
          { label: 'Gates', value: 'Locked access points' },
          { label: 'Signage', value: 'Warning signs' },
          { label: 'Grounding', value: 'Bonded to ground grid' }
        ],
        fact: 'Security fencing is required by electrical codes and insurance policies. Many solar farms also use camera surveillance and motion sensors for additional protection.',
        related: ['substation', 'ground-wire']
      }
    };

    // === MARKER SYSTEM VARIABLES ===
    let markers = [];
    let markerGroup = null;
    let raycaster = null;
    let mouse = null;
    let labelElements = [];
    
    function createMarkers() {
      markers = [];
      markerGroup = new THREE.Group();
      raycaster = new THREE.Raycaster();
      mouse = new THREE.Vector2();
      
      // Clear existing labels
      const labelsContainer = document.getElementById('labels-container');
      labelsContainer.innerHTML = '';
      labelElements = [];
      
      function createInfoMarker(x, y, z, componentKey, labelText, scale = 1) {
        // Invisible 3D marker for position tracking only
        const markerGeo = new THREE.SphereGeometry(0.15 * scale, 8, 8);
        const markerMat = new THREE.MeshBasicMaterial({ 
          transparent: true,
          opacity: 0
        });
        const marker = new THREE.Mesh(markerGeo, markerMat);
        marker.position.set(x, y, z);
        marker.userData.componentKey = componentKey;
        marker.userData.isMarker = true;
        marker.userData.labelText = labelText;
        
        // Create HTML label with connecting line
        const labelWrapper = document.createElement('div');
        labelWrapper.className = 'marker-label-wrapper';
        labelWrapper.style.cssText = `
          position: absolute;
          display: flex;
          flex-direction: column;
          align-items: center;
          pointer-events: none;
          transform: translate(-50%, -100%);
        `;
        
        const label = document.createElement('div');
        label.className = 'marker-label';
        label.innerHTML = labelText;
        label.style.cssText = `
          color: #fff;
          font-size: 13px;
          font-weight: 700;
          text-transform: uppercase;
          letter-spacing: 1.5px;
          background: linear-gradient(135deg, rgba(20,80,100,0.95), rgba(10,50,70,0.95));
          padding: 10px 16px;
          border-radius: 6px;
          pointer-events: auto;
          cursor: pointer;
          white-space: nowrap;
          border-left: 4px solid #38bdf8;
          text-shadow: 0 2px 4px rgba(0,0,0,0.5);
          margin-bottom: 8px;
          box-shadow: 0 4px 15px rgba(0,0,0,0.4), 0 0 20px rgba(56,189,248,0.2);
          transition: all 0.2s ease;
        `;
        label.dataset.componentKey = componentKey;
        
        // Add hover effects
        label.addEventListener('mouseenter', () => {
          label.style.transform = 'scale(1.08)';
          label.style.background = 'linear-gradient(135deg, rgba(56,189,248,0.95), rgba(20,100,130,0.95))';
          label.style.boxShadow = '0 6px 25px rgba(0,0,0,0.5), 0 0 30px rgba(56,189,248,0.4)';
        });
        label.addEventListener('mouseleave', () => {
          label.style.transform = 'scale(1)';
          label.style.background = 'linear-gradient(135deg, rgba(20,80,100,0.95), rgba(10,50,70,0.95))';
          label.style.boxShadow = '0 4px 15px rgba(0,0,0,0.4), 0 0 20px rgba(56,189,248,0.2)';
        });
        
        label.addEventListener('click', (e) => {
          e.stopPropagation();
          showInfoBox(componentKey);
        });
        
        // Connecting line - more visible
        const line = document.createElement('div');
        line.style.cssText = `
          width: 2px;
          height: 35px;
          background: linear-gradient(to bottom, rgba(56,189,248,0.8), rgba(255,255,255,0.3));
          border-radius: 1px;
        `;
        
        // Dot at bottom of line - larger and glowing
        const dot = document.createElement('div');
        dot.style.cssText = `
          width: 12px;
          height: 12px;
          border-radius: 50%;
          background: radial-gradient(circle, #fff 30%, #38bdf8 100%);
          border: 2px solid #38bdf8;
          box-shadow: 0 0 10px rgba(56,189,248,0.6), 0 0 20px rgba(56,189,248,0.3);
          animation: pulse-dot 2s ease-in-out infinite;
        `;
        
        labelWrapper.appendChild(label);
        labelWrapper.appendChild(line);
        labelWrapper.appendChild(dot);
        labelsContainer.appendChild(labelWrapper);
        
        marker.userData.labelElement = labelWrapper;
        labelElements.push({ marker, label: labelWrapper });
        
        markers.push(marker);
        return marker;
      }
      
      // Add markers SPREAD OUT across the farm - NO OVERLAPPING
      // Right block at x=140, Left block at x=-140
      // Rows at z: 117, 99, 81, 63, 45, 27, -27, -45, -63, -81, -99, -117
      
      const rightX = 140;   // Right block center
      const leftX = -140;   // Left block center
      
      // === FAR RIGHT SIDE OF RIGHT BLOCK ===
      // PHOTOVOLTAIC PANEL - front right, on panel row
      markerGroup.add(createInfoMarker(rightX + 80, 7.5, 117, 'solar-panel', 'PHOTOVOLTAIC PANEL', 1.1));
      
      // === MID RIGHT SIDE ===
      // STRING INVERTER - visible on post, on panel row
      markerGroup.add(createInfoMarker(rightX + 60, 3.5, 63, 'string-inverter', 'STRING INVERTER', 1.0));
      
      // === CENTER OF RIGHT BLOCK ===
      // TORQUE TUBE - center of a row, on panel row
      markerGroup.add(createInfoMarker(rightX, 5.5, 45, 'torque-tube', 'TORQUE TUBE', 1.0));
      
      // === LEFT SIDE OF RIGHT BLOCK ===
      // SUPPORT POST - on panel row
      markerGroup.add(createInfoMarker(rightX - 50, 2.5, 99, 'driven-pile', 'SUPPORT POST', 1.0));
      
      // COMBINER BOX - at center of row (where midCBX is placed), on panel row
      markerGroup.add(createInfoMarker(rightX, 3, 27, 'combiner-box', 'COMBINER BOX', 1.0));
      
      // === FAR LEFT SIDE OF LEFT BLOCK ===
      // JUNCTION BOX - on panel row
      markerGroup.add(createInfoMarker(leftX - 70, 6.5, 99, 'junction-box', 'JUNCTION BOX', 1.0));
      
      // MC4 CONNECTORS - on panel row
      markerGroup.add(createInfoMarker(rightX + 20, 6, 63, 'mc4-connector', 'MC4 CONNECTORS', 1.0));
      
      // === MID LEFT BLOCK ===
      // STRING WIRING - on panel row
      markerGroup.add(createInfoMarker(rightX - 20, 5.5, 81, 'wire-harness', 'STRING WIRING', 1.0));
      
      // DC CABLES - on panel row
      markerGroup.add(createInfoMarker(rightX + 40, 4.5, 45, 'dc-cables', 'DC CABLES', 1.0));
      
      // === RIGHT SIDE OF LEFT BLOCK ===
      // CABLE TRAY - on panel row
      markerGroup.add(createInfoMarker(leftX + 70, 4.2, 99, 'cable-tray', 'CABLE TRAY', 1.0));
      
      // CAB CLIPS - on panel row
      markerGroup.add(createInfoMarker(leftX + 90, 5.8, 45, 'cab-clip', 'CAB CLIPS', 0.9));
      
      // === BACK ROWS (negative Z) ===
      // TRACKER MOTOR - back left, on panel row
      markerGroup.add(createInfoMarker(leftX - 80, 5, -45, 'tracker-motor', 'TRACKER MOTOR', 1.0));
      
      // HOME RUN - back right, on panel row
      markerGroup.add(createInfoMarker(rightX + 70, 4, -45, 'home-run', 'STRING HOME RUN', 1.0));
      
      // GROUNDING - back center-left, on panel row
      markerGroup.add(createInfoMarker(leftX + 40, 2, -63, 'ground-wire', 'GROUNDING', 1.0));
      
      // AC CONDUIT - back center-right, at ground level
      markerGroup.add(createInfoMarker(rightX, 1.5, -81, 'ac-conduit', 'AC CONDUIT', 1.0));
      
      // === CENTER AREA ===
      // ROW SPACING - between two adjacent rows to show the spacing
      markerGroup.add(createInfoMarker(140, 1, -36, 'free-space', 'ROW SPACING', 1.0));
      
      // SUBSTATION - center
      markerGroup.add(createInfoMarker(0, 10, 0, 'substation', 'SUBSTATION', 1.2));
      
      // DID YOU KNOW - front center, on panel row
      markerGroup.add(createInfoMarker(0, 6, 117, 'did-you-know', 'DID YOU KNOW?', 1.1));
      
      // PERIMETER FENCE - at the back center of the farm
      markerGroup.add(createInfoMarker(0, 3, -140, 'perimeter-fence', 'FENCE', 1.0));
      
      scene.add(markerGroup);
      
      // Add click listener for 3D markers
      renderer.domElement.addEventListener('click', onMarkerClick);
    }
    
    // Update label positions each frame
    function updateLabelPositions() {
      if (!labelElements.length || !markersVisible) return;
      
      labelElements.forEach(({ marker, label }) => {
        // Get screen position of marker
        const vector = marker.position.clone();
        vector.project(camera);
        
        const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
        const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
        
        // Check if marker is in front of camera and within reasonable distance
        const dist = camera.position.distanceTo(marker.position);
        if (vector.z < 1 && dist < 400) {
          label.style.left = x + 'px';
          label.style.top = y + 'px';
          label.style.display = 'flex';
          // Fade based on distance
          const opacity = Math.max(0.4, Math.min(1, 1 - (dist - 80) / 320));
          label.style.opacity = opacity;
        } else {
          label.style.display = 'none';
        }
      });
    }
    
    function onMarkerClick(event) {
      if (!raycaster || !mouse || !markers.length) return;
      
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
      
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(markers, true);
      
      if (intersects.length > 0) {
        let clickedMarker = intersects[0].object;
        while (clickedMarker && !clickedMarker.userData.isMarker) {
          clickedMarker = clickedMarker.parent;
        }
        if (clickedMarker && clickedMarker.userData.componentKey) {
          showInfoBox(clickedMarker.userData.componentKey);
        }
      }
    }
    
    // === DETAIL PANEL FUNCTIONS ===
    function showInfoBox(componentKey) {
      const info = componentInfo[componentKey];
      if (!info) return;
      
      // Find the marker for this component and zoom to it
      const markerData = labelElements.find(el => el.marker.userData.componentKey === componentKey);
      if (markerData) {
        const pos = markerData.marker.position;
        // Calculate camera position - offset from marker
        const camOffset = 25; // Distance from component
        const camHeight = 12; // Height above component
        const targetX = pos.x;
        const targetY = pos.y;
        const targetZ = pos.z;
        
        // Animate camera to view the component
        animateCameraTo(
          pos.x + camOffset * 0.5, 
          pos.y + camHeight, 
          pos.z + camOffset,
          targetX, targetY, targetZ
        );
      }
      
      // Populate detail panel
      document.getElementById('detail-title').innerHTML = info.title;
      document.getElementById('detail-category').innerHTML = info.category;
      document.getElementById('detail-desc').innerHTML = info.desc;
      
      // Populate specs grid
      const specsContainer = document.getElementById('detail-specs');
      specsContainer.innerHTML = info.specs.map(spec => `
        <div style="background:rgba(255,255,255,0.05); padding:10px; border-radius:3px;">
          <div style="color:#888; font-size:0.75em; text-transform:uppercase; margin-bottom:4px;">${spec.label}</div>
          <div style="color:#fff; font-size:0.95em; font-weight:500;">${spec.value}</div>
        </div>
      `).join('');
      
      // Generate component diagram
      const imageContainer = document.getElementById('detail-image');
      imageContainer.innerHTML = getComponentDiagram(componentKey);
      
      // Populate gallery with detail diagrams
      const galleryContainer = document.getElementById('detail-gallery');
      galleryContainer.innerHTML = getComponentGallery(componentKey);
      
      // Populate fact
      document.getElementById('detail-fact-text').innerHTML = info.fact;
      
      // Populate related components
      const relatedContainer = document.getElementById('detail-related');
      relatedContainer.innerHTML = info.related.map(key => {
        const relatedInfo = componentInfo[key];
        if (!relatedInfo) return '';
        return `
          <button onclick="showInfoBox('${key}')" style="background:rgba(255,255,255,0.1); border:1px solid rgba(255,255,255,0.2); color:#fff; padding:8px 12px; border-radius:3px; cursor:pointer; font-size:0.8em;">
            ${relatedInfo.title}
          </button>
        `;
      }).join('');
      
      // Show panel with animation
      document.getElementById('detail-overlay').style.display = 'block';
      const panel = document.getElementById('detail-panel');
      panel.style.display = 'block';
      setTimeout(() => {
        panel.style.transform = 'translateX(0)';
      }, 10);
      
      // Scroll to top
      panel.scrollTop = 0;
    }
    
    // Generate SVG diagrams for each component
    function getComponentDiagram(key) {
      const diagrams = {
        'solar-panel': `
          <svg viewBox="0 0 200 120" style="width:100%;height:100%;">
            <defs>
              <linearGradient id="panelGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                <stop offset="0%" style="stop-color:#1a3a5c"/>
                <stop offset="100%" style="stop-color:#0d1f33"/>
              </linearGradient>
            </defs>
            <rect x="10" y="10" width="180" height="100" fill="url(#panelGrad)" stroke="#4aa" stroke-width="2" rx="2"/>
            <!-- Grid lines -->
            <g stroke="#2a4a6a" stroke-width="0.5">
              <line x1="10" y1="35" x2="190" y2="35"/>
              <line x1="10" y1="60" x2="190" y2="60"/>
              <line x1="10" y1="85" x2="190" y2="85"/>
              <line x1="40" y1="10" x2="40" y2="110"/>
              <line x1="70" y1="10" x2="70" y2="110"/>
              <line x1="100" y1="10" x2="100" y2="110"/>
              <line x1="130" y1="10" x2="130" y2="110"/>
              <line x1="160" y1="10" x2="160" y2="110"/>
            </g>
            <!-- Cells -->
            <g fill="#1e4060">
              ${[0,1,2,3,4,5].map(col => [0,1,2,3].map(row => 
                `<rect x="${15+col*30}" y="${15+row*25}" width="25" height="20" rx="1"/>`
              ).join('')).join('')}
            </g>
            <text x="100" y="70" text-anchor="middle" fill="#4aa" font-size="8">72 Monocrystalline Cells</text>
          </svg>`,
        'torque-tube': `
          <svg viewBox="0 0 200 120" style="width:100%;height:100%;">
            <!-- Title -->
            <text x="100" y="10" text-anchor="middle" fill="#4aa" font-size="7">SINGLE-AXIS TRACKER (East-West Rotation)</text>
            
            <defs>
              <linearGradient id="tubeGrad" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" style="stop-color:#999"/>
                <stop offset="50%" style="stop-color:#666"/>
                <stop offset="100%" style="stop-color:#999"/>
              </linearGradient>
            </defs>
            
            <!-- Torque Tube -->
            <rect x="15" y="50" width="170" height="16" fill="url(#tubeGrad)" rx="8"/>
            <text x="100" y="61" text-anchor="middle" fill="#333" font-size="5">TORQUE TUBE</text>
            
            <!-- Rotation arrows showing ¬±60¬∞ -->
            <path d="M 100 30 A 25 25 0 0 1 120 50" stroke="#0f8" stroke-width="2" fill="none"/>
            <polygon points="120,50 115,45 118,53" fill="#0f8"/>
            <path d="M 100 86 A 25 25 0 0 0 120 66" stroke="#0f8" stroke-width="2" fill="none"/>
            <polygon points="120,66 115,71 118,63" fill="#0f8"/>
            <text x="135" y="58" fill="#0f8" font-size="6">¬±60¬∞</text>
            
            <!-- Array-style bearing (left) - large shield with flame cutouts -->
            <path d="M 22 32 L 58 32 Q 66 40 66 58 Q 66 76 58 84 L 22 84 Z" fill="#b0b0b0" stroke="#888"/>
            <!-- Flame-like cutouts (Array signature design) -->
            <path d="M 30 40 Q 35 36 40 40 Q 45 36 50 40" stroke="#87CEEB" stroke-width="3" fill="none"/>
            <path d="M 30 52 Q 35 48 40 52 Q 45 48 50 52" stroke="#87CEEB" stroke-width="3" fill="none"/>
            <path d="M 30 64 Q 35 60 40 64 Q 45 60 50 64" stroke="#87CEEB" stroke-width="3" fill="none"/>
            <!-- Horizontal U-channel arms -->
            <rect x="16" y="42" width="10" height="6" fill="#707070"/>
            <rect x="16" y="68" width="10" height="6" fill="#707070"/>
            <!-- Bolts -->
            <circle cx="20" cy="45" r="2" fill="#333"/>
            <circle cx="20" cy="71" r="2" fill="#333"/>
            <text x="44" y="97" text-anchor="middle" fill="#2255aa" font-size="5" font-weight="bold">ARRAY</text>
            
            <!-- Nextracker-style bearing (right) -->
            <circle cx="160" cy="58" r="16" fill="#666" stroke="#888" stroke-width="2"/>
            <circle cx="160" cy="58" r="10" fill="#555"/>
            <circle cx="160" cy="80" r="8" fill="#ff6600"/>
            <line x1="157" y1="77" x2="163" y2="83" stroke="#fff" stroke-width="2"/>
            <line x1="163" y1="77" x2="157" y2="83" stroke="#fff" stroke-width="2"/>
            <text x="160" y="97" text-anchor="middle" fill="#ff6600" font-size="5" font-weight="bold">NEXTRACKER</text>
            
            <text x="100" y="112" text-anchor="middle" fill="#888" font-size="6">Rotates all panels simultaneously to follow the sun</text>
          </svg>`,
        'driven-pile': `
          <svg viewBox="0 0 200 120" style="width:100%;height:100%;">
            <!-- Ground -->
            <rect x="0" y="85" width="200" height="35" fill="#3a5a40"/>
            <line x1="0" y1="85" x2="200" y2="85" stroke="#5a8a50" stroke-width="2"/>
            
            <!-- W-beam post -->
            <rect x="88" y="25" width="24" height="95" fill="#777"/>
            <rect x="82" y="25" width="36" height="6" fill="#888"/>
            <rect x="82" y="40" width="36" height="3" fill="#666"/>
            <rect x="82" y="55" width="36" height="3" fill="#666"/>
            
            <!-- Torque tube (top) -->
            <rect x="40" y="18" width="120" height="14" fill="#888" rx="7"/>
            
            <!-- Bearing assembly (Array style) -->
            <path d="M 110 15 L 145 15 Q 160 20 160 35 Q 160 50 145 55 L 110 55 Z" fill="#999" stroke="#777" stroke-width="1"/>
            <rect x="120" y="22" width="25" height="6" fill="#3a5a4a"/>
            <rect x="120" y="35" width="25" height="6" fill="#3a5a4a"/>
            <rect x="120" y="48" width="20" height="5" fill="#3a5a4a"/>
            
            <!-- Bolts -->
            <circle cx="115" cy="25" r="3" fill="#444"/>
            <circle cx="115" cy="45" r="3" fill="#444"/>
            
            <!-- Dimensions -->
            <line x1="55" y1="25" x2="55" y2="85" stroke="#4aa" stroke-width="1" stroke-dasharray="3"/>
            <text x="45" y="55" fill="#4aa" font-size="6" transform="rotate(-90 45 55)">5-8 ft</text>
            <line x1="145" y1="85" x2="145" y2="115" stroke="#4aa" stroke-width="1" stroke-dasharray="3"/>
            <text x="155" y="102" fill="#4aa" font-size="6">4-8 ft embed</text>
            
            <text x="100" y="10" text-anchor="middle" fill="#4aa" font-size="7">Bearing mounts tube to post</text>
          </svg>`,
        'string-inverter': `
          <svg viewBox="0 0 200 120" style="width:100%;height:100%;">
            <!-- Enclosure -->
            <rect x="40" y="15" width="120" height="90" fill="#444" stroke="#666" stroke-width="2" rx="3"/>
            <!-- Display -->
            <rect x="55" y="25" width="50" height="25" fill="#1a3a45" stroke="#4aa" stroke-width="1" rx="2"/>
            <text x="80" y="42" text-anchor="middle" fill="#4aa" font-size="8">480V AC</text>
            <!-- LEDs -->
            <circle cx="120" cy="32" r="4" fill="#0f0"/>
            <circle cx="135" cy="32" r="4" fill="#0f0"/>
            <!-- Vents -->
            <g fill="#333">
              <rect x="55" y="60" width="90" height="3"/>
              <rect x="55" y="67" width="90" height="3"/>
              <rect x="55" y="74" width="90" height="3"/>
            </g>
            <!-- Connections -->
            <rect x="55" y="85" width="15" height="10" fill="#a33" rx="1"/>
            <rect x="75" y="85" width="15" height="10" fill="#33a" rx="1"/>
            <rect x="95" y="85" width="15" height="10" fill="#3a3" rx="1"/>
            <text x="62" y="110" fill="#a66" font-size="6">DC+</text>
            <text x="82" y="110" fill="#66a" font-size="6">DC-</text>
            <text x="100" y="110" fill="#6a6" font-size="6">GND</text>
          </svg>`,
        'combiner-box': `
          <svg viewBox="0 0 200 120" style="width:100%;height:100%;">
            <!-- Title -->
            <text x="100" y="10" text-anchor="middle" fill="#4aa" font-size="7">COMBINER BOX INTERNALS</text>
            
            <!-- Box enclosure -->
            <rect x="25" y="15" width="150" height="95" fill="#ccc" stroke="#888" stroke-width="2" rx="3"/>
            
            <!-- String inputs (left side - red cables) -->
            <text x="15" y="35" fill="#a33" font-size="5" text-anchor="end">STR 1</text>
            <text x="15" y="50" fill="#a33" font-size="5" text-anchor="end">STR 2</text>
            <text x="15" y="65" fill="#a33" font-size="5" text-anchor="end">STR 3</text>
            <text x="15" y="80" fill="#a33" font-size="5" text-anchor="end">STR 4</text>
            <line x1="18" y1="32" x2="35" y2="32" stroke="#a33" stroke-width="3"/>
            <line x1="18" y1="47" x2="35" y2="47" stroke="#a33" stroke-width="3"/>
            <line x1="18" y1="62" x2="35" y2="62" stroke="#a33" stroke-width="3"/>
            <line x1="18" y1="77" x2="35" y2="77" stroke="#a33" stroke-width="3"/>
            
            <!-- DC input terminals -->
            <rect x="35" y="28" width="12" height="8" fill="#a33" stroke="#800"/>
            <rect x="35" y="43" width="12" height="8" fill="#a33" stroke="#800"/>
            <rect x="35" y="58" width="12" height="8" fill="#a33" stroke="#800"/>
            <rect x="35" y="73" width="12" height="8" fill="#a33" stroke="#800"/>
            
            <!-- Fuses (yellow) -->
            <rect x="55" y="25" width="25" height="12" fill="#ffcc00" stroke="#cc9900" rx="2"/>
            <rect x="55" y="40" width="25" height="12" fill="#ffcc00" stroke="#cc9900" rx="2"/>
            <rect x="55" y="55" width="25" height="12" fill="#ffcc00" stroke="#cc9900" rx="2"/>
            <rect x="55" y="70" width="25" height="12" fill="#ffcc00" stroke="#cc9900" rx="2"/>
            <text x="67" y="34" text-anchor="middle" fill="#333" font-size="4">15A</text>
            <text x="67" y="49" text-anchor="middle" fill="#333" font-size="4">15A</text>
            <text x="67" y="64" text-anchor="middle" fill="#333" font-size="4">15A</text>
            <text x="67" y="79" text-anchor="middle" fill="#333" font-size="4">15A</text>
            <text x="67" y="95" text-anchor="middle" fill="#cc9900" font-size="6">FUSES</text>
            
            <!-- Bus bars (copper) -->
            <rect x="90" y="25" width="8" height="60" fill="#b87333" stroke="#996633"/>
            <rect x="102" y="25" width="8" height="60" fill="#666" stroke="#444"/>
            <text x="99" y="95" text-anchor="middle" fill="#b87333" font-size="5">BUS BARS</text>
            
            <!-- SPD (blue) -->
            <rect x="120" y="30" width="25" height="45" fill="#0066cc" stroke="#004499" rx="2"/>
            <circle cx="132" cy="42" r="4" fill="#00ff00"/>
            <text x="132" y="58" text-anchor="middle" fill="#fff" font-size="4">SPD</text>
            <text x="132" y="68" text-anchor="middle" fill="#aaf" font-size="4">OK</text>
            <text x="132" y="95" text-anchor="middle" fill="#08f" font-size="5">SURGE PROT.</text>
            
            <!-- Output (right side) -->
            <line x1="150" y1="50" x2="180" y2="50" stroke="#0a8" stroke-width="4"/>
            <polygon points="180,45 195,50 180,55" fill="#0a8"/>
            <text x="185" y="65" fill="#0a8" font-size="5">TO</text>
            <text x="185" y="73" fill="#0a8" font-size="5">INVERTER</text>
            
            <!-- Warning label -->
            <rect x="145" y="85" width="28" height="18" fill="#ff0" stroke="#f90"/>
            <text x="159" y="95" text-anchor="middle" fill="#000" font-size="5">‚ö°1500V</text>
            <text x="159" y="102" text-anchor="middle" fill="#000" font-size="4">DC</text>
          </svg>`,
        'wire-harness': `
          <svg viewBox="0 0 200 120" style="width:100%;height:100%;">
            <!-- Title -->
            <text x="100" y="10" text-anchor="middle" fill="#4aa" font-size="7">STRING WIRING FLOW</text>
            
            <!-- Three panels in a row (top view showing backs) -->
            <rect x="10" y="18" width="50" height="35" fill="#333" stroke="#555"/>
            <rect x="75" y="18" width="50" height="35" fill="#333" stroke="#555"/>
            <rect x="140" y="18" width="50" height="35" fill="#333" stroke="#555"/>
            
            <!-- Junction boxes on each panel -->
            <rect x="25" y="28" width="20" height="15" fill="#444" stroke="#666" rx="2"/>
            <rect x="90" y="28" width="20" height="15" fill="#444" stroke="#666" rx="2"/>
            <rect x="155" y="28" width="20" height="15" fill="#444" stroke="#666" rx="2"/>
            <text x="35" y="38" text-anchor="middle" fill="#888" font-size="4">J-Box</text>
            <text x="100" y="38" text-anchor="middle" fill="#888" font-size="4">J-Box</text>
            <text x="165" y="38" text-anchor="middle" fill="#888" font-size="4">J-Box</text>
            
            <!-- Pre-attached cables from junction boxes -->
            <path d="M 45 36 L 55 36 L 55 60" stroke="#a33" stroke-width="2" fill="none"/>
            <path d="M 25 36 L 15 36 L 15 60" stroke="#33a" stroke-width="2" fill="none"/>
            <path d="M 110 36 L 120 36 L 120 60" stroke="#a33" stroke-width="2" fill="none"/>
            <path d="M 90 36 L 80 36 L 80 60" stroke="#33a" stroke-width="2" fill="none"/>
            <path d="M 175 36 L 185 36 L 185 60" stroke="#a33" stroke-width="2" fill="none"/>
            <path d="M 155 36 L 145 36 L 145 60" stroke="#33a" stroke-width="2" fill="none"/>
            
            <!-- MC4 connectors (circles where cables meet) -->
            <circle cx="55" cy="65" r="4" fill="#a33" stroke="#fff" stroke-width="1"/>
            <circle cx="80" cy="65" r="4" fill="#33a" stroke="#fff" stroke-width="1"/>
            <circle cx="120" cy="65" r="4" fill="#a33" stroke="#fff" stroke-width="1"/>
            <circle cx="145" cy="65" r="4" fill="#33a" stroke="#fff" stroke-width="1"/>
            
            <!-- MC4 interconnection lines -->
            <line x1="55" y1="65" x2="80" y2="65" stroke="#666" stroke-width="3"/>
            <line x1="120" y1="65" x2="145" y2="65" stroke="#666" stroke-width="3"/>
            
            <!-- Labels -->
            <text x="67" y="77" text-anchor="middle" fill="#4aa" font-size="5">MC4</text>
            <text x="132" y="77" text-anchor="middle" fill="#4aa" font-size="5">MC4</text>
            
            <!-- Mounting rail representation -->
            <rect x="5" y="58" width="190" height="4" fill="#666" opacity="0.5"/>
            <text x="100" y="90" text-anchor="middle" fill="#888" font-size="5">Wiring runs along mounting rails</text>
            
            <!-- Arrow to inverter/combiner -->
            <path d="M 185 65 L 195 65" stroke="#4aa" stroke-width="2"/>
            <polygon points="195,62 200,65 195,68" fill="#4aa"/>
            <text x="100" y="100" text-anchor="middle" fill="#888" font-size="5">Routes via conduit to Inverter/Combiner</text>
            
            <text x="100" y="115" text-anchor="middle" fill="#4aa" font-size="6">Junction Box ‚Üí MC4 Connectors ‚Üí Inverter</text>
          </svg>`,
        'home-run': `
          <svg viewBox="0 0 200 120" style="width:100%;height:100%;">
            <!-- Title -->
            <text x="100" y="10" text-anchor="middle" fill="#4aa" font-size="7">HOME RUN: String to Inverter</text>
            
            <!-- Panel string representation -->
            <rect x="140" y="20" width="55" height="35" fill="#1a3a5c" stroke="#4aa" rx="2"/>
            <text x="167" y="40" text-anchor="middle" fill="#4aa" font-size="5">Panel String</text>
            
            <!-- Conduit representation -->
            <rect x="60" y="55" width="80" height="12" fill="#666" rx="6"/>
            <text x="100" y="63" text-anchor="middle" fill="#aaa" font-size="5">UV Conduit</text>
            
            <!-- Inverter/Combiner box -->
            <rect x="5" y="45" width="45" height="35" fill="#ddd" stroke="#999" rx="2"/>
            <text x="27" y="65" text-anchor="middle" fill="#666" font-size="5">Inverter/</text>
            <text x="27" y="73" text-anchor="middle" fill="#666" font-size="5">Combiner</text>
            
            <!-- Cables from string to conduit to inverter -->
            <path d="M 140 40 L 140 57 L 60 57" stroke="#a33" stroke-width="3" fill="none"/>
            <path d="M 140 50 L 130 50 L 130 63 L 60 63" stroke="#33a" stroke-width="3" fill="none"/>
            <path d="M 60 57 L 50 57" stroke="#a33" stroke-width="3" fill="none"/>
            <path d="M 60 63 L 50 63" stroke="#33a" stroke-width="3" fill="none"/>
            
            <!-- Labels -->
            <text x="145" y="95" fill="#a66" font-size="6">DC+</text>
            <text x="145" y="105" fill="#66a" font-size="6">DC-</text>
            
            <text x="100" y="90" text-anchor="middle" fill="#888" font-size="5">Protected routing via conduit</text>
            <text x="100" y="115" text-anchor="middle" fill="#4aa" font-size="6">Meets NEC safety codes</text>
          </svg>`,
        'cab-clip': `
          <svg viewBox="0 0 200 120" style="width:100%;height:100%;">
            <!-- Structure beam -->
            <rect x="20" y="50" width="160" height="15" fill="#666"/>
            <!-- CAB clips -->
            <g fill="#c33">
              <path d="M 50 50 Q 50 30 60 30 L 70 30 Q 80 30 80 50 L 80 45 Q 80 35 70 35 L 60 35 Q 50 35 50 45 Z"/>
              <path d="M 110 50 Q 110 30 120 30 L 130 30 Q 140 30 140 50 L 140 45 Q 140 35 130 35 L 120 35 Q 110 35 110 45 Z"/>
            </g>
            <!-- Cables through clips -->
            <g fill="none" stroke-width="6">
              <path d="M 20 40 L 180 40" stroke="#a33"/>
              <path d="M 20 45 L 180 45" stroke="#33a"/>
            </g>
            <!-- Labels -->
            <text x="65" y="20" text-anchor="middle" fill="#c66" font-size="7">CAB Clip</text>
            <text x="125" y="20" text-anchor="middle" fill="#c66" font-size="7">CAB Clip</text>
            <text x="100" y="90" text-anchor="middle" fill="#4aa" font-size="8">Secures cables to structure</text>
          </svg>`,
        'mc4-connector': `
          <svg viewBox="0 0 200 120" style="width:100%;height:100%;">
            <!-- Title -->
            <text x="100" y="12" text-anchor="middle" fill="#4aa" font-size="7">MC4 PANEL INTERCONNECTION</text>
            
            <!-- Two panels -->
            <rect x="10" y="25" width="70" height="35" fill="#1a3a5c" stroke="#4aa"/>
            <rect x="120" y="25" width="70" height="35" fill="#1a3a5c" stroke="#4aa"/>
            <text x="45" y="45" text-anchor="middle" fill="#4aa" font-size="5">Panel 1</text>
            <text x="155" y="45" text-anchor="middle" fill="#4aa" font-size="5">Panel 2</text>
            
            <!-- Cables from panels -->
            <path d="M 65 60 L 65 75" stroke="#a33" stroke-width="3"/>
            <path d="M 135 60 L 135 75" stroke="#33a" stroke-width="3"/>
            
            <!-- Male connector (from Panel 1) -->
            <rect x="55" y="75" width="20" height="12" fill="#222" rx="2"/>
            <rect x="75" y="78" width="8" height="6" fill="#333"/>
            <circle cx="79" cy="81" r="2" fill="#b87333"/>
            
            <!-- Female connector (from Panel 2) -->
            <rect x="125" y="75" width="20" height="12" fill="#222" rx="2"/>
            <rect x="117" y="78" width="8" height="6" fill="#333"/>
            <circle cx="121" cy="81" r="3" fill="#333" stroke="#b87333" stroke-width="1"/>
            
            <!-- Connection in middle -->
            <line x1="83" y1="81" x2="117" y2="81" stroke="#4aa" stroke-width="2" stroke-dasharray="4"/>
            <text x="100" y="78" text-anchor="middle" fill="#4aa" font-size="5">Click!</text>
            
            <!-- Labels -->
            <text x="65" y="95" text-anchor="middle" fill="#a66" font-size="5">Male +</text>
            <text x="135" y="95" text-anchor="middle" fill="#66a" font-size="5">Female -</text>
            
            <text x="100" y="110" text-anchor="middle" fill="#888" font-size="6">Plug together to connect panels in series</text>
          </svg>`,
        'junction-box': `
          <svg viewBox="0 0 200 120" style="width:100%;height:100%;">
            <!-- Title -->
            <text x="100" y="10" text-anchor="middle" fill="#4aa" font-size="7">JUNCTION BOX (Back of Panel)</text>
            
            <!-- Panel back surface -->
            <rect x="30" y="18" width="140" height="50" fill="#333" stroke="#555"/>
            <text x="100" y="35" text-anchor="middle" fill="#666" font-size="6">Panel Back</text>
            
            <!-- Junction box -->
            <rect x="60" y="38" width="80" height="30" fill="#444" stroke="#666" stroke-width="2" rx="3"/>
            <text x="100" y="52" text-anchor="middle" fill="#aaa" font-size="6">JUNCTION BOX</text>
            
            <!-- + and - terminals inside -->
            <circle cx="80" cy="58" r="5" fill="#a33" stroke="#fff"/>
            <text x="80" y="61" text-anchor="middle" fill="#fff" font-size="6">+</text>
            <circle cx="120" cy="58" r="5" fill="#33a" stroke="#fff"/>
            <text x="120" y="61" text-anchor="middle" fill="#fff" font-size="6">-</text>
            
            <!-- Pre-attached DC cables coming out -->
            <path d="M 80 63 L 80 85" stroke="#a33" stroke-width="4" fill="none"/>
            <path d="M 120 63 L 120 85" stroke="#33a" stroke-width="4" fill="none"/>
            
            <!-- MC4 connectors at cable ends -->
            <rect x="73" y="85" width="14" height="12" fill="#222" stroke="#444" rx="2"/>
            <rect x="113" y="85" width="14" height="12" fill="#222" stroke="#444" rx="2"/>
            <text x="80" y="93" text-anchor="middle" fill="#888" font-size="4">MC4</text>
            <text x="120" y="93" text-anchor="middle" fill="#888" font-size="4">MC4</text>
            
            <!-- Labels -->
            <text x="55" y="78" fill="#a66" font-size="6">DC+</text>
            <text x="135" y="78" fill="#66a" font-size="6">DC-</text>
            
            <text x="100" y="110" text-anchor="middle" fill="#4aa" font-size="6">Pre-attached cables end in MC4 connectors</text>
          </svg>`,
        'cable-tray': `
          <svg viewBox="0 0 200 120" style="width:100%;height:100%;">
            <!-- Tray structure -->
            <path d="M 10 40 L 10 80 L 190 80 L 190 40" stroke="#888" stroke-width="3" fill="none"/>
            <g stroke="#666" stroke-width="2">
              <line x1="30" y1="40" x2="30" y2="80"/>
              <line x1="60" y1="40" x2="60" y2="80"/>
              <line x1="90" y1="40" x2="90" y2="80"/>
              <line x1="120" y1="40" x2="120" y2="80"/>
              <line x1="150" y1="40" x2="150" y2="80"/>
              <line x1="170" y1="40" x2="170" y2="80"/>
            </g>
            <!-- Cables in tray -->
            <ellipse cx="45" cy="65" rx="10" ry="8" fill="#a33"/>
            <ellipse cx="75" cy="65" rx="10" ry="8" fill="#33a"/>
            <ellipse cx="105" cy="65" rx="10" ry="8" fill="#a33"/>
            <ellipse cx="135" cy="65" rx="10" ry="8" fill="#33a"/>
            <!-- Support -->
            <rect x="95" y="80" width="10" height="30" fill="#555"/>
            <text x="100" y="25" text-anchor="middle" fill="#4aa" font-size="8">Ladder-type Cable Tray</text>
          </svg>`,
        'ground-wire': `
          <svg viewBox="0 0 200 120" style="width:100%;height:100%;">
            <!-- Ground symbol -->
            <g stroke="#3a3" stroke-width="3" fill="none">
              <line x1="100" y1="10" x2="100" y2="40"/>
              <line x1="70" y1="40" x2="130" y2="40"/>
              <line x1="80" y1="50" x2="120" y2="50"/>
              <line x1="90" y1="60" x2="110" y2="60"/>
            </g>
            <!-- Ground wire -->
            <path d="M 100 60 L 100 85 Q 100 100 80 100 L 20 100" stroke="#3a3" stroke-width="4" fill="none"/>
            <!-- Ground rod -->
            <rect x="15" y="90" width="10" height="25" fill="#b87333"/>
            <!-- Equipment -->
            <rect x="150" y="70" width="40" height="40" fill="#666" stroke="#888" stroke-width="1" rx="2"/>
            <path d="M 100 85 L 150 85" stroke="#3a3" stroke-width="4" fill="none"/>
            <text x="170" y="95" text-anchor="middle" fill="#888" font-size="6">Equipment</text>
            <text x="100" y="20" text-anchor="middle" fill="#3a3" font-size="8">Earth Ground</text>
          </svg>`,
        'dc-cables': `
          <svg viewBox="0 0 200 120" style="width:100%;height:100%;">
            <!-- Cable cross-section -->
            <circle cx="60" cy="60" r="30" fill="#a33" stroke="#822" stroke-width="2"/>
            <circle cx="60" cy="60" r="15" fill="#b87333"/>
            <text x="60" y="65" text-anchor="middle" fill="#fff" font-size="8">+</text>
            <text x="60" y="105" text-anchor="middle" fill="#a66" font-size="8">DC Positive</text>
            
            <circle cx="140" cy="60" r="30" fill="#33a" stroke="#228" stroke-width="2"/>
            <circle cx="140" cy="60" r="15" fill="#b87333"/>
            <text x="140" y="65" text-anchor="middle" fill="#fff" font-size="8">‚àí</text>
            <text x="140" y="105" text-anchor="middle" fill="#66a" font-size="8">DC Negative</text>
            
            <text x="100" y="20" text-anchor="middle" fill="#4aa" font-size="8">PV Wire Cross-Section (10 AWG)</text>
          </svg>`,
        'ac-conduit': `
          <svg viewBox="0 0 200 120" style="width:100%;height:100%;">
            <!-- Conduit -->
            <rect x="20" y="40" width="160" height="40" fill="#888" rx="20"/>
            <rect x="20" y="50" width="160" height="20" fill="#666"/>
            <!-- Wires inside -->
            <circle cx="60" cy="60" r="6" fill="#a33"/>
            <circle cx="100" cy="60" r="6" fill="#33a"/>
            <circle cx="140" cy="60" r="6" fill="#3a3"/>
            <!-- Labels -->
            <text x="60" y="95" text-anchor="middle" fill="#a66" font-size="7">L1</text>
            <text x="100" y="95" text-anchor="middle" fill="#66a" font-size="7">L2</text>
            <text x="140" y="95" text-anchor="middle" fill="#6a6" font-size="7">L3</text>
            <text x="100" y="25" text-anchor="middle" fill="#4aa" font-size="8">EMT Conduit - 3-Phase 480V AC</text>
            <text x="100" y="110" text-anchor="middle" fill="#888" font-size="7">Galvanized Steel / PVC</text>
          </svg>`,
        'tracker-motor': `
          <svg viewBox="0 0 200 120" style="width:100%;height:100%;">
            <!-- Title -->
            <text x="100" y="10" text-anchor="middle" fill="#4aa" font-size="7">HOW THE TRACKER WORKS</text>
            
            <!-- Sun icon -->
            <circle cx="170" cy="25" r="12" fill="#ffcc00"/>
            <g stroke="#ffcc00" stroke-width="2">
              <line x1="170" y1="8" x2="170" y2="3"/>
              <line x1="170" y1="42" x2="170" y2="47"/>
              <line x1="153" y1="25" x2="148" y2="25"/>
              <line x1="187" y1="25" x2="192" y2="25"/>
              <line x1="158" y1="13" x2="154" y2="9"/>
              <line x1="182" y1="37" x2="186" y2="41"/>
            </g>
            
            <!-- Step 1: Sensor/Algorithm -->
            <rect x="10" y="20" width="55" height="25" fill="#335" stroke="#4aa" rx="3"/>
            <text x="37" y="30" text-anchor="middle" fill="#4aa" font-size="5">1. SENSING</text>
            <text x="37" y="40" text-anchor="middle" fill="#888" font-size="4">GPS + Algorithms</text>
            
            <!-- Arrow 1 -->
            <path d="M 65 32 L 78 32" stroke="#4aa" stroke-width="2"/>
            <polygon points="78,29 85,32 78,35" fill="#4aa"/>
            
            <!-- Step 2: Motor -->
            <ellipse cx="105" cy="32" rx="18" ry="12" fill="#555" stroke="#777"/>
            <text x="105" y="35" text-anchor="middle" fill="#aaa" font-size="5">2. MOTOR</text>
            
            <!-- Arrow 2 -->
            <path d="M 123 32 L 136 32" stroke="#4aa" stroke-width="2"/>
            <polygon points="136,29 143,32 136,35" fill="#4aa"/>
            
            <!-- Step 3: Rotation indicator -->
            <path d="M 155 20 A 15 15 0 0 1 155 44" stroke="#0f8" stroke-width="2" fill="none"/>
            <polygon points="155,44 152,38 158,38" fill="#0f8"/>
            <text x="155" y="35" text-anchor="middle" fill="#0f8" font-size="5">¬±60¬∞</text>
            
            <!-- Panel representation showing tilt -->
            <rect x="25" y="60" width="70" height="8" fill="#1a3a5c" stroke="#4aa" transform="rotate(-15 60 64)"/>
            <rect x="25" y="75" width="70" height="8" fill="#1a3a5c" stroke="#4aa"/>
            <rect x="25" y="90" width="70" height="8" fill="#1a3a5c" stroke="#4aa" transform="rotate(15 60 94)"/>
            
            <!-- Labels for panel positions -->
            <text x="110" y="62" fill="#888" font-size="5">Morning (East)</text>
            <text x="110" y="79" fill="#0f8" font-size="5">Noon (Flat)</text>
            <text x="110" y="96" fill="#888" font-size="5">Evening (West)</text>
            
            <text x="100" y="112" text-anchor="middle" fill="#4aa" font-size="6">Panels rotate to stay perpendicular to sunlight</text>
          </svg>`,
        'substation': `
          <svg viewBox="0 0 200 120" style="width:100%;height:100%;">
            <!-- Building -->
            <rect x="20" y="50" width="80" height="60" fill="#ddd" stroke="#999" stroke-width="2"/>
            <rect x="50" y="80" width="20" height="30" fill="#666"/>
            <!-- Transformer -->
            <rect x="120" y="40" width="60" height="70" fill="#888" stroke="#666" stroke-width="2" rx="3"/>
            <ellipse cx="150" cy="55" rx="20" ry="10" fill="#777"/>
            <rect x="140" y="75" width="20" height="25" fill="#666"/>
            <!-- Power lines -->
            <line x1="100" y1="70" x2="120" y2="70" stroke="#333" stroke-width="3"/>
            <line x1="150" y1="20" x2="150" y2="40" stroke="#333" stroke-width="3"/>
            <line x1="130" y1="20" x2="170" y2="20" stroke="#333" stroke-width="2"/>
            <!-- Labels -->
            <text x="60" y="45" text-anchor="middle" fill="#666" font-size="7">Control Room</text>
            <text x="150" y="115" text-anchor="middle" fill="#666" font-size="7">Transformer</text>
            <text x="150" y="15" text-anchor="middle" fill="#4aa" font-size="7">To Grid</text>
          </svg>`,
        'free-space': `
          <svg viewBox="0 0 200 120" style="width:100%;height:100%;">
            <!-- Row 1 -->
            <rect x="10" y="10" width="180" height="15" fill="#1a3a5c" stroke="#4aa" stroke-width="1"/>
            <!-- Row 2 -->
            <rect x="10" y="95" width="180" height="15" fill="#1a3a5c" stroke="#4aa" stroke-width="1"/>
            <!-- Spacing indicator -->
            <line x1="100" y1="25" x2="100" y2="95" stroke="#4aa" stroke-width="1" stroke-dasharray="5"/>
            <path d="M 90 30 L 100 25 L 110 30" stroke="#4aa" stroke-width="2" fill="none"/>
            <path d="M 90 90 L 100 95 L 110 90" stroke="#4aa" stroke-width="2" fill="none"/>
            <text x="115" y="60" fill="#4aa" font-size="10">18-25 ft</text>
            <text x="100" y="75" text-anchor="middle" fill="#888" font-size="7">Row Pitch</text>
            <!-- Ground -->
            <rect x="0" y="50" width="200" height="3" fill="#5a8a50" opacity="0.5"/>
          </svg>`,
        'did-you-know': `
          <svg viewBox="0 0 200 120" style="width:100%;height:100%;">
            <!-- Sun -->
            <circle cx="100" cy="35" r="25" fill="#fd0"/>
            <g stroke="#fd0" stroke-width="3">
              <line x1="100" y1="0" x2="100" y2="5"/>
              <line x1="100" y1="65" x2="100" y2="70"/>
              <line x1="65" y1="35" x2="60" y2="35"/>
              <line x1="135" y1="35" x2="140" y2="35"/>
              <line x1="75" y1="10" x2="72" y2="7"/>
              <line x1="125" y1="10" x2="128" y2="7"/>
              <line x1="75" y1="60" x2="72" y2="63"/>
              <line x1="125" y1="60" x2="128" y2="63"/>
            </g>
            <!-- Solar panel -->
            <rect x="50" y="80" width="100" height="30" fill="#1a3a5c" stroke="#4aa" stroke-width="2" transform="rotate(-15 100 95)"/>
            <!-- Arrow from sun -->
            <path d="M 100 65 L 100 78" stroke="#fd0" stroke-width="2" marker-end="url(#arrow)"/>
            <text x="100" y="115" text-anchor="middle" fill="#4aa" font-size="8">Clean Energy from Sunlight</text>
          </svg>`
      };
      return diagrams[key] || `<div style="color:#4aa; font-size:0.9em; text-align:center; padding:40px;">Component Diagram</div>`;
    }
    
    // Generate gallery images for each component
    function getComponentGallery(key) {
      const galleries = {
        'solar-panel': `
          <div style="background:#1a3a45; height:100px; border-radius:3px; display:flex; align-items:center; justify-content:center; flex-direction:column; padding:10px;">
            <svg viewBox="0 0 80 50" style="width:70px;height:45px;">
              <rect x="5" y="5" width="70" height="40" fill="#1a3a5c" stroke="#4aa" stroke-width="1"/>
              <g stroke="#2a4a6a" stroke-width="0.5"><line x1="5" y1="18" x2="75" y2="18"/><line x1="5" y1="32" x2="75" y2="32"/><line x1="28" y1="5" x2="28" y2="45"/><line x1="52" y1="5" x2="52" y2="45"/></g>
            </svg>
            <span style="color:#4aa; font-size:0.7em; margin-top:5px;">Front View</span>
          </div>
          <div style="background:#1a3a45; height:100px; border-radius:3px; display:flex; align-items:center; justify-content:center; flex-direction:column; padding:10px;">
            <svg viewBox="0 0 80 50" style="width:70px;height:45px;">
              <rect x="5" y="5" width="70" height="40" fill="#333" stroke="#555" stroke-width="1"/>
              <rect x="30" y="15" width="20" height="15" fill="#444" stroke="#666"/>
              <line x1="35" y1="30" x2="35" y2="45" stroke="#a33" stroke-width="2"/>
              <line x1="45" y1="30" x2="45" y2="45" stroke="#33a" stroke-width="2"/>
            </svg>
            <span style="color:#4aa; font-size:0.7em; margin-top:5px;">Back (Junction Box)</span>
          </div>`,
        'string-inverter': `
          <div style="background:#1a3a45; height:100px; border-radius:3px; display:flex; align-items:center; justify-content:center; flex-direction:column; padding:10px;">
            <svg viewBox="0 0 80 50" style="width:70px;height:45px;">
              <rect x="10" y="5" width="60" height="40" fill="#444" stroke="#666" stroke-width="1" rx="2"/>
              <rect x="15" y="10" width="25" height="12" fill="#1a3a45" stroke="#4aa"/>
              <circle cx="55" cy="15" r="3" fill="#0f0"/>
            </svg>
            <span style="color:#4aa; font-size:0.7em; margin-top:5px;">Front Panel</span>
          </div>
          <div style="background:#1a3a45; height:100px; border-radius:3px; display:flex; align-items:center; justify-content:center; flex-direction:column; padding:10px;">
            <svg viewBox="0 0 80 50" style="width:70px;height:45px;">
              <rect x="10" y="5" width="60" height="40" fill="#333" stroke="#555" stroke-width="1" rx="2"/>
              <rect x="20" y="35" width="10" height="8" fill="#a33"/>
              <rect x="35" y="35" width="10" height="8" fill="#33a"/>
              <rect x="50" y="35" width="10" height="8" fill="#3a3"/>
            </svg>
            <span style="color:#4aa; font-size:0.7em; margin-top:5px;">Wiring Connections</span>
          </div>`
      };
      return galleries[key] || `
        <div style="background:#1a3a45; height:100px; border-radius:3px; display:flex; align-items:center; justify-content:center;">
          <span style="color:#4aa; font-size:0.8em;">Detail View 1</span>
        </div>
        <div style="background:#1a3a45; height:100px; border-radius:3px; display:flex; align-items:center; justify-content:center;">
          <span style="color:#4aa; font-size:0.8em;">Detail View 2</span>
        </div>`;
    }
    
    window.closeDetailPanel = function() {
      const panel = document.getElementById('detail-panel');
      panel.style.transform = 'translateX(100%)';
      setTimeout(() => {
        panel.style.display = 'none';
        document.getElementById('detail-overlay').style.display = 'none';
      }, 300);
    };
    
    // Keep old function name for compatibility
    window.closeInfoBox = window.closeDetailPanel;
    
    // Toggle left education panel visibility
    let leftPanelVisible = true;
    window.toggleLeftPanel = function() {
      leftPanelVisible = !leftPanelVisible;
      const panel = document.getElementById('left-panel');
      const showBtn = document.getElementById('panelShowBtn');
      const hideIcon = document.getElementById('panelHideIcon');
      
      if (leftPanelVisible) {
        panel.classList.remove('hidden');
        showBtn.style.display = 'none';
        hideIcon.textContent = '‚óÄ';
      } else {
        panel.classList.add('hidden');
        showBtn.style.display = 'flex';
        hideIcon.textContent = '‚ñ∂';
      }
    };
    
    // Toggle markers visibility
    let markersVisible = true;
    window.toggleMarkers = function() {
      markersVisible = !markersVisible;
      
      // Toggle HTML labels
      labelElements.forEach(({ label }) => {
        label.style.display = markersVisible ? 'flex' : 'none';
      });
      
      const btn = document.getElementById('toggle-markers');
      btn.innerHTML = markersVisible ? 'Hide Labels' : 'Show Labels';
      btn.style.background = markersVisible ? 'rgba(15,35,45,0.95)' : 'rgba(60,60,60,0.95)';
    };
    
    // Animate markers (subtle effect)
    function animateMarkers() {
      if (!markers || !markers.length) return;
      // Update label positions to follow 3D markers
      updateLabelPositions();
    }

    function animate() {
      requestAnimationFrame(animate);
      animateMarkers();
      animateHighlights();
      updateDayCycle();
      updateElectricityFlow();
      renderer.render(scene, camera);
    }
    
    // Day/Night cycle and sun tracking
    function updateDayCycle() {
      if (!isDayCycleActive) return;
      
      // Advance sun angle (complete cycle in ~10 seconds - FASTER)
      sunAngle += 0.002;
      if (sunAngle > 1) sunAngle = 0;
      
      // Calculate sun position (arc across sky)
      const sunRadius = 350;
      const sunX = Math.cos(sunAngle * Math.PI) * sunRadius;
      const sunY = Math.sin(sunAngle * Math.PI) * 250 + 50;
      const sunZ = 80;
      
      if (sunMesh) {
        sunMesh.position.set(sunX, Math.max(30, sunY), sunZ);
        // Rotate sun rays for visual effect
        sunMesh.rotation.z += 0.005;
      }
      if (sunLight) {
        sunLight.position.set(sunX, Math.max(50, sunY), sunZ);
        
        // Adjust light color and intensity based on time of day - STRONGER
        const noon = 0.5;
        const timeFromNoon = Math.abs(sunAngle - noon);
        
        if (sunAngle < 0.1 || sunAngle > 0.9) {
          // Dawn/dusk - orange light
          sunLight.color.setHex(0xff6622);
          sunLight.intensity = 0.6;
          if (sunMesh) sunMesh.material.color.setHex(0xff4400);
        } else if (sunAngle < 0.2 || sunAngle > 0.8) {
          // Early morning/late afternoon
          sunLight.color.setHex(0xffbb44);
          sunLight.intensity = 1.2;
          if (sunMesh) sunMesh.material.color.setHex(0xff8800);
        } else {
          // Midday - bright white/yellow - VERY BRIGHT
          sunLight.color.setHex(0xffffee);
          sunLight.intensity = 1.8;
          if (sunMesh) sunMesh.material.color.setHex(0xffff66);
        }
      }
      
      // Rotate trackers to follow sun - MORE DRAMATIC
      const trackerAngle = (sunAngle - 0.5) * Math.PI * 0.9; // ¬±80 degrees
      trackerRows.forEach(tracker => {
        if (tracker.userData.panelTable) {
          tracker.userData.panelTable.rotation.x = trackerAngle;
        }
      });
    }
    
    // Electricity flow particle system
    function createElectricityParticles() {
      // Clear existing particles
      electricityParticles.forEach(p => {
        scene.remove(p.mesh);
        if (p.glow) scene.remove(p.glow);
      });
      electricityParticles = [];
      
      // DC particle material (cyan/blue - from panels) - BRIGHT
      const dcMat = new THREE.MeshBasicMaterial({ 
        color: 0x00ffff, 
        transparent: true, 
        opacity: 1.0
      });
      
      // Glow material
      const dcGlowMat = new THREE.MeshBasicMaterial({ 
        color: 0x00ffff, 
        transparent: true, 
        opacity: 0.5
      });
      
      const particleGeo = new THREE.SphereGeometry(1.0, 16, 16); // Bigger particles
      const glowGeo = new THREE.SphereGeometry(2.5, 16, 16);
      
      // Create particles for each tracker row OR use default positions
      const rowPositions = trackerRows.length > 0 
        ? trackerRows.map(t => ({ x: t.position.x, z: t.position.z }))
        : [
            { x: 140, z: -117 }, { x: 140, z: -99 }, { x: 140, z: -81 }, { x: 140, z: -63 }, { x: 140, z: -45 }, { x: 140, z: -27 },
            { x: 140, z: 27 }, { x: 140, z: 45 }, { x: 140, z: 63 }, { x: 140, z: 81 }, { x: 140, z: 99 }, { x: 140, z: 117 },
            { x: -140, z: -117 }, { x: -140, z: -99 }, { x: -140, z: -81 }, { x: -140, z: -63 }, { x: -140, z: -45 }, { x: -140, z: -27 },
            { x: -140, z: 27 }, { x: -140, z: 45 }, { x: -140, z: 63 }, { x: -140, z: 81 }, { x: -140, z: 99 }, { x: -140, z: 117 }
          ];
      
      rowPositions.forEach((pos, rowIdx) => {
        const isLeftSide = pos.x < 0;
        const z = pos.z;
        
        // DC flows from panels toward the end of the row (toward inverters)
        let startX, endX, baseSpeed;
        if (isLeftSide) {
          // Left side: flow from right to left (toward -X)
          startX = pos.x + 50;
          endX = pos.x - 55;
          baseSpeed = -1; // Negative direction
        } else {
          // Right side: flow from left to right (toward +X)
          startX = pos.x - 50;
          endX = pos.x + 55;
          baseSpeed = 1; // Positive direction
        }
        
        // Create multiple particles per row
        for (let i = 0; i < 8; i++) {
          const particle = new THREE.Mesh(particleGeo, dcMat.clone());
          const glow = new THREE.Mesh(glowGeo, dcGlowMat.clone());
          
          const initPos = isLeftSide 
            ? startX - (i / 8) * 40 
            : startX + (i / 8) * 40;
          particle.position.set(initPos, 10, z);
          glow.position.copy(particle.position);
          
          scene.add(particle);
          scene.add(glow);
          
          electricityParticles.push({
            mesh: particle,
            glow: glow,
            startX: startX,
            endX: endX,
            speed: baseSpeed * (0.5 + Math.random() * 0.3),
            phase: Math.random() * Math.PI * 2,
            row: rowIdx,
            baseZ: z,
            type: 'dc'
          });
        }
      });
      
      // Create AC particles (orange/yellow - to grid) - BRIGHT
      const acMat = new THREE.MeshBasicMaterial({ 
        color: 0xffaa00, 
        transparent: true, 
        opacity: 1.0
      });
      const acGlowMat = new THREE.MeshBasicMaterial({ 
        color: 0xff6600, 
        transparent: true, 
        opacity: 0.5
      });
      
      // Particles from RIGHT side inverters toward substation (center)
      for (let i = 0; i < 18; i++) {
        const particle = new THREE.Mesh(particleGeo, acMat.clone());
        const glow = new THREE.Mesh(glowGeo, acGlowMat.clone());
        
        const z = -120 + (i / 18) * 240;
        particle.position.set(165 + Math.random() * 20, 8, z);
        glow.position.copy(particle.position);
        
        scene.add(particle);
        scene.add(glow);
        
        electricityParticles.push({
          mesh: particle,
          glow: glow,
          startX: 175,
          endX: 10,  // Moving toward center/substation
          speed: -(0.7 + Math.random() * 0.4), // Negative to go left
          phase: Math.random() * Math.PI * 2,
          baseZ: z,
          type: 'ac'
        });
      }
      
      // Particles from LEFT side inverters toward substation (center)
      for (let i = 0; i < 18; i++) {
        const particle = new THREE.Mesh(particleGeo, acMat.clone());
        const glow = new THREE.Mesh(glowGeo, acGlowMat.clone());
        
        const z = -120 + (i / 18) * 240;
        particle.position.set(-165 - Math.random() * 20, 8, z);
        glow.position.copy(particle.position);
        
        scene.add(particle);
        scene.add(glow);
        
        electricityParticles.push({
          mesh: particle,
          glow: glow,
          startX: -175,
          endX: -10,  // Moving toward center/substation
          speed: 0.7 + Math.random() * 0.4, // Positive to go right
          phase: Math.random() * Math.PI * 2,
          baseZ: z,
          type: 'ac'
        });
      }
      
      console.log('Created', electricityParticles.length, 'electricity particles');
    }
    
    function updateElectricityFlow() {
      if (!isElectricityFlowActive) return;
      
      const time = Date.now() * 0.001;
      
      electricityParticles.forEach(p => {
        // Move particle along path
        p.mesh.position.x += p.speed;
        
        // Add some vertical and horizontal wobble
        const baseY = p.type === 'dc' ? 10 : 8;
        p.mesh.position.y = baseY + Math.sin(time * 4 + p.phase) * 0.5;
        p.mesh.position.z = p.baseZ + Math.sin(time * 2 + p.phase * 2) * 0.4;
        
        // Update glow position
        if (p.glow) {
          p.glow.position.copy(p.mesh.position);
        }
        
        // Reset when reaching end (handle both directions)
        if (p.speed > 0 && p.mesh.position.x > p.endX) {
          p.mesh.position.x = p.startX;
        } else if (p.speed < 0 && p.mesh.position.x < p.endX) {
          p.mesh.position.x = p.startX;
        }
        
        // Pulse opacity and scale
        const pulse = Math.sin(time * 6 + p.phase);
        p.mesh.material.opacity = 0.8 + pulse * 0.2;
        if (p.glow) {
          p.glow.material.opacity = 0.3 + pulse * 0.2;
        }
        
        // Scale based on position (energy accumulation effect)
        const progress = Math.abs(p.mesh.position.x - p.startX) / Math.abs(p.endX - p.startX);
        const scale = 1.0 + progress * 0.5 + pulse * 0.15;
        p.mesh.scale.setScalar(scale);
        if (p.glow) {
          p.glow.scale.setScalar(scale * 1.5);
        }
      });
    }
    
    function toggleDayCycle() {
      isDayCycleActive = !isDayCycleActive;
      const btn = document.getElementById('dayCycleBtn');
      if (isDayCycleActive) {
        btn.classList.add('active');
        btn.innerHTML = '‚òÄÔ∏è Sun Tracking: ON';
      } else {
        btn.classList.remove('active');
        btn.innerHTML = 'üåÖ Sun Tracking';
        // Reset to default position
        sunAngle = 0.25;
        if (sunMesh) sunMesh.position.set(100, 200, 80);
        if (sunLight) {
          sunLight.position.set(100, 200, 80);
          sunLight.color.setHex(0xffffff);
          sunLight.intensity = 1.0;
        }
        trackerRows.forEach(tracker => {
          if (tracker.userData.panelTable) {
            tracker.userData.panelTable.rotation.x = tracker.userData.baseTilt || 0.15;
          }
        });
      }
    }
    
    function toggleElectricityFlow() {
      isElectricityFlowActive = !isElectricityFlowActive;
      const btn = document.getElementById('electricFlowBtn');
      if (isElectricityFlowActive) {
        btn.classList.add('active');
        btn.innerHTML = '‚ö° Power Flow: ON';
        createElectricityParticles();
      } else {
        btn.classList.remove('active');
        btn.innerHTML = '‚ö° Power Flow';
        // Remove particles and glows
        electricityParticles.forEach(p => {
          scene.remove(p.mesh);
          if (p.glow) scene.remove(p.glow);
        });
        electricityParticles = [];
      }
    }
    
    // Tooltip control functions
    function closeSunTooltip() {
      document.getElementById('sunTooltip').classList.remove('show');
    }
    
    function closePowerTooltip() {
      document.getElementById('powerTooltip').classList.remove('show');
    }
    
    function startSunTracking() {
      closeSunTooltip();
      if (!isDayCycleActive) {
        toggleDayCycle();
      }
    }
    
    function startPowerFlow() {
      closePowerTooltip();
      if (!isElectricityFlowActive) {
        toggleElectricityFlow();
      }
    }
    
    // Close tooltips when clicking elsewhere
    document.addEventListener('click', (e) => {
      if (!e.target.closest('#dayCycleBtn') && !e.target.closest('#sunTooltip')) {
        closeSunTooltip();
      }
      if (!e.target.closest('#electricFlowBtn') && !e.target.closest('#powerTooltip')) {
        closePowerTooltip();
      }
    });

    function setupListeners() {
      document.querySelectorAll('.step').forEach(s => s.addEventListener('click', () => navigate(s.dataset.step)));
      
      document.getElementById('prev').addEventListener('click', () => {
        const steps = ['module', 'string', 'tracker', 'combiner', 'cabling', 'inverter'];
        const i = steps.indexOf(currentStep);
        if (i > 0) navigate(steps[i - 1]);
      });
      
      document.getElementById('next').addEventListener('click', () => {
        const steps = ['module', 'string', 'tracker', 'combiner', 'cabling', 'inverter'];
        const i = steps.indexOf(currentStep);
        if (i < steps.length - 1) navigate(steps[i + 1]);
      });
      
      document.getElementById('topview').addEventListener('click', () => {
        isTopView = !isTopView;
        const btn = document.getElementById('topview');
        if (isTopView) {
          btn.classList.add('active');
          btn.textContent = 'Exit Top View';
          animateCameraTo(topViewCam.x, topViewCam.y, topViewCam.z, 0, 0, 0);
          // Hide highlights in top view
          if (highlightGroup) highlightGroup.children.forEach(g => g.visible = false);
        } else {
          btn.classList.remove('active');
          btn.textContent = 'Top View';
          animateCameraTo(defaultCam.x, defaultCam.y, defaultCam.z, 0, 10, 0);
          // Restore highlight for current step
          highlightComponent(currentStep);
        }
      });
      
      document.getElementById('reset').addEventListener('click', () => {
        isTopView = false;
        document.getElementById('topview').classList.remove('active');
        document.getElementById('topview').textContent = 'Top View';
        targetX = 0; targetY = 10; targetZ = 0;
        animateCameraTo(defaultCam.x, defaultCam.y, defaultCam.z, 0, 10, 0);
        // Restore highlight for current step
        highlightComponent(currentStep);
      });
      
      // Day cycle / sun tracking button - show tooltip first
      document.getElementById('dayCycleBtn').addEventListener('click', () => {
        if (isDayCycleActive) {
          toggleDayCycle(); // If active, just toggle off
        } else {
          // Show tooltip
          document.getElementById('sunTooltip').classList.add('show');
          document.getElementById('powerTooltip').classList.remove('show');
        }
      });
      
      // Electricity flow button - show tooltip first
      document.getElementById('electricFlowBtn').addEventListener('click', () => {
        if (isElectricityFlowActive) {
          toggleElectricityFlow(); // If active, just toggle off
        } else {
          // Show tooltip
          document.getElementById('powerTooltip').classList.add('show');
          document.getElementById('sunTooltip').classList.remove('show');
        }
      });
      
      // FREE CAMERA CONTROLS - SHARP & RESPONSIVE
      let isDragging = false;
      let isRightDrag = false;
      let lastX = 0, lastY = 0;
      
      renderer.domElement.addEventListener('mousedown', e => {
        isDragging = true;
        isRightDrag = e.button === 2;
        lastX = e.clientX;
        lastY = e.clientY;
      });
      
      renderer.domElement.addEventListener('contextmenu', e => e.preventDefault());
      
      renderer.domElement.addEventListener('mousemove', e => {
        if (!isDragging) return;
        
        const dx = e.clientX - lastX;
        const dy = e.clientY - lastY;
        lastX = e.clientX;
        lastY = e.clientY;
        
        if (isRightDrag) {
          // PAN - move the target point
          const panSpeed = 0.5;
          const right = new THREE.Vector3();
          const up = new THREE.Vector3(0, 1, 0);
          camera.getWorldDirection(right);
          right.crossVectors(up, right).normalize();
          
          targetX -= right.x * dx * panSpeed;
          targetZ -= right.z * dx * panSpeed;
          targetY += dy * panSpeed * 0.5;
          targetY = Math.max(0, Math.min(50, targetY));
          
          camera.position.x -= right.x * dx * panSpeed;
          camera.position.z -= right.z * dx * panSpeed;
          camera.position.y += dy * panSpeed * 0.5;
          camera.position.y = Math.max(0.3, camera.position.y);
          
          camera.lookAt(targetX, targetY, targetZ);
        } else {
          // ORBIT - rotate around target
          const orbitSpeed = 0.01;
          
          const offset = new THREE.Vector3(
            camera.position.x - targetX,
            camera.position.y - targetY,
            camera.position.z - targetZ
          );
          const radius = offset.length();
          let theta = Math.atan2(offset.x, offset.z);
          let phi = Math.acos(Math.max(-1, Math.min(1, offset.y / radius)));
          
          theta -= dx * orbitSpeed;
          phi -= dy * orbitSpeed;
          phi = Math.max(0.05, Math.min(Math.PI * 0.85, phi));
          
          let newY = targetY + radius * Math.cos(phi);
          if (newY < 0.3) newY = 0.3;
          
          camera.position.x = targetX + radius * Math.sin(phi) * Math.sin(theta);
          camera.position.y = newY;
          camera.position.z = targetZ + radius * Math.sin(phi) * Math.cos(theta);
          
          camera.lookAt(targetX, targetY, targetZ);
        }
      });
      
      renderer.domElement.addEventListener('mouseup', () => { isDragging = false; isRightDrag = false; });
      renderer.domElement.addEventListener('mouseleave', () => { isDragging = false; isRightDrag = false; });
      
      // ZOOM - direct scroll zoom
      renderer.domElement.addEventListener('wheel', e => {
        e.preventDefault();
        
        const zoomSpeed = 0.12;
        const dir = e.deltaY > 0 ? 1 : -1;
        
        const offset = new THREE.Vector3(
          camera.position.x - targetX,
          camera.position.y - targetY,
          camera.position.z - targetZ
        );
        const currentDist = offset.length();
        const newDist = Math.max(0.5, Math.min(600, currentDist * (1 + dir * zoomSpeed)));
        
        offset.normalize().multiplyScalar(newDist);
        let newY = targetY + offset.y;
        if (newY < 0.3) newY = 0.3;
        
        camera.position.set(targetX + offset.x, newY, targetZ + offset.z);
        camera.lookAt(targetX, targetY, targetZ);
      }, { passive: false });
      
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    }

    function navigate(step) {
      if (isTopView) {
        isTopView = false;
        document.getElementById('topview').classList.remove('active');
        document.getElementById('topview').textContent = 'Top View';
      }
      
      // Show left panel if hidden
      if (!leftPanelVisible) {
        leftPanelVisible = true;
        document.getElementById('left-panel').classList.remove('hidden');
        document.getElementById('panelShowBtn').style.display = 'none';
        document.getElementById('panelHideIcon').textContent = '‚óÄ';
      }
      
      document.querySelectorAll('.step').forEach(s => s.classList.remove('active'));
      document.querySelector(`[data-step="${step}"]`).classList.add('active');
      currentStep = step;
      updateContent();
      
      // Hide demo objects when navigating (only show via close-up buttons)
      if (demoTrackerGroup) {
        demoTrackerGroup.visible = false;
      }
      if (demoCombinerGroup) {
        demoCombinerGroup.visible = false;
      }
      
      // Show junction boxes only on String step and only for that specific row
      const stringRowZ = -45; // The row shown in String step
      junctionBoxes.forEach(item => {
        if (step === 'string' && Math.abs(item.rowZ - stringRowZ) < 1) {
          item.mesh.visible = true;
        } else {
          item.mesh.visible = false;
        }
      });
      
      // Show red cables only on String step and only for that specific row
      redCables.forEach(item => {
        if (step === 'string' && Math.abs(item.rowZ - stringRowZ) < 1) {
          item.mesh.visible = true;
        } else {
          item.mesh.visible = false;
        }
      });
      
      // Highlight the component for this step
      highlightComponent(step);
      
      const data = contentData[step];
      const cam = data.cam;
      const look = data.lookAt;
      targetX = look.x; targetY = look.y; targetZ = look.z;
      animateCameraTo(cam.x, cam.y, cam.z, look.x, look.y, look.z);
    }

    function updateContent() {
      const data = contentData[currentStep];
      document.getElementById('title').textContent = data.title;
      document.getElementById('subtitle').textContent = data.subtitle;
      document.getElementById('content').innerHTML = data.content;
      document.getElementById('stats').innerHTML = data.stats;
      
      // Attach event listener for tracker close-up button if present
      const trackerBtn = document.getElementById('viewTrackerBtn');
      if (trackerBtn) {
        trackerBtn.addEventListener('click', () => {
          zoomToTrackerDemo();
        });
      }
      
      // Attach event listener for combiner close-up button if present
      const combinerBtn = document.getElementById('viewCombinerBtn');
      if (combinerBtn) {
        combinerBtn.addEventListener('click', () => {
          zoomToCombinerDemo();
        });
      }
      
      // Attach event listener for cables view button if present
      const cablesBtn = document.getElementById('viewCablesBtn');
      if (cablesBtn) {
        cablesBtn.addEventListener('click', () => {
          zoomToCablesView();
        });
      }
    }
    
    // Demo tracker position
    const demoTrackerPos = { x: 0, y: 5, z: 50 };
    let isViewingTrackerDemo = false;
    
    // Demo combiner position
    const demoCombinerPos = { x: 0, y: 2.5, z: 80 };
    let isViewingCombinerDemo = false;
    
    function zoomToTrackerDemo() {
      isViewingTrackerDemo = true;
      
      // Show the demo tracker - add to scene if not already
      if (demoTrackerGroup) {
        if (!demoTrackerGroup.parent) scene.add(demoTrackerGroup);
        demoTrackerGroup.visible = true;
      }
      
      // Hide step highlights when viewing demo
      if (highlightGroup) highlightGroup.children.forEach(g => g.visible = false);
      
      // Animate camera to view both board and bearings from front
      animateCameraTo(
        demoTrackerPos.x - 4, demoTrackerPos.y + 5, demoTrackerPos.z + 22,
        demoTrackerPos.x - 3, demoTrackerPos.y + 2, demoTrackerPos.z + 3
      );
      
      // Update the stats area with return button
      document.getElementById('stats').innerHTML = `
        <div class="stat-card" style="background: linear-gradient(135deg, #ff6600, #ff8833);">
          <div class="stat-value" style="font-size: 14px;">üîç TRACKER CLOSE-UP VIEW</div>
          <div class="stat-label">Viewing demo tracker with Nextracker & Array styles</div>
        </div>
        <button id="returnFromDemo" style="margin-top: 10px; background: #0a3a4a; color: #4aa; border: 2px solid #4aa; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-weight: bold;">
          ‚Üê RETURN TO LESSON
        </button>
      `;
      
      // Add return button listener
      document.getElementById('returnFromDemo').addEventListener('click', () => {
        isViewingTrackerDemo = false;
        if (demoTrackerGroup) {
          demoTrackerGroup.visible = false;
          if (demoTrackerGroup.parent) scene.remove(demoTrackerGroup); // Remove from scene
        }
        navigate('tracker');
      });
    }
    
    function zoomToCombinerDemo() {
      isViewingCombinerDemo = true;
      
      // Show the demo combiner - add to scene if not already
      if (demoCombinerGroup) {
        if (!demoCombinerGroup.parent) scene.add(demoCombinerGroup);
        demoCombinerGroup.visible = true;
      }
      
      // Hide step highlights when viewing demo
      if (highlightGroup) highlightGroup.children.forEach(g => g.visible = false);
      
      // Animate camera to view combiner on left and board on right
      animateCameraTo(
        demoCombinerPos.x + 1, demoCombinerPos.y + 4, demoCombinerPos.z + 18,
        demoCombinerPos.x + 1, demoCombinerPos.y + 2, demoCombinerPos.z + 2
      );
      
      // Update the stats area with return button
      document.getElementById('stats').innerHTML = `
        <div class="stat-card" style="background: linear-gradient(135deg, #00aa66, #00cc88);">
          <div class="stat-value" style="font-size: 14px;">üîç COMBINER BOX - DOOR OPEN</div>
          <div class="stat-label">View internal components: String Inputs, Fuses, SPD, Bus Bars</div>
        </div>
        <button id="returnFromCombiner" style="margin-top: 10px; background: #0a3a4a; color: #4aa; border: 2px solid #4aa; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-weight: bold;">
          ‚Üê RETURN TO LESSON
        </button>
      `;
      
      // Add return button listener
      document.getElementById('returnFromCombiner').addEventListener('click', () => {
        isViewingCombinerDemo = false;
        if (demoCombinerGroup) {
          demoCombinerGroup.visible = false;
          if (demoCombinerGroup.parent) scene.remove(demoCombinerGroup); // Remove from scene
        }
        navigate('combiner');
      });
    }
    
    let isViewingCablesDemo = false;
    
    function zoomToCablesView() {
      isViewingCablesDemo = true;
      
      // Make sure cables are visible for this row
      const stringRowZ = -45;
      junctionBoxes.forEach(item => {
        if (Math.abs(item.rowZ - stringRowZ) < 1) {
          item.mesh.visible = true;
        }
      });
      redCables.forEach(item => {
        if (Math.abs(item.rowZ - stringRowZ) < 1) {
          item.mesh.visible = true;
        }
      });
      
      // Hide step highlights when viewing cables
      if (highlightGroup) highlightGroup.children.forEach(g => g.visible = false);
      
      // Animate camera to view DC cables (low angle from behind, seeing cables on torque tube)
      animateCameraTo(
        160, 6, -52,   // Camera position - behind and to the side, a bit higher
        120, 5.5, -45  // Look at - across the row seeing the cables
      );
      
      // Update the stats area with return button
      document.getElementById('stats').innerHTML = `
        <div class="stat-card" style="background: linear-gradient(135deg, #cc3333, #ff5555);">
          <div class="stat-value" style="font-size: 14px;">üîå DC CABLES - BACK OF PANEL</div>
          <div class="stat-label">View: Junction boxes (yellow), DC+ cables (red), DC- cables (black)</div>
        </div>
        <button id="returnFromCables" style="margin-top: 10px; background: #0a3a4a; color: #4aa; border: 2px solid #4aa; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-weight: bold;">
          ‚Üê RETURN TO LESSON
        </button>
      `;
      
      // Add return button listener
      document.getElementById('returnFromCables').addEventListener('click', () => {
        isViewingCablesDemo = false;
        navigate('string');
      });
    }

    function animateCameraTo(tx, ty, tz, lookX, lookY, lookZ) {
      // Ensure target Y is above ground but allow close views
      ty = Math.max(0.3, ty);
      
      const start = { 
        x: camera.position.x, y: camera.position.y, z: camera.position.z,
        lx: targetX, ly: targetY, lz: targetZ
      };
      const duration = 1200, startTime = Date.now();
      
      function update() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        const eased = 1 - Math.pow(1 - progress, 3);
        
        camera.position.x = start.x + (tx - start.x) * eased;
        camera.position.y = Math.max(0.3, start.y + (ty - start.y) * eased);
        camera.position.z = start.z + (tz - start.z) * eased;
        
        targetX = start.lx + (lookX - start.lx) * eased;
        targetY = start.ly + (lookY - start.ly) * eased;
        targetZ = start.lz + (lookZ - start.lz) * eased;
        
        camera.lookAt(targetX, targetY, targetZ);
        
        if (progress < 1) requestAnimationFrame(update);
      }
      update();
    }

    // ===== QUIZ SYSTEM =====
    const quizQuestions = [
      {
        question: "What is the basic building block of a solar farm?",
        options: [
          "String Inverter",
          "Solar Panel Module",
          "Combiner Box",
          "Torque Tube"
        ],
        correct: 1,
        explanation: "The solar panel module (also called a photovoltaic module) is the basic building block. Multiple modules connect together to form strings and arrays."
      },
      {
        question: "What type of solar cells are typically used in utility-scale solar farms?",
        options: [
          "Thin-film cells",
          "Organic cells",
          "Monocrystalline silicon cells",
          "Dye-sensitized cells"
        ],
        correct: 2,
        explanation: "Monocrystalline silicon cells are preferred for utility-scale projects due to their high efficiency (20-22%) and long-term reliability."
      },
      {
        question: "What connector type is used to link solar panels together in a string?",
        options: [
          "USB-C connectors",
          "Anderson connectors",
          "MC4 connectors",
          "RJ45 connectors"
        ],
        correct: 2,
        explanation: "MC4 connectors are the industry standard for connecting solar panels. They provide weatherproof, secure connections that can handle high DC voltages."
      },
      {
        question: "What is the main purpose of a single-axis solar tracker?",
        options: [
          "To protect panels from wind",
          "To follow the sun's path and increase energy production",
          "To cool the panels down",
          "To store excess energy"
        ],
        correct: 1,
        explanation: "Single-axis trackers follow the sun from east to west throughout the day, increasing energy production by up to 25% compared to fixed-tilt systems."
      },
      {
        question: "Which company's tracker bearing features a distinctive half-circle (D-shaped) plate?",
        options: [
          "Nextracker",
          "SunPower",
          "Array Technologies",
          "First Solar"
        ],
        correct: 2,
        explanation: "Array Technologies' DuraTrack system features a distinctive semi-circular plate design with the company name embossed vertically."
      },
      {
        question: "What is the primary function of a combiner box in a solar farm?",
        options: [
          "Convert DC to AC power",
          "Store energy in batteries",
          "Combine multiple string outputs and provide protection",
          "Track the sun's position"
        ],
        correct: 2,
        explanation: "Combiner boxes bundle multiple solar panel strings into a single output while providing crucial protection through fuses and surge protection devices (SPDs)."
      },
      {
        question: "What color is typically used for DC positive cables in solar installations?",
        options: [
          "Blue",
          "Green",
          "Black",
          "Red"
        ],
        correct: 3,
        explanation: "Red is the standard color for DC positive (+) cables, while blue or black is used for DC negative (-) cables. Green/yellow is reserved for grounding."
      },
      {
        question: "What does a string inverter do?",
        options: [
          "Combines multiple strings together",
          "Converts DC power from panels to AC power for the grid",
          "Tracks the sun's movement",
          "Protects against lightning"
        ],
        correct: 1,
        explanation: "String inverters convert the DC (Direct Current) electricity generated by solar panels into AC (Alternating Current) electricity that can be fed into the power grid."
      },
      {
        question: "What type of foundation is commonly used for tracker posts in solar farms?",
        options: [
          "Concrete footings",
          "Helical piles",
          "Driven piles (W-beam posts)",
          "Floating foundations"
        ],
        correct: 2,
        explanation: "Driven pile foundations using W-beam (wide flange) steel posts are common in utility-scale solar farms. They're quick to install and work well in most soil conditions."
      },
      {
        question: "Approximately how much more energy can a tracking system produce compared to a fixed-tilt system?",
        options: [
          "5-10% more",
          "25% more",
          "50% more",
          "100% more"
        ],
        correct: 1,
        explanation: "Single-axis trackers typically produce about 25% more energy than fixed-tilt systems by keeping panels optimally oriented toward the sun throughout the day."
      }
    ];
    
    let currentQuestion = 0;
    let score = 0;
    let selectedAnswer = null;
    let answered = false;
    
    function initQuiz() {
      const quizBtn = document.getElementById('quizBtn');
      const quizModal = document.getElementById('quizModal');
      const quizClose = document.getElementById('quizClose');
      const quizNext = document.getElementById('quizNext');
      
      quizBtn.addEventListener('click', () => {
        currentQuestion = 0;
        score = 0;
        selectedAnswer = null;
        answered = false;
        quizModal.classList.add('active');
        showQuestion();
      });
      
      quizClose.addEventListener('click', () => {
        quizModal.classList.remove('active');
      });
      
      quizNext.addEventListener('click', () => {
        if (!answered) return;
        
        currentQuestion++;
        if (currentQuestion >= quizQuestions.length) {
          showResults();
        } else {
          selectedAnswer = null;
          answered = false;
          showQuestion();
        }
      });
    }
    
    function showQuestion() {
      const q = quizQuestions[currentQuestion];
      const content = document.getElementById('quizContent');
      const progressBar = document.getElementById('quizProgressBar');
      const scoreDisplay = document.getElementById('quizScore');
      const nextBtn = document.getElementById('quizNext');
      
      progressBar.style.width = ((currentQuestion + 1) / quizQuestions.length * 100) + '%';
      scoreDisplay.textContent = `Question ${currentQuestion + 1} of ${quizQuestions.length}`;
      nextBtn.disabled = true;
      nextBtn.textContent = 'Select an answer';
      
      const letters = ['A', 'B', 'C', 'D'];
      let optionsHTML = q.options.map((opt, i) => `
        <button class="quiz-option" data-index="${i}">
          <span class="option-letter">${letters[i]}</span>
          <span>${opt}</span>
        </button>
      `).join('');
      
      content.innerHTML = `
        <div class="quiz-question">
          <span>Question ${currentQuestion + 1}</span>
          ${q.question}
        </div>
        <div class="quiz-options">
          ${optionsHTML}
        </div>
        <div class="quiz-feedback" id="quizFeedback"></div>
      `;
      
      // Add click handlers to options
      document.querySelectorAll('.quiz-option').forEach(opt => {
        opt.addEventListener('click', () => selectAnswer(parseInt(opt.dataset.index)));
      });
    }
    
    function selectAnswer(index) {
      if (answered) return;
      
      selectedAnswer = index;
      answered = true;
      
      const q = quizQuestions[currentQuestion];
      const options = document.querySelectorAll('.quiz-option');
      const feedback = document.getElementById('quizFeedback');
      const nextBtn = document.getElementById('quizNext');
      
      options.forEach((opt, i) => {
        opt.style.pointerEvents = 'none';
        if (i === q.correct) {
          opt.classList.add('correct');
        } else if (i === index && i !== q.correct) {
          opt.classList.add('incorrect');
        }
      });
      
      if (index === q.correct) {
        score++;
        feedback.className = 'quiz-feedback correct';
        feedback.innerHTML = `‚úì Correct! ${q.explanation}`;
      } else {
        feedback.className = 'quiz-feedback incorrect';
        feedback.innerHTML = `‚úó Incorrect. ${q.explanation}`;
      }
      
      nextBtn.disabled = false;
      nextBtn.textContent = currentQuestion < quizQuestions.length - 1 ? 'Next Question ‚Üí' : 'See Results ‚Üí';
    }
    
    function showResults() {
      const content = document.getElementById('quizContent');
      const progressBar = document.getElementById('quizProgressBar');
      const scoreDisplay = document.getElementById('quizScore');
      const nextBtn = document.getElementById('quizNext');
      
      progressBar.style.width = '100%';
      scoreDisplay.textContent = 'Quiz Complete!';
      
      const percentage = Math.round((score / quizQuestions.length) * 100);
      let grade, gradeClass, message;
      
      if (percentage >= 90) {
        grade = 'üèÜ Excellent!';
        gradeClass = 'excellent';
        message = "Outstanding! You're a solar farm expert!";
      } else if (percentage >= 70) {
        grade = '‚≠ê Good Job!';
        gradeClass = 'good';
        message = "Great work! You have a solid understanding.";
      } else if (percentage >= 50) {
        grade = 'üìö Keep Learning';
        gradeClass = 'okay';
        message = "You're getting there! Review the material and try again.";
      } else {
        grade = 'üîÑ Try Again';
        gradeClass = 'needs-work';
        message = "Don't give up! Go through the lessons and retake the quiz.";
      }
      
      content.innerHTML = `
        <div class="quiz-results">
          <div class="grade ${gradeClass}">${grade}</div>
          <div class="score-big">${score}/${quizQuestions.length}</div>
          <div class="score-text">${percentage}% - ${message}</div>
          <p style="color: #64748b; margin-top: 20px;">
            You answered ${score} out of ${quizQuestions.length} questions correctly.
          </p>
        </div>
      `;
      
      nextBtn.textContent = 'üîÑ Retake Quiz';
      nextBtn.disabled = false;
      nextBtn.onclick = () => {
        currentQuestion = 0;
        score = 0;
        selectedAnswer = null;
        answered = false;
        nextBtn.onclick = null;
        document.getElementById('quizNext').addEventListener('click', () => {
          if (!answered) return;
          currentQuestion++;
          if (currentQuestion >= quizQuestions.length) {
            showResults();
          } else {
            selectedAnswer = null;
            answered = false;
            showQuestion();
          }
        });
        showQuestion();
      };
    }
    
    init();
    initQuiz();
  </script>
</body>
</html>
