<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ampacity Renewables - Solar Education</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
    
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      overflow: hidden; 
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; 
      background: linear-gradient(180deg, #0a1628 0%, #1a2744 100%); 
      color: #e2e8f0; 
      height: 100vh;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }
    #canvas-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
    canvas { display: block; cursor: grab; will-change: contents; }
    canvas:active { cursor: grabbing; }
    
    /* Professional vignette overlay */
    .vignette-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      z-index: 2;
      background: radial-gradient(ellipse at center, transparent 40%, rgba(10,22,40,0.4) 100%);
    }
    
    /* Subtle scan line effect for tech feel */
    .scanlines {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      z-index: 3;
      background: repeating-linear-gradient(
        0deg,
        transparent,
        transparent 2px,
        rgba(0,0,0,0.03) 2px,
        rgba(0,0,0,0.03) 4px
      );
      opacity: 0.5;
    }
    
    /* ===== HEADER / PROGRESS TRACKER ===== */
    .header-bar {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 70px;
      background: linear-gradient(180deg, rgba(10,22,40,0.98) 0%, rgba(10,22,40,0.9) 100%);
      border-bottom: 1px solid rgba(56,189,248,0.15);
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0 30px;
    }
    
    .logo-section {
      position: absolute;
      left: 30px;
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .logo-icon {
      width: 52px;
      height: 52px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 10px;
      overflow: hidden;
      box-shadow: 0 0 20px rgba(255,20,147,0.6), 0 0 40px rgba(255,20,147,0.3), inset 0 0 0 1px rgba(255,20,147,0.3);
      border: 1px solid rgba(255,20,147,0.4);
    }
    .logo-icon img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    .logo-text {
      font-size: 20px;
      font-weight: 700;
      color: #fff;
      letter-spacing: 0.5px;
    }
    .logo-subtitle {
      font-size: 11px;
      color: #ff69b4;
      font-weight: 600;
      letter-spacing: 2px;
      text-transform: uppercase;
    }
    
    .progress-tracker {
      display: flex;
      align-items: center;
      gap: 4px;
      background: rgba(30,41,59,0.6);
      padding: 6px 8px;
      border-radius: 40px;
      border: 1px solid rgba(56,189,248,0.1);
    }
    .step {
      display: flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
      padding: 8px 14px;
      border-radius: 25px;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      border: 1px solid transparent;
      position: relative;
      overflow: hidden;
    }
    .step::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, rgba(56,189,248,0.15), transparent);
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    .step:hover::before { opacity: 1; }
    .step:hover { 
      background: rgba(56,189,248,0.1);
      transform: translateY(-1px);
    }
    .step.active { 
      background: linear-gradient(135deg, rgba(255,20,147,0.2), rgba(255,105,180,0.1)); 
      border-color: rgba(255,20,147,0.4);
      box-shadow: 0 4px 15px rgba(255,20,147,0.2);
    }
    .step-number { 
      width: 26px; 
      height: 26px; 
      background: #1e293b; 
      border-radius: 50%; 
      display: flex; 
      align-items: center; 
      justify-content: center; 
      font-weight: 600; 
      font-size: 12px;
      transition: all 0.25s;
    }
    .step.active .step-number { 
      background: linear-gradient(135deg, #ff1493, #ff69b4); 
      color: #fff;
    }
    .step-text { font-size: 13px; font-weight: 500; color: #94a3b8; }
    .step.active .step-text { color: #fff; }
    
    .header-controls {
      display: flex;
      gap: 8px;
    }
    .header-btn {
      background: rgba(30,41,59,0.8);
      border: 1px solid rgba(56,189,248,0.2);
      color: #94a3b8;
      padding: 8px 16px;
      border-radius: 8px;
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      overflow: hidden;
    }
    .header-btn::after {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, rgba(56,189,248,0.2), transparent);
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    .header-btn:hover::after { opacity: 1; }
    .header-btn:hover { 
      background: rgba(56,189,248,0.15); 
      color: #fff;
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(56,189,248,0.15);
    }
    .header-btn.active { 
      background: linear-gradient(135deg, #ff1493, #ff69b4); 
      border-color: #ff1493; 
      color: #fff;
      box-shadow: 0 4px 15px rgba(255,20,147,0.3);
    }
    
    /* ===== LEFT PANEL - EDUCATION CONTENT ===== */
    .ui-panel { 
      position: absolute; 
      top: 90px; 
      left: 20px; 
      width: 360px; 
      background: rgba(15,23,42,0.95);
      backdrop-filter: blur(20px);
      border-radius: 16px; 
      z-index: 100; 
      border: 1px solid rgba(56,189,248,0.1);
      max-height: calc(100vh - 110px); 
      overflow: hidden; 
      display: flex; 
      flex-direction: column;
      box-shadow: 
        0 20px 40px rgba(0,0,0,0.3),
        0 0 0 1px rgba(56,189,248,0.05) inset,
        0 1px 0 rgba(255,255,255,0.05) inset;
      transition: box-shadow 0.3s ease, transform 0.3s ease, opacity 0.3s ease;
      will-change: transform, opacity;
    }
    .ui-panel:hover {
      box-shadow: 
        0 25px 50px rgba(0,0,0,0.35),
        0 0 0 1px rgba(56,189,248,0.1) inset,
        0 1px 0 rgba(255,255,255,0.05) inset;
    }
    .panel-header { 
      padding: 20px 24px 16px; 
      border-bottom: 1px solid rgba(56,189,248,0.1);
      background: rgba(30,41,59,0.3);
      position: relative;
    }
    .panel-hide-btn {
      position: absolute;
      top: 12px;
      right: 12px;
      width: 28px;
      height: 28px;
      background: rgba(56,189,248,0.15);
      border: 1px solid rgba(56,189,248,0.3);
      border-radius: 4px;
      color: #38bdf8;
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
    }
    .panel-hide-btn:hover {
      background: rgba(56,189,248,0.3);
      color: #fff;
    }
    .panel-show-btn {
      position: fixed;
      left: 0;
      top: 50%;
      transform: translateY(-50%);
      width: 32px;
      height: 60px;
      background: linear-gradient(135deg, rgba(15,35,50,0.95), rgba(10,25,40,0.98));
      border: 1px solid rgba(56,189,248,0.3);
      border-left: none;
      border-radius: 0 8px 8px 0;
      color: #38bdf8;
      font-size: 14px;
      cursor: pointer;
      z-index: 500;
      display: none;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
      box-shadow: 4px 0 15px rgba(0,0,0,0.3);
    }
    .panel-show-btn:hover {
      background: linear-gradient(135deg, rgba(56,189,248,0.3), rgba(30,60,80,0.95));
      color: #fff;
      width: 40px;
    }
    .ui-panel.hidden {
      transform: translateX(-100%);
      opacity: 0;
      pointer-events: none;
    }
    .panel-title h2 { 
      font-size: 18px; 
      color: #fff; 
      margin-bottom: 4px; 
      font-weight: 600;
    }
    .panel-subtitle { 
      font-size: 12px; 
      color: #ff1493;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .panel-body { 
      padding: 20px 24px; 
      overflow-y: auto; 
      color: #cbd5e1; 
      line-height: 1.65;
      flex: 1;
    }
    .panel-body::-webkit-scrollbar { width: 6px; }
    .panel-body::-webkit-scrollbar-track { background: transparent; }
    .panel-body::-webkit-scrollbar-thumb { background: rgba(56,189,248,0.3); border-radius: 3px; }
    
    .info-box { 
      background: rgba(30,41,59,0.5); 
      padding: 14px 16px; 
      border-radius: 10px; 
      border-left: 3px solid #38bdf8; 
      margin-bottom: 14px;
      transition: all 0.3s ease;
    }
    .info-box:hover {
      background: rgba(30,41,59,0.7);
      transform: translateX(2px);
    }
    .info-box h3 { 
      font-size: 13px; 
      margin-bottom: 8px; 
      color: #38bdf8;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .info-box p { font-size: 13px; color: #94a3b8; margin-bottom: 6px; line-height: 1.5; }
    .info-box p:last-child { margin-bottom: 0; }
    
    .stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px; }
    .stat-card { 
      background: linear-gradient(135deg, rgba(56,189,248,0.1), rgba(56,189,248,0.05)); 
      padding: 14px 12px; 
      border-radius: 10px; 
      text-align: center;
      border: 1px solid rgba(56,189,248,0.1);
      transition: all 0.3s ease;
    }
    .stat-card:hover {
      background: linear-gradient(135deg, rgba(56,189,248,0.15), rgba(56,189,248,0.08));
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(56,189,248,0.1);
    }
    .stat-value { font-size: 20px; font-weight: 700; color: #ff1493; }
    .stat-label { font-size: 11px; color: #64748b; margin-top: 4px; text-transform: uppercase; letter-spacing: 0.5px; }
    
    /* ===== RIGHT PANEL - QUICK STATS ===== */
    .energy-dashboard { 
      position: absolute; 
      top: 90px; 
      right: 20px; 
      width: 260px; 
      background: rgba(15,23,42,0.95);
      backdrop-filter: blur(20px);
      border-radius: 16px; 
      padding: 20px; 
      padding-top: 30px;
      z-index: 100; 
      border: 1px solid rgba(56,189,248,0.1);
      box-shadow: 
        0 20px 40px rgba(0,0,0,0.3),
        0 0 0 1px rgba(56,189,248,0.05) inset,
        0 1px 0 rgba(255,255,255,0.05) inset;
      transition: box-shadow 0.3s ease;
    }
    .energy-dashboard:hover {
      box-shadow: 
        0 25px 50px rgba(0,0,0,0.35),
        0 0 0 1px rgba(56,189,248,0.1) inset,
        0 1px 0 rgba(255,255,255,0.05) inset;
    }
    .dashboard-title { 
      font-size: 11px; 
      color: #94a3b8; 
      font-weight: 600; 
      margin-bottom: 16px;
      text-transform: uppercase;
      letter-spacing: 2px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .step-indicator {
      width: 8px;
      height: 8px;
      background: #ff1493;
      border-radius: 50%;
      box-shadow: 0 0 8px rgba(255,20,147,0.6);
      animation: pulse-dot 2s ease-in-out infinite;
    }
    @keyframes pulse-dot {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.7; transform: scale(1.2); }
    }
    
    /* ===== BOTTOM CONTROLS ===== */
    .controls { 
      position: absolute; 
      bottom: 25px; 
      left: 50%; 
      transform: translateX(-50%); 
      display: flex; 
      gap: 10px; 
      z-index: 100;
      background: rgba(15,23,42,0.9);
      padding: 10px 16px;
      border-radius: 14px;
      border: 1px solid rgba(56,189,248,0.1);
    }
    .control-btn { 
      background: rgba(30,41,59,0.8); 
      border: 1px solid rgba(56,189,248,0.2); 
      color: #94a3b8; 
      padding: 10px 20px; 
      border-radius: 10px; 
      font-size: 13px; 
      font-weight: 500; 
      cursor: pointer; 
      transition: all 0.2s; 
    }
    .control-btn:hover { background: rgba(56,189,248,0.15); color: #fff; border-color: rgba(56,189,248,0.3); }
    .control-btn.active-view { background: linear-gradient(135deg, #ff1493, #ff69b4); border-color: #ff1493; color: #fff; }
    
    .camera-hint { 
      position: absolute; 
      bottom: 85px; 
      left: 50%; 
      transform: translateX(-50%); 
      background: rgba(15,23,42,0.8); 
      padding: 8px 16px; 
      border-radius: 20px; 
      font-size: 11px; 
      color: #64748b; 
      z-index: 100;
      border: 1px solid rgba(56,189,248,0.1);
    }
    
    /* ===== SIGNATURE FOOTER ===== */
    
    /* ===== LOADING SCREEN ===== */
    .loading { 
      position: fixed; 
      top: 0; 
      left: 0; 
      width: 100%; 
      height: 100%; 
      background: linear-gradient(180deg, #0a1628 0%, #1a2744 100%); 
      display: flex; 
      flex-direction: column; 
      align-items: center; 
      justify-content: center; 
      z-index: 10000;
      transition: opacity 0.6s ease, visibility 0.6s;
    }
    .loading.fade-out { opacity: 0; visibility: hidden; pointer-events: none; }
    .loader { 
      width: 50px; 
      height: 50px; 
      border: 3px solid rgba(56,189,248,0.2); 
      border-top-color: #ff1493; 
      border-radius: 50%; 
      animation: spin 1s linear infinite; 
      margin-bottom: 20px; 
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    
    /* ===== VIEW CLOSE-UP BUTTONS ===== */
    .view-demo-btn {
      display: inline-block;
      background: linear-gradient(135deg, #ff1493, #ff69b4);
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 10px;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 4px 15px rgba(255,20,147,0.3);
      transition: all 0.2s;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .view-demo-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(255,20,147,0.4);
    }
    .view-demo-btn.green {
      background: linear-gradient(135deg, #10b981, #34d399);
      box-shadow: 0 4px 15px rgba(16,185,129,0.3);
    }
    .view-demo-btn.green:hover {
      box-shadow: 0 6px 20px rgba(16,185,129,0.4);
    }
    
    /* ===== HIGHLIGHT LEGEND ===== */
    .legend-box {
      background: rgba(20,30,50,0.9);
      border: 1px solid rgba(56,189,248,0.2);
      border-radius: 10px;
      padding: 12px 14px;
      margin-top: 12px;
    }
    .legend-title {
      font-size: 11px;
      color: #38bdf8;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      color: #94a3b8;
      margin-bottom: 6px;
    }
    .legend-item:last-child { margin-bottom: 0; }
    .legend-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
    }
    .legend-line {
      width: 16px;
      height: 3px;
      border-radius: 2px;
    }
    
    /* ===== QUIZ STYLES ===== */
    .quiz-btn {
      background: linear-gradient(135deg, #10b981, #059669) !important;
      border-color: #10b981 !important;
      font-weight: 800 !important;
      letter-spacing: 0.3px;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
    }
    .quiz-btn:hover {
      background: linear-gradient(135deg, #059669, #047857) !important;
      box-shadow: 0 4px 15px rgba(16, 185, 129, 0.4) !important;
    }
    
    /* Feature buttons */
    .feature-btn {
      background: linear-gradient(135deg, #8b5cf6, #7c3aed) !important;
      border-color: #8b5cf6 !important;
      position: relative;
    }
    .feature-btn:hover {
      background: linear-gradient(135deg, #7c3aed, #6d28d9) !important;
      box-shadow: 0 4px 15px rgba(139, 92, 246, 0.4) !important;
    }
    .feature-btn.active {
      background: linear-gradient(135deg, #f59e0b, #d97706) !important;
      border-color: #f59e0b !important;
      box-shadow: 0 0 20px rgba(245, 158, 11, 0.5) !important;
    }
    
    /* Tooltip bubbles */
    .tooltip-bubble {
      position: absolute;
      bottom: calc(100% + 15px);
      left: 50%;
      transform: translateX(-50%) scale(0.9);
      background: linear-gradient(145deg, #1e293b, #0f172a);
      border: 2px solid #38bdf8;
      border-radius: 12px;
      padding: 15px 18px;
      width: 260px;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
      z-index: 1000;
      box-shadow: 0 10px 40px rgba(0,0,0,0.5), 0 0 20px rgba(56, 189, 248, 0.2);
    }
    .tooltip-bubble.show {
      opacity: 1;
      visibility: visible;
      transform: translateX(-50%) scale(1);
    }
    .tooltip-bubble::after {
      content: '';
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      border: 10px solid transparent;
      border-top-color: #38bdf8;
    }
    .tooltip-bubble h4 {
      color: #ff1493;
      margin: 0 0 8px 0;
      font-size: 15px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .tooltip-bubble p {
      color: #cbd5e1;
      margin: 0 0 12px 0;
      font-size: 13px;
      line-height: 1.5;
    }
    .tooltip-bubble .tooltip-actions {
      display: flex;
      gap: 8px;
    }
    .tooltip-bubble button {
      flex: 1;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }
    .tooltip-bubble .tooltip-start {
      background: linear-gradient(135deg, #10b981, #059669);
      border: none;
      color: white;
    }
    .tooltip-bubble .tooltip-start:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);
    }
    .tooltip-bubble .tooltip-close {
      background: transparent;
      border: 1px solid #475569;
      color: #94a3b8;
    }
    .tooltip-bubble .tooltip-close:hover {
      border-color: #64748b;
      color: #cbd5e1;
    }
    
    /* Panel Style Selector */
    .panel-style-tooltip {
      width: 260px;
    }
    .panel-style-options {
      display: flex;
      gap: 8px;
      margin: 12px 0;
    }
    .panel-style-option {
      flex: 1;
      background: rgba(30, 41, 59, 0.8);
      border: 2px solid #334155;
      border-radius: 10px;
      padding: 10px 6px;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
    }
    .panel-style-option:hover {
      border-color: #38bdf8;
      background: rgba(56, 189, 248, 0.1);
    }
    .panel-style-option.active {
      border-color: #ff1493;
      background: rgba(255, 20, 147, 0.15);
      box-shadow: 0 0 12px rgba(255, 20, 147, 0.3);
    }
    .panel-style-option .style-icon {
      font-size: 20px;
      color: #38bdf8;
      letter-spacing: 1px;
    }
    .panel-style-option.active .style-icon {
      color: #ff1493;
    }
    .panel-style-option .style-label {
      font-size: 13px;
      font-weight: 700;
      color: #fff;
    }
    .panel-style-option .style-desc {
      font-size: 9px;
      color: #94a3b8;
    }
    
    .quiz-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 10, 20, 0.95);
      z-index: 10000;
      justify-content: center;
      align-items: center;
      animation: fadeIn 0.3s ease;
    }
    .quiz-modal.active {
      display: flex;
    }
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    .quiz-container {
      background: linear-gradient(145deg, #0f172a, #1e293b);
      border: 2px solid #38bdf8;
      border-radius: 20px;
      width: 90%;
      max-width: 700px;
      max-height: 85vh;
      overflow-y: auto;
      box-shadow: 0 25px 80px rgba(56, 189, 248, 0.3), 0 0 100px rgba(255, 20, 147, 0.1);
      position: relative;
    }
    
    .quiz-header {
      background: linear-gradient(135deg, #1e293b, #334155);
      padding: 25px 30px;
      border-bottom: 2px solid #38bdf8;
      border-radius: 18px 18px 0 0;
      text-align: center;
      position: relative;
    }
    .quiz-header h2 {
      color: #ff1493;
      margin: 0 0 8px 0;
      font-size: 28px;
    }
    .quiz-header p {
      color: #94a3b8;
      margin: 0;
      font-size: 14px;
    }
    .quiz-close {
      position: absolute;
      top: 15px;
      right: 20px;
      background: rgba(239, 68, 68, 0.2);
      border: 2px solid #ef4444;
      color: #ef4444;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 18px;
      transition: all 0.2s;
    }
    .quiz-close:hover {
      background: #ef4444;
      color: white;
    }
    
    .quiz-progress {
      height: 6px;
      background: #1e293b;
    }
    .quiz-progress-bar {
      height: 100%;
      background: linear-gradient(90deg, #ff1493, #38bdf8);
      width: 10%;
      transition: width 0.4s ease;
    }
    
    .quiz-content {
      padding: 30px;
    }
    
    .quiz-question {
      color: #f1f5f9;
      font-size: 20px;
      font-weight: 600;
      margin-bottom: 25px;
      line-height: 1.5;
    }
    .quiz-question span {
      color: #38bdf8;
      font-size: 14px;
      display: block;
      margin-bottom: 8px;
    }
    
    .quiz-options {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    
    .quiz-option {
      background: linear-gradient(135deg, #1e293b, #0f172a);
      border: 2px solid #334155;
      border-radius: 12px;
      padding: 16px 20px;
      color: #e2e8f0;
      font-size: 16px;
      cursor: pointer;
      transition: all 0.2s;
      text-align: left;
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .quiz-option:hover {
      border-color: #38bdf8;
      background: linear-gradient(135deg, #1e3a5f, #0f172a);
      transform: translateX(5px);
    }
    .quiz-option.selected {
      border-color: #38bdf8;
      background: linear-gradient(135deg, #0c4a6e, #1e293b);
    }
    .quiz-option.correct {
      border-color: #10b981;
      background: linear-gradient(135deg, #064e3b, #1e293b);
    }
    .quiz-option.incorrect {
      border-color: #ef4444;
      background: linear-gradient(135deg, #7f1d1d, #1e293b);
    }
    .quiz-option .option-letter {
      width: 32px;
      height: 32px;
      background: #334155;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      color: #38bdf8;
      flex-shrink: 0;
    }
    .quiz-option.correct .option-letter {
      background: #10b981;
      color: white;
    }
    .quiz-option.incorrect .option-letter {
      background: #ef4444;
      color: white;
    }
    
    .quiz-feedback {
      margin-top: 20px;
      padding: 15px 20px;
      border-radius: 10px;
      font-size: 15px;
      display: none;
    }
    .quiz-feedback.correct {
      display: block;
      background: rgba(16, 185, 129, 0.15);
      border: 1px solid #10b981;
      color: #10b981;
    }
    .quiz-feedback.incorrect {
      display: block;
      background: rgba(239, 68, 68, 0.15);
      border: 1px solid #ef4444;
      color: #fca5a5;
    }
    
    .quiz-footer {
      padding: 20px 30px;
      background: linear-gradient(135deg, #1e293b, #0f172a);
      border-top: 1px solid #334155;
      border-radius: 0 0 18px 18px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .quiz-score {
      color: #94a3b8;
      font-size: 14px;
    }
    .quiz-btn-action {
      background: linear-gradient(135deg, #ff1493, #db2777);
      border: none;
      color: white;
      padding: 12px 28px;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }
    .quiz-btn-action:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 20px rgba(255, 20, 147, 0.4);
    }
    .quiz-btn-action:disabled {
      background: #334155;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    
    .quiz-results {
      text-align: center;
      padding: 20px;
    }
    .quiz-results h3 {
      font-size: 32px;
      margin-bottom: 10px;
    }
    .quiz-results .score-big {
      font-size: 72px;
      font-weight: bold;
      background: linear-gradient(135deg, #ff1493, #38bdf8);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      margin: 20px 0;
    }
    .quiz-results .score-text {
      color: #94a3b8;
      font-size: 18px;
      margin-bottom: 30px;
    }
    .quiz-results .grade {
      font-size: 24px;
      padding: 10px 30px;
      border-radius: 50px;
      display: inline-block;
      margin-bottom: 20px;
    }
    .quiz-results .grade.excellent {
      background: linear-gradient(135deg, #10b981, #059669);
      color: white;
    }
    .quiz-results .grade.good {
      background: linear-gradient(135deg, #38bdf8, #0284c7);
      color: white;
    }
    .quiz-results .grade.okay {
      background: linear-gradient(135deg, #f59e0b, #d97706);
      color: white;
    }
    .quiz-results .grade.needs-work {
      background: linear-gradient(135deg, #ef4444, #dc2626);
      color: white;
    }

    /* ===== SITE BUILDER CONFIG PANEL ===== */
    .site-builder-modal {
      display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0, 10, 20, 0.95); z-index: 10000;
      justify-content: center; align-items: center; animation: fadeIn 0.3s ease;
    }
    .site-builder-modal.active { display: flex; }
    .sb-container {
      background: linear-gradient(145deg, #0f172a, #1e293b);
      border: 2px solid #38bdf8; border-radius: 20px;
      width: 94%; max-width: 860px; max-height: 90vh; overflow-y: auto;
      box-shadow: 0 25px 80px rgba(56,189,248,0.3), 0 0 100px rgba(255,20,147,0.1);
      position: relative;
    }
    .sb-container::-webkit-scrollbar { width: 6px; }
    .sb-container::-webkit-scrollbar-track { background: transparent; }
    .sb-container::-webkit-scrollbar-thumb { background: rgba(56,189,248,0.3); border-radius: 3px; }
    .sb-head {
      background: linear-gradient(135deg, #1e293b, #334155);
      padding: 22px 30px; border-bottom: 2px solid #38bdf8;
      border-radius: 18px 18px 0 0; text-align: center; position: relative;
    }
    .sb-head h2 { color: #ff1493; margin: 0 0 4px; font-size: 24px; font-weight: 700; }
    .sb-head p { color: #94a3b8; margin: 0; font-size: 13px; }
    .sb-x {
      position: absolute; top: 14px; right: 16px; width: 34px; height: 34px;
      background: rgba(239,68,68,0.15); border: 1px solid rgba(239,68,68,0.3);
      border-radius: 50%; color: #f87171; font-size: 18px; cursor: pointer;
      display: flex; align-items: center; justify-content: center; transition: all 0.2s;
    }
    .sb-x:hover { background: rgba(239,68,68,0.3); border-color: #ef4444; }
    .sb-body { padding: 18px 28px 12px; }
    .sb-section { margin-bottom: 16px; }
    .sb-section h3 {
      color: #38bdf8; font-size: 14px; font-weight: 700; margin: 0 0 8px;
      letter-spacing: 0.5px; text-transform: uppercase;
    }
    .sb-section h3::before { content: '▸ '; color: #ff1493; }
    .sb-opts { display: flex; flex-wrap: wrap; gap: 8px; }
    .sb-opt {
      background: linear-gradient(135deg, rgba(30,41,59,0.8), rgba(15,23,42,0.9));
      border: 1.5px solid rgba(148,163,184,0.15); border-radius: 12px;
      padding: 10px 16px; cursor: pointer; transition: all 0.2s;
      color: #cbd5e1; font-size: 13px; font-weight: 500;
      flex: 1; min-width: 180px; text-align: center;
    }
    .sb-opt:hover:not(.sb-disabled) {
      border-color: #38bdf8; background: linear-gradient(135deg, rgba(56,189,248,0.1), rgba(30,41,59,0.9));
      color: #f1f5f9; transform: translateY(-1px);
    }
    .sb-opt.sb-selected {
      border-color: #10b981; background: linear-gradient(135deg, rgba(16,185,129,0.15), rgba(5,150,105,0.1));
      color: #6ee7b7; box-shadow: 0 0 14px rgba(16,185,129,0.2);
    }
    .sb-opt.sb-selected::after { content: ' ✓'; color: #34d399; font-weight: 700; }
    .sb-opt.sb-disabled {
      opacity: 0.3; cursor: not-allowed; border-color: rgba(148,163,184,0.05);
      background: rgba(15,23,42,0.5); color: #475569;
    }
    .sb-opt-sub { font-size: 11px; color: #64748b; margin-top: 2px; }
    .sb-opt.sb-selected .sb-opt-sub { color: #94a3b8; }
    .sb-footer {
      display: flex; justify-content: space-between; align-items: center;
      padding: 14px 28px; border-top: 1px solid rgba(56,189,248,0.1);
      background: rgba(15,23,42,0.5);
      border-radius: 0 0 18px 18px;
    }
    .sb-footer-info { color: #94a3b8; font-size: 12px; }
    .sb-btn-reset {
      background: transparent; border: 1px solid rgba(148,163,184,0.2);
      color: #94a3b8; padding: 6px 14px; border-radius: 8px; cursor: pointer;
      font-size: 12px; transition: all 0.15s;
    }
    .sb-btn-reset:hover { border-color: #ff1493; color: #ff1493; }
    .sb-btn-view {
      background: linear-gradient(135deg,#10b981,#059669); color: #fff;
      border: 2px solid #34d399; padding: 12px 30px; border-radius: 14px;
      cursor: pointer; font-weight: 700; font-size: 15px;
      box-shadow: 0 6px 25px rgba(16,185,129,0.4); transition: all 0.2s;
      display: none;
    }
    .sb-btn-view.visible { display: inline-block; animation: fadeIn 0.3s ease; }
    .sb-btn-view:hover { transform: translateY(-2px); box-shadow: 0 8px 30px rgba(16,185,129,0.5); }

    /* Site Builder Flow Bar */
    .sb-flow-bar {
      display: flex; align-items: center; justify-content: center; gap: 0;
      padding: 14px 28px; background: rgba(15,23,42,0.4);
      border-bottom: 1px solid rgba(56,189,248,0.08);
    }
    .sb-flow-node {
      display: flex; align-items: center; gap: 6px; padding: 6px 12px;
      border-radius: 8px; border: 1px solid rgba(56,189,248,0.08);
      background: rgba(15,23,42,0.5); transition: all 0.3s ease;
    }
    .sb-flow-node.filled { border-color: rgba(16,185,129,0.3); background: rgba(16,185,129,0.08); }
    .sb-flow-node.active-node { border-color: rgba(56,189,248,0.3); background: rgba(56,189,248,0.05); }
    .sb-flow-dot { width: 7px; height: 7px; border-radius: 50%; background: #334155; transition: all 0.3s; flex-shrink: 0; }
    .sb-flow-node.filled .sb-flow-dot { background: #10b981; box-shadow: 0 0 6px rgba(16,185,129,0.5); }
    .sb-flow-node.active-node .sb-flow-dot { background: #38bdf8; box-shadow: 0 0 6px rgba(56,189,248,0.5); }
    .sb-flow-label { font-size: 10px; font-weight: 600; color: #475569; transition: color 0.3s; white-space: nowrap; }
    .sb-flow-node.filled .sb-flow-label { color: #6ee7b7; }
    .sb-flow-node.active-node .sb-flow-label { color: #7dd3fc; }
    .sb-flow-val { font-size: 9px; color: #334155; max-width: 90px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; transition: color 0.3s; }
    .sb-flow-node.filled .sb-flow-val { color: #34d399; }
    .sb-flow-arrow { color: #1e293b; font-size: 10px; padding: 0 5px; transition: color 0.3s; flex-shrink: 0; }
    .sb-flow-arrow.lit { color: #10b981; }

    /* Fullscreen 3D Site Viewer */
    #siteViewerFS {
      display:none; position:fixed; top:0; left:0; width:100%; height:100%;
      background:#080f1a; z-index:20000;
    }
    #siteViewerFS.active { display:block; }
    #siteViewerFS canvas { display:block; width:100%; height:100%; cursor:grab; will-change:contents; }
    #siteViewerFS canvas:active { cursor:grabbing; }
    .sv-topbar {
      position:fixed;top:0;left:0;right:0;height:54px;
      background:linear-gradient(135deg,rgba(15,23,42,0.95),rgba(30,41,59,0.95));
      backdrop-filter:blur(12px);border-bottom:1px solid rgba(56,189,248,0.25);
      display:flex;align-items:center;justify-content:space-between;padding:0 24px;z-index:20010;
    }
    .sv-topbar h1{font-size:17px;font-weight:700;background:linear-gradient(135deg,#ff1493,#38bdf8);-webkit-background-clip:text;background-clip:text;-webkit-text-fill-color:transparent;}
    .sv-topbar .sv-badge{background:rgba(16,185,129,0.2);border:1px solid #10b981;color:#34d399;padding:4px 14px;border-radius:20px;font-size:12px;font-weight:600;}
    .sv-topbar .sv-close-btn{background:rgba(239,68,68,0.15);border:1px solid rgba(239,68,68,0.4);color:#f87171;padding:6px 16px;border-radius:10px;cursor:pointer;font-size:13px;font-weight:600;transition:all 0.15s;}
    .sv-topbar .sv-close-btn:hover{background:rgba(239,68,68,0.3);border-color:#ef4444;}
    .sv-ctrl-panel{position:fixed;top:68px;left:20px;background:rgba(10,18,30,0.92);backdrop-filter:blur(12px);border:1px solid rgba(56,189,248,0.15);border-radius:12px;padding:10px 14px;z-index:20010;display:flex;flex-direction:column;gap:6px;}
    .sv-ctrl-btn{background:rgba(56,189,248,0.1);border:1px solid rgba(56,189,248,0.25);color:#94a3b8;padding:7px 14px;border-radius:8px;cursor:pointer;font-size:11px;font-weight:600;transition:all 0.15s;}
    .sv-ctrl-btn:hover{background:rgba(56,189,248,0.2);color:#e2e8f0;border-color:#38bdf8;}
    .sv-ctrl-btn.active{background:rgba(16,185,129,0.2);border-color:#10b981;color:#34d399;}
    .sv-cfg-panel{position:fixed;bottom:20px;left:20px;background:rgba(10,18,30,0.92);backdrop-filter:blur(14px);border:1px solid rgba(56,189,248,0.2);border-radius:16px;padding:18px 22px;z-index:20010;max-width:340px;}
    .sv-cfg-panel .sv-cfg-title{font-size:13px;font-weight:700;color:#ff1493;margin-bottom:10px;letter-spacing:0.5px;}
    .sv-cfg-row{display:flex;justify-content:space-between;padding:5px 0;border-bottom:1px solid rgba(255,255,255,0.05);font-size:12px;}
    .sv-cfg-row:last-child{border:none;}
    .sv-cfg-label{color:#64748b;font-weight:600;}
    .sv-cfg-val{color:#e2e8f0;font-weight:500;text-align:right;}
    .sv-legend{position:fixed;bottom:20px;right:20px;background:rgba(10,18,30,0.88);backdrop-filter:blur(12px);border:1px solid rgba(56,189,248,0.15);border-radius:12px;padding:12px 16px;z-index:20010;display:flex;gap:16px;}
    .sv-leg-item{display:flex;align-items:center;gap:6px;font-size:11px;color:#94a3b8;}
    .sv-leg-dot{width:10px;height:10px;border-radius:50%;}
    .sv-hint{position:fixed;top:68px;right:20px;background:rgba(10,18,30,0.8);padding:6px 14px;border-radius:20px;font-size:11px;color:#64748b;z-index:20010;pointer-events:none;transition:opacity 1s;}

  </style>
</head>
<body>
  <div class="loading" id="loading">
    <div class="loader"></div>
    <h2 style="color:#fff; font-weight:600;">Loading Solar Education</h2>
    <p style="color:#64748b; margin-top:8px; font-size:14px;">Preparing 3D environment...</p>
  </div>
  
  <div id="canvas-container"></div>
  <div class="vignette-overlay"></div>
  <div class="scanlines"></div>
  
  <!-- ===== HEADER BAR ===== -->
  <header class="header-bar">
    <div class="logo-section">
      <div class="logo-icon">
        <img src="data:image/jpeg;base64,UklGRmo0AABXRUJQVlA4WAoAAAAgAAAAZAQAzwcASUNDUMgBAAAAAAHIAAAAAAQwAABtbnRyUkdCIFhZWiAH4AABAAEAAAAAAABhY3NwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAA9tYAAQAAAADTLQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlkZXNjAAAA8AAAACRyWFlaAAABFAAAABRnWFlaAAABKAAAABRiWFlaAAABPAAAABR3dHB0AAABUAAAABRyVFJDAAABZAAAAChnVFJDAAABZAAAAChiVFJDAAABZAAAAChjcHJ0AAABjAAAADxtbHVjAAAAAAAAAAEAAAAMZW5VUwAAAAgAAAAcAHMAUgBHAEJYWVogAAAAAAAAb6IAADj1AAADkFhZWiAAAAAAAABimQAAt4UAABjaWFlaIAAAAAAAACSgAAAPhAAAts9YWVogAAAAAAAA9tYAAQAAAADTLXBhcmEAAAAAAAQAAAACZmYAAPKnAAANWQAAE9AAAApbAAAAAAAAAABtbHVjAAAAAAAAAAEAAAAMZW5VUwAAACAAAAAcAEcAbwBvAGcAbABlACAASQBuAGMALgAgADIAMAAxADZWUDggfDIAADDOAp0BKmUE0Ac+USiSRqSioiEhnUggkAoJaW777T0mFw468GKww9dc0c/jf0n38W+PE/3794v8V7z/CPRZ34+3f4f/If3D3r+AXkf/f8sLw/8w/539r/zHvJ/yPrM/jXqE/wT+rf/3/P9db/8elb/6eiN6jP4J/+skvvmOeA6jbG//Ors/9s0nz/9NPQv8J/6fMH5Ncc1/56/58DzfCOKAKsi20y3uOsAFWRbaZb3HWACrIttMt7jrABVkW2mW9x1gAqyLbTLe46wAVZFtplvcdYAKsi20y3uOsAFWRbaZb3HWACrIttMt7jrABVkW2mW9x1gAqyLbTLe46wAVZFtplvcdYAKsi20y3uOsAFWRbaZb3HWACrIttMt7jrABVkW2mW9x1gAqyLbTLe46wAVZFtplvcdYAKsi20y3uOsAFWRbaZb3HWACrIttMt7jrABVkW2mW9x1gAqyLbTLe46wAVZFtplvcdYAKsi20y3uOsAFWRbaZb3HWACrIttMt7jrABVkW2mW9x1gAqyLbTLe46wAVZFtplvcdYAKsi20y3uOsAFWRbaZb3HWACrIttMt7jrABVkW2mW9x1gAqyLbTLe46wAVZFtplvcdYAKsi20y3uOsAFWRbaZb3HWACrIttMt7jrABVkW2mW9x1gAqyLbTLe46wAVZFtplvcdYAKsi20y3uOsAFWRbaZb3HWACrIttMt7jrABVkW2mW9x1gAqyLbTLe46wAVZFtplvcdYAKsi20y3uOsAFWRbaZb3HWACrIttMt7jrABVkW2mW9x1gAqyLbTLe46wAVZFtplvcdYAKsi20y3uOsAFWRbaZb3HWACrIttMt7jrABVkW2mW9x1gAqyLbTLe46wAVZFtplvcdYAKsi20y3uOsAFWRbaZb3HWACrIttMt7jrABVkW2mW9x1gAqyLbTLe46wAVZFtplvcdYAKsi20y3uOsAFWRbaZb3HWACrIttMt7jrABVkW2mW9x1gAqyLbTLe46wAVZFtplvcdYAKsi20y3uOsAFWRbaZb3HWACrIttMt7jrABVkW2mW9x1gAqyLbTLe46wAVZFtplvcdYAKsi20y3uOsAFWRbaZb3HWACrIttMt7jrABVkW2mW9x1gAqyLbTLe46wAVZFtplvcdYAKsi20y3uOsAFWRbaZb3HWACrIttMt7jrABVkW2mW9x1gAqyLbTLe46wAVZFtplvcdYAKsi20y3uOsAFWRbaZb3HWACrIttMt7jrABVkW2mW9x1gAqyLbTLe46wAVZFtplvcdYAKsi20y3uOsAFWRbaZb3HWACrIttMt7jrABVkW2mW9x1gAqyLbTLe46wAVZFtplvcdYAKsi20m2Kl7siYx1gAqyLbTLe46wAVZFtplvcdYAKsi20y3uOsADsOvq+uduHQEAssmKB/ufasdYAKsi20y3uOsAFWRbaZb3HWACrIttMt7jrABTKjJ1AH94pvvv8fiDPXOB2VbikttMt7jrABVkW2mW9x1gAqyLbTLe46wAVZFs4ZOMLvK5A99vW6Rf/05Zg4WumW9x1gAqyLbTLe46wAVZFtplvcdYAKsi20y3rkSCkxfStNfxPbZ1xPnIPslEtixbR70VkW2mW9x1gAqyLbTLe46wAVZFtplvcdYAKZWO0VCdek4Gtn+x93j7QemAPb+9T2QSo2ACrIttMt7jrABVkW2mW9x1gAqyLbTLe46vyh1sm17EOKaMaNQNI4uOQjyDiKRwxJ/N7jrABVkW2mW9x1gAqyLbTLe46wAVZFtplucYuOvXKWMU4+Z0vzaMx52UbWQvPNQBVkW2mW9x1gAqyLbTLe46wAVZFtplvcdW+UhhHDV6j/bDp15LE4wilUVa4pLbTLe46wAVZFtplvcdYAKsi20y3uOsAFMSHvlgKooh0iQi/75sDZArK0cG+Rf4neisi20y3uOsAFWRbaZb3HWACrIttMt7f0AkzbmgowAiJLcxcTpDVZh9JFCvwF0x1gAqyLbTLe46wAVZFtplvcdYAKsi20xyS/uQwa5A9UhB3ZFbX66GdqQQ8CAAE0VkW2mW9x1gAqyLbTLe46wAVZFtplvcdX/jDQG8MaQcAjl3gNEmtPKoRupSRSCtoDOMdYAKsi20y3uOsAFWRbaZb3HWACrIttMtz5CTWmcZIxmCwSyuRCMtQenRLsCk3f2HEIVFyLbTLe46wAVZFtplvcdYAKsi20y3uOsAFVcE12AmqhkLwTwuFJBfEraOTygs8A0ltplvcdYAKsi20y3uOsAFWRbaZb3HWACmYAUw1ZGo/CKEkOvyN2xTco/DXS6344x1gAqyLbTLe46wAVZFtplvcdYAKsi20y3rUfYidIiB1saiW9vzMNYqIEdXbsqgTvRWRbaZb3HWACrIttMt7jrABVkW2mW9x0lZkkDVxxDaypEJik+8e28/j1uHvvSXGAXTHWACrIttMt7jrABVkW2mW9x1gAqyLKCFVPjCtjLFEKb/b0UOldkXhrMl6S6r6kWmkttMt7jrABVkW2mW9x1gAqyLbTLe46wAVVvzVTvhLq0h1hwu9ExH27I7shE7W47m6EcZ6d6KyLbTLe46wAVZFtplvcdYAKsi20y3uNXykJRUIZWnMC3Bsxq4A47dhUk4+ws6DSMNMVHPPsRglFgkFJUAHRpI4Gpb6H1Zb1nmA+bfNl6JJMLdVKmiIr+64rIttMt7jrABVkW2mW9x1gAqyLZrBBefPeqBe1t7jUbo2bMJ9zPniKE/TY20AZo/g5mvm6rXz4TXz4T4TXzXzXdKO7gHvZaVt89I5Al4u5U4NB4/R0b70VkW2mW9x1gAqyLbTLe46wAUzIPWOo/ezo9TigBxdKXX+UHql71lQnRL/JHT50C1PFZFtlWH6JiKwz6syX5o++BYnpBwozSY6wAVZFtplvcdYAKsi20y3uOkOczRp7Pf8wEAU0DEKBHgnLw8+LKgaBFu2BUjW/5I1qAlWRbab5sxyh57kywYi7JuWPdFlq1ARcYBdMdYAKsi20y3uOsAFWRBttfH3Phi0rMt60xH/bU4Ys9QjgA9pDBcInf2W2+46wAVYyYS5vxO21W3Nv8TvRWRbaZb3HWACrIttMt65DX0kvrNrFgmTtLIyd25QykqEljRKp2wnjdwFnd/4yg1AFWNUmtFilnM+rYC6Y6wAVZFtplvcdYAKsi2ypo7Ac0TNXYEUxaTsYvj5DnSU9KCnJudrJHXAEDU61b0VkW2kyiKgmhBpcBdMdYAKsi20y3uOsAFWRZQQZ0IC2T2YWzgsAwIErowLrGpt+41Ltq1zPJhKM0i4wC6ZBBwhWAT5290y3uOsAFWRbaZb3HWACrIgX667EHwoIt/oyZZGXANbecOf4Fv1Yi3QoBM2jW0C3wLsAFWRbZU5kRYTjBaY8Ms2oqk3orIttMt7jrABVkW2mWQZTpFxS4eUwpkLaOAAKZTDKTwKknrQIbEXGVtdCwUdodNOprXRKreisi20mLqDhWsFirwuqDUAVZFtplvcdYAKsi2cy2gx32dkAZDJOvhOJIZMLDS39n/rABAYAX37q9LsIpxp7si4wC6Y1hUa3SObnSf/N2ReYVkW2mW9x1gAqyLbTLetyN+oni4TKr0y5qSyIH9RvvmvFMAhONdLjALhj3fddEBg+OPP9sd2ACrItso6zUzM+rZIuMAumOsAFWRbaZb3GtE6nSwmUnswtnAsRjicVAy1z96KyMbMhUyVxjSrjVoReTvRWRbasgMmieozPnVnKDUAVZFtplvcdYAKsZrdQgk++5HQq1oAFMHYDGVScgY5GAXTGsEWGsiKpxHIERbaZb3HSRdWYzIiqYIneisi20y3uOsAFWRCy2OqFBt9moXRvAPBYupyZZ1xgF0x0g3VdBzqkr2eKyLbTQVM60eDv/k5O9FZFtplvcdYAKsiBSZoUY4yaL9aVO+woteUp8fgCyN5Mt7jq/9vOa+l4b6wNRX5FxgF0xqvvyd+Syskt46wAVZFtplvcdX/klF5fAmNGSVbKrc7NmRAkfdqMAVZFtplvwcG3bJ94dvlZrmZB5njrABVkQLujFoX9RSwUxWRbaZb3HWACrIslPjYmFvsI9mF6gBCz3+SYloiMFfRWRbaZb2LNcp+7alKkmkttMt7f1NjS/7CxmpwWnMKIOKS20y3uOsAFWRZEOX2D7AgNqSA4Gph5mshb/3HWACrIttJuhabuQQ+mIA9AqyLbTHG510ow8+Jfeisi20y3uOsAFVcVZWnyho8Aef8m/cG6P57ekYBdMdYAKyhVHPUJTMFAPPWY6wAVZNQaV7SjsCIo3y20y3uOsAFWRbaTe2IGMHWqoNa5EJxZZJe2qcMAumOsAFWRCFvHCycmb0y4GjJbx1gAqyIN6YqRuNxRzHWACrIttMt7jpIWepu0HoRbmV54+yn+rfhS2nPAFWRbaZb3HVrhomoQ81aeT0reisi21AzaLRSTKBqw6Y6wAVZFtplvb+pUIzMUK2WH8nmhdf9AoL9lci20y3uOsAFWnSGG8PdOLMKxbaZb3Gr6NsboyNCk3+KyLbTLe46wAVVnpLliUsgN0qPAx932Ix+vACrIttMt7jrAA6CDq0mda+VyrJdAqyLbTHCbwAv72k85jrABVkW2mW9xqwBO84Tzy2j27SiyT2NU4lULu4wNJVkW2mW9x1gApihOwtZ3OXW2Y6wAVY5yUyrEjCFi0I4TubpjrABVkWUp7kTkgR+E+E+E14Ld9viDuliQ3gMfsUTgA8+BMsDwBjhiD4T4Ohz37rfrfrfrfrfrfrfrfrfrfrfrfrfrfrfrfrfrRYoQBtm8ZCZ6vc90OwYzBr7ckLHgLpjq/8H5EPQ7kGiGlvcdYAKsaAzSGC1FSSg21lSLm7PzrtPGKfB2gaHFOBpK1Ll+YFIlJ7WxKqjEI34Vg+laSOBqekjgSvpIGmp6SOBKys6uLQNJX0kDTU6nAy0Ebd6XL+8wRv8FLNizlx8n3a4wC6Y2Aztd71maKNKtkW2mW9x0kYiZjvstI9pF52PJRFnk3xkJkBxdP0NKTfsFWa7oey6foYYN7dAx/lWQgtXQ3cmQqOnisi20xx1qq2nOQL8KFwpoVZFtpjrbBBn/aPpmRXLbTLe46wAVZFtplvcdX5Q63S/sia1ampnTrykJrdk+VZtFZFtpluZLB57o/wWuzFZFtpljYH7I1ewYJBm/mhKS20y3uOsAFWRbaZb3HSSENIOCoHDLV/F8Fv2qPHhcYBdMdJUKTZNhkYShHCdzdMdX/j5zYRHPJVlH3xWRbaZb3HWACrIttMt7jUuWwdmA3MSKh6SG3zdnqV8NwVALYzHWACrGSbJJxTSD/a4wC4eNBGZIw5T3fE70VkW2mW9x1gAqyLbSY/b1E/7EWSAMbOuYRkcPgTi8qZb3HV/5rLjktQRGJRzHV/4yNCImEL7GXaKXhDLe46wAVZFtplvcdYAKZkE51MFc3WvkMwPir1Fdsv6ZWy9AVcYBdMdIMKN40jAw5b3GrsIuWE9H9jPCY/jlqwC6Y6wAVZFtplvcdYAKducYbHF85mqPJhluaFnu4M4c4ZQagCrGoMkRRZ2CAj/Asy0EXE5ylE4awxkmKDUAVZFtplvcdYAKsi2cE8KQveJUzKUBYs2gbItsrIHBAy0kHjAk/FJbaZYx0QpyKfYfqKc11ADjEu5YnHfkcUAVZFtplvcdYAKsi2zLU2iGbr8KcT3KSTFXfoU6Y8OZyMAwaFjHN5lZmhajUF/YlKKAKsi20mHeHtiFD9dCmgcRZ+xR0UV4NNT0kcDU9JHA1PSRwNT2T2SYOYlBRAz+TqekjfS64mciInOBqekjganpI4Gp6SN9LriZLp60gn5SKyBp2gRK4ROxFvcdXDB9hsO/5iCo8/DRFjdI8BEFDYq0HA1PSRwNT0kb6pgUVvV+sanpDKEsHLkXF+g/+Kx/QhnFaKrL0QtFVl6IWP6D/4g4FR/5VkIuMAunRqiEmkA5RCTSSs2xDXABVkW2mW9x1gAqyLbTLe46wAVZFtplvcdYAKsi20y3uOsAFWRbaZb3HWACrIttMt7jrABVkW2mW9x1gAqyLbTLe46wAVZFtplvcdYAKsi20y3uOsAFWRbaZb3HWACrIttMt7jrABVkW2mW9x1gAqyLbTLe46wAVZFtplvcdYAKsi20y3uOsAFWRbaZb3HWACrIttMt7jrABVkW2mW9x1gAqyLbTLe46wAVZFtplvcdYAKsi20y3uOsAFWRbaZb3HWACrIttMt7jrABVkW2mW9x1gAqyLbTLe46wAVZFtplvcdYAKsi20y3uOsAFWRbaZb3HWACrIttMt7jrABVkW2mW9x1gAqyLbTLe46wAVZFtplvcdYAKsi20y3uOsAFWRbaZb3HWACrIttMt7jrABVkW2mW9x1gAqyLbTLe46wAVZFtplvcdYAKsi20y3uOsAFWRbaZb3HWACrIttMt7jrABVkW2mW9x1gAqyLbTLe46wAVZFtplvcdYAKsi20y3uOsAFWRbaZb3HWACrIttMt7jrABVkW2mW9x1gAqyLbTLe46wAVZFtplvcdYAKsi20y3uOsAFWRbaZb3HWACrIttMt7jrABVkW2mW9x1gAqyLbTLe46wAVZFtplvcdYAKsi20y3uOsAFWRbaZb3HWACrIttMt7jrABVkW2mW9x1gAqyLbTLe46wAVZFtplvcdYAKsi20y3uOsAFWRbaZb3HWACrIttMt7jrABVkW2mW9x1gAqyLbTLe46wAVZFtplvcdYAKsi20y3uOsAFWRbaZb3HWACrIttMt7jrABVkW2mW9x1gAqyLbTLe46wAVZFtplvcdYAKsi20y3uOsAFWRbaZb3HWACrIttMt7jrABVkW2mW9x1gAqyLbTLe46wAVZFtplvcdYAKsi20y3uOsAFWRbaZb3HWACrIttMt7jrABVkW2mW9x1gAqyLbTLe46wAVZFtplvcdYAKsi20y3uOsAFWRbaZb3HWACrIttMt7jrABVkW2mW9x1gAqyLbTLe46wAVZFtplvcdYAKsi20y3uOsAFWRbaZb3HWACrIttMt7jrABVkW2mW9x1gAqyLbTLe46wAVZFtplvcdYAKsi20y3uOsAFWRbaZb3HWACrIttMt7jrABVkW2mW9x1gAqyLbTLe46wAVZFtplvcdYAKsi20y3uOsAFWRbaZb3HWACrIttMt7jrABVkW2mW9x1gAqyLbTLe46wAVZFtplvcdYAKsi20y3uOsAFWRbaZb3HWACrIttMt7jrABVkW2mW9x1gAqyLbTLe46wAVZFtplvcdYAKsi20y3uOsAFWRbaZb3HWACrIttMt7jrABVkW2mW9x1gAqyLbTLe46wAVZFtplvcdYAKsi20y3uOsAFWRbaZb3HWACrIttMt7jrABVkW2mW9x1gAqyLbTLe46wAVZFtplvcdYAKsi20y3uOsAFWRbaZb3HWACrIttMt7jrABVkW2mW9x1gAqyLbTLe46wAVZFtplvcdYAKsi20y3uOsAFWRbaZb3HWACrIttMt7jrABVkW2mW9x1gAqyLbTLe46wAVZFtplvcdYAKsi20y3uOsAFWRbaZb3HWACrIttMt7jrABVkW2mW9x1gAqyLbTLe46wAVZFtplvcdYAKsi20y3uOsAFWRbaZb3HWACrIsgAAD+/vg0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABfHo1WqEEBmw+gg64h70lyVvjr1Xh/cTEF9AACf53BadK07ElJI1MfDorS509943sSC6pyynp8V4F6KlPJCllA+ZwsjPDCRAhyCEE5x7ipAAKiikxmWgjuKFWqTEuCdQ2hwXtYZDjz3NeGKRHOBSKNq+Q6reeeBeguByPfs6PaUUBBhZ+w6AfZyPTRJ7d5jskAA0lbJ5qF4OKFT9vzM0h1NauMvrudPBn06AwS41HoD5nkQaVycqBrrbPGtWXpBiIRCyLxNw3TAw1HDmKlnn/gaSwAEG8dVw0YRdkvEjBdVjOWoQy904XZSXZGNJtRWZISFkvcNQACrl63Ao3oQPf2qLhNegMlKATOnlhEqWTsAAC6j0zN5aS94U0483cR89P33Vo/isPu90c6SSxS5FdFIhUR9nvVSi1JCgSMikVWSxbMgJinMWv1qHTCkI53odvfcbpW70UaAAMhA2ECdQwyG+OU6tjEffusNhH1piRijXoY36F84cTlDpP/+AT14XYyUM6ELGCp2ojGzi2TkQ6sFN7Xme6JHt0/B3QIAAEadOODYGNj2mVDRURMv882i3FZOdA94JKbwQK2lX+78ikACA5m06hvrNTmvPrrvdlf4gulYHOHBBnmpGkAACvR50Xf3i/ycV4HzwxsRLpTarcMxuxILueqabxEuVZgv5A7Jls7gHiJurs5zRbDSwzuvSC6WTFjwnE5ueWWPp88Th4d3BEh0/5rURwAAELd1LU0Jua9s+a8uRFnT8xjThgRGSLx4D/SqQ88GBqtSBTt3cZ4NVv8M6Oe4ZHwYV2gvVYC5Gr1UrLmKFj9b49v35W8FQQYwdLaAAM+aX8vSy/zXuVf/p6IV9vhDNUJxlaVmTb7P+vwBvHZtp5yQzLrCTiIiPgxN3hLvvCssULCe/Ei16648AK+VqnVJNHFReGmIWqSQtXZlLKZLnQKvkMB2BsAABIhHKzO0WWsBb8+5xH74101eeX01+a/VIv/LmgSiUzXnCH8Fp7FCTpaHecpaN8Fxl9JxXenvi1pWL9r7EWrX0HTYsB8k81ldw0xRGABGLgABzrTEIZEgcw3LiPowk3QOHuSudJJU5LJL8FS+OzYDOpLSsDHlED47DyrksHNAPHxhTEjaoL3Da3sN3+IAeD0Qk5BeNizdxHaGBgDNsJxOPwEAAF9EliVL+zFKkoiBcTMq4j6/j6y4ji7aUjnLnNlXm+wRJnLEwV6FzOFbAITTUk/0105IVV9R4D4sEnpwSP7MzH8h18t7+B82AuiWlBir0BoAAAWxVH5m+6x2FoaXplh4LrYUUi8eZ93509+jv8Qeus32xweqm3VcjwsvBNLymbahDTeoFxvBfInyFfP2qLS9kfvvz8+F6pmZQLXTdra07FTEKG2VBLUL6gAAjCL8oiKjxO+/51Kap0vWe1Zp5/L8o579PTnTwed/BOwMK5uwuL9PsBoAEZ2y4TW++qmINLDGAyWYFaSx1lnL7z3HmmEE046zg0L0gywzLy4qZJSFX1Lg5gAAIe7/eDHAjWV+76sHmv1tzE/XCPYMQgybTVntmSltBrMUpn63EtKKKjaqqv36vBZKNNdshtfi6XHLKfyYyDhG5M7rqw26/E3ubr92Sw9k0Qj0gAADajcf0Z8F0xVOitQf3taIjyMWvKpN1/Q6ZlV9YMiLVhsToA5R7oId+nzYfXPGrfi2Z6nLlarQRuE02E1iWzczYoxI3ty83trGUgAAQic95jO6+RiwfTJy7GvwixH6eIxz/Z1bB0fuSF7jCot4YAhM7NBX41Ldzx5soNnhh4L7Jn5U6nZOzmDM2fNCYeFSJ6uaiZSAAAGZHaQLARNeeLTVBl/YAZA/gAlEcrVPX3oN1mYDNQvUUe4x/2SxesO8P7EgMjkok1JDV0j/74I5GkznpFfYOk+wdQv0+G8KYQf+icquiIX0RhgkBZQriuXAACWJIWJlhAgSzEx3jnT2eKNiQY8vh/MJevRr83VSqXotYv3BhmTjoz9k5iR/OnpAUcBJeTj36CRV0SxOVj3hTZUJE1sP8rl+B9/uXvVH++e6pbqEoY1D8fjpf/iurXenvdyF9fdE2v5vS76jp7TZo+QQ+LQWX4Wkl6Gy+gkrKWXTJ12uhYpdsCQaUuJnmNLdsC4mGQnLPj7tpfQeU4w9fdWX27Z3M3xGouu7o/3LJMZjOOQ8NcTAFWfk0tH7IdgL+wC1zp+sYFk7h2LaRv4zFr0f6FN4QEwTi+BO0smp4gxYLGBE7dNXnzFFhCQHsMscq+M4dvdSqR+G63VILrAUD8zXM1Cl7GPgzeqFgnnTSmO/o4sz3Z3U7DhRGuLUmle+PvZWW6ZnJpvSz9lloqnH8yhNI8ct+Ec+GQPSv8C8Lv0PgBUNyoI9gtvWCdLjGnAwpZ5o+nX98MNTOXI4eLgtzzUxr+p5bxKCWsPKMuYE1ym+hL8kWVhegxi1N4W4/g+MT9r1ndB9XkgA6d63be8tJQX8vSgeguyYo0+tmkOprU2deobrUxIFrpwrJIUCRkgApDjyIc78zUFTSwiBCqf9PNEaj4aNUm0tSFrE61h1ZFePB+SM9vW8USHyjbztYLihXZNMYGpyF/MpAmfHl+/0xfuPgDt2HMAGxhMeQuwxNONpxV5y/uRap/4LH3R/lRie3COTaD3qohK0+ZTkdkRmAqqQShzlRew3qA3z6rVBfHYC0czXrccaIsY8+yc2//ccjmCd9jgnyFhekMF8kSPPrE4AYCv/4icvp4FSlOLdjUKFDjuRmckQCC9UCEz2stNApzttq5d0wW9QY6ZdV7yLxUzasECslsWqoNM14ikcPZZ45CcqLRn/6geMZgMuGOH9aG4Ey53HsCMJulAjWdrEc6Y2v0yoo6x5t04Yq5biV1kUq+rADpIJXUTiMtumJHFjAG8HRgSVUnUV59wisiaLV5Nc/0lp59n03uPKxRJew/Z5A68DSqvIUn2ATqvMt1PtcH6MZxKYVOJEEaUCS1oCIoIGo4SjXyjMIKRPsCuNOlSfEtUzwNTiAPKPJheQnqYUfA4fTLEFBRi2KufM6fj/byKmnqNY9oJm+7gR362lGwvUHDxMMl3Rwx4HKi7R62rISZFgJxERMCOLj+Efe/Jeev6ktFfYrY0CjNHBAzo4/o4XrNlkY1oE8kaOWGC/KIkW7Ps5/5sbBOCH/uFZm7yTj0zJ5Q0ayBENmwmuKADXgBmorfBH4hGbFSZETxooOWxeZD193LZJckHMx3U4PM8KAnLpsqd4/1hBuhLUzDByXeaxrfuPdaPINqs0PkIgNVb9tm1F581GP+2pmeSTTAhLnBY9IFdwZKFEaN+ojlYpQ5SvY1std64pihP54OED2kIuD52Sl4j9yNwoj5wCeDXnDUhO6NIbb1y+GcU8R9++9YTUVNnxaVIKKK1jWz29Z20xANXVCQG/6WY+VWgFTM+DwioqumqbsUFokMOcypffFxRgrXHD+g5/9gWRJHWyMIIBZpGJ72FJmJDGn1j44rPILFz2dtDDLl2GJfkhpPgMiowqzigfh53A2cUWTgHdmDt9V9cJf6/DCC7BgziKO7CFy/UIHnCmxKp/61g1WuFj+rAKgAzSybTBwUsnnNm/SsuoVRsjelVq9H8eAqBHltlY6P+Q82b9SyOWqNd2f2xlQKCknBvjg/rDwyclhdyUYkF1q2dDAHegSwYuu5Xq4oEpw+zT5ejb/EcUjxavoQdSIr6ZOyB/k8rgyf4LboqX6Jb6oTlJBvk8LO8qUJDdkbaIgdPNo8wKh1YVABlsl5wafJqV040WK2mGLwW05s2f9INWWYvf5t8DcslvS2y4+VAAMTJosdyBGFMnGsiH4y9i0yKVAvBXfbdPvpB5u0NvkXrrgjiMo+eF3hUmYB4OHTbwQOZdQ5fzpGiKlYBTuhye/OQ05D5HjETxIQkY0TwNiP2ssRExU9lrOOzUs4uzPFBn/X8bNyl/BX/l+ujvt75hiumOrWKxFtb9NIE0q99SBVQpMbVyz53o/do7N3vp2hvk/4Aaq3yYsJaLoo5ymxbL+GNLTXfUMXYmCoUvV9D5tayX0BTgby+2m2JHnk6mWYG5iFsf89WScDukTxZo0EA7ltfQjRwoL/0uJRXoG3R51dPlHtemH4Js4ppDFgLW6yDWNBQ0/QMgXOFO9BuMisCL4asCfM2h52A6YRT0TiUmYLFmLmXgw2yQTTNLZSAE7g6zR5uBqw9nj2dWkgq+dBdy4Qy4uiexdty8uybwzFz7KM1/jFTFG+DI11UUG2fPDRYuQ6Qb0t+YeGZPfa/RAuw9ZOs1k9dpgSFR8qnAV4dPZf/OsU5/A6M6DX/nZNM0TBV1JMn4/E3S/8g1BjpLnMVH/ANIjEjfoELRVsMshD4BACUJlltMLIEaUsS9+/IgjzOp5YIWhXKuPAcj+bGR3adpotmG384L8ZICEN2dNUaP6rUlsv4sDJVvYAvlNPEhDZsE1PT/ipILdy2O8ElsWvQtNrL2qiGAACZS8j86dg+J8I/Lmg2SYD9tZMQ7SMP+D9ZVcZu2Vwz7AgY5kNNSby5g9xoPgGt8tiZ6wZF86WOp/fmAx72VCjBploD8hJLig/qDTf3EQQ/K5BNftGwVM4i5pJBHkgkqvzy8aUpM7n88HG2sGwhKnFr1t8Zv67fmqjLEExMZZvEXBv97fCQil4gkucduy9K7hs+XNgvKjuAa26M5Nub775j2Hl2nY1ggAE8+aksQoF9AdIdILfUQfbEbTnNSjE34Sby3UXz7EM8D3hMV6+gd8R/7flA19FH5fXL5oSFHiW4poY2HhJlVF5O0pa50/JGXiRBXYAeBx3VplnSSN4dzJCc6CMg/AGdUtPvt+AhJV3EgEw1mdUyb7KzOWnqbWzHSyGKfZ/xmCEqilPyugJDh9cqOqBAdNaFpPB2mEUrfCLe4GC9C3/cMXnoVR+Ud8AGCiEIY6RbmoF/qBMgBtHh+VKqpt5JyU5d3kBYzdZ07f+aGjiwhxpRQwHZMqM0A3hl+K7v6o308kMd1GKegKJzpoMMx9CEcL1RQ1Wyu8mDR5P6+QnxuHJgFMng6LA9clKlC+i9Q73lo1GjdevFg1IISL4ASn7WgPynTIpT11GSqGoC9YKt3wn/VQySZcj4aesFDmDS4LdETqlpssPQxKiXUViRUOlsaL8en74AAYy+Jh60x+G30fvfOpS4lWZQZs8a9sjFCMObptKCOatbyCBQHi9gMF/tQxbads0G35sXmJCvN5VuLgpzj7yWymjaYdF94Qn5ZCwiRhkkaUfhi4avwkEgEw1h01BpAzbKjJIe4abEg7wgPVxXu59ip7h28jAQzsCOHEHFZw1ZcnX6PYgX8bYzjzbxhf0bBxw7qAprkE+PQdk/O/aYPMbGXV3A0refUickCkAalpdWjPXcWPTJAij4KAtdSUsi5J1nh12dcvYrNCsTh5KgUyLwke5gKRqlJATYWBhTe0msLaQC7NuFbF3bVx8oBsOzw4pfOq5dv32W8GZ9xwr2rBIZLX9nwlosSR2RSTA8oCclgcTdv9JABnYwYw2cI5Wuem97We1SiUaYhMl8etQe9yZB5OQJOkc5f5uEATUZ7X8FP7rYAT3BWJIpOgVwxjcLMF2E5H1bL/zFT+4dW/9g2uTbfyodBYcl2kPdmTbCPXZxjz1Fs0kWgljNpXJM8z9UALUZOkOZD4eHT6I+bkWiHJO32GoI4DBGxLuQyVM85RTLzFqNyMHAfB9wq/tFxZZ8h1yMHWbl4DPaXEjLsonlSlAfDAcaaHBTtrYoleml+J/B/PsKVV6T5B6J4q7LBd6Uj9ANEmyFow21xvKq/PlFANNFoCOlAd1f3ehpklEuFxwFCaEgaClWZCCBabhkwaNIeiTMM/FMnVhz1e+TwY3l6wom0tfwEehsqgS8OU3mxSbMsJvrM5/t3c57alF6ROddv0y9vg1WY/+5pemYpwG+kPmXt8ntU3aa4GdpURkUhgxUYUrSCgUGD/gNrQSrQvawa2YBAgj36/nG4xCOp48cbVAofdsajljTUraBkcuzxD0eUJZuTvhUyuERgakIkyOwClvGk4gE87teCGf27NkLYXeT0oWcVKJxxv5KHapxHzBmorVOyy4haQgtvoKxyZIo86lYUPlKXlWgrfAHJ40RAXyKs7AFE230Cug+bpWgH5nxZ5ccjCcb5d/3q12yASfg/ffIdPax93xL0541Cr0lDpM9YtBrfkzwI6Lh/ZHt05vr6k8GGRMT7HU8OpDJ2akZ9jY2TD+zLKrzT5M8dkBuoKXc243IVTV9uDcKfUGCbG6augo9b1QADEiB7MgP7Zhlp0YZoC8pIFGa29Y3Sj/8DfzZWJEeHSKamIKPE4b35bOfeT/zk+TcfF3aAgpp45dB+BGtnYbg0NbMPNFYrSlBaFu/RFm9W8J8LOIa2m/F9281OEd1YM8I5qXDudOuWy0QByZ36qb4heKcQdnGnSGlaS+A0xPRKX9xYh+GNCwufc8rHFiicUAxrJEyxTnfkvfciJpu9AndFI+oHht3uhtQ5UyPp/lLsc/H0jsPoA+FwmN/iw/BUMK/QvEwBOmCoYWePv06979YbBYHV4mEF4Ou7yJgjKgrAFxw2RA+ODciwbNAsFS5GP3Iug2lvTOgPCYK/X12eATCq3y89kFYEJNcO8ALhXVSQn5WJE+yRlGggLAKc1tyQhiWBjJZDVWmCKVzAiCitF01mGgABL2roAPxrZQbepNWbCf3NZptt/jBqO3dnL5RHsyNGKTYK5wXML+fn2APr8LqO3VLygNHVhDoSdF3ebVVqDOycjszIMCSAN4QgdxWamYNX/mBE1sa+1RuC48ieI7CfPcaZYWhB2IU+rYcmbAwG8aII37LJUx4j+AKGgduIAAX0Mz06yYauFthiMIVrUpIOgSIYXDASo+sK/hioFS4K0wknpAZLnTRvU2GXAk4inmkRXfAesNUxa5PUO+Leiu337gAR2VEeohR+/N7IhjMMafSCFbnte8BGOsjhflHSSTSUc/ulN2+RL/vFz5ZGSLqxzlEMzmAL5t+KikmSaffuVbvI9vjy4scyv2KaDD5pNnm788s+MebClikienQik+7xZ788TjFteugWi1ccAIK6yjN11O5lw6v2AAAAGJ32hZMTHSeJ44Y56KYYa7L40MQLBwz0SPoOKcmC0nbwqyRFOxrnhwv8NCtzBcXDXUjgkTi4fuTL0chIGRakxf2pULYfVdmApNniG63wSOip96UC0oEvL+fGPDWw1Zqb8uQ7DbvbaRhUi67odZpc1PzZfRfrkowuJr6mMZFXsuFxRexhgAABk5aXtTtVjJGUK/a38FYpsvNhLyjq7CSw0uQnvYHGDUiVJOfvAGI63U5XRVlGWMkdWH/M2IneT8plgflxo2tMNMqYm9yXT51euocO8D9nqUO3+6K0MPGPsmos5cHweU2uqkG8rABgli/7TxIQIi27tJmvX5uov05LFM8iANI8qmQApgAAITXce16N/AkxVkmgCtVnE9UAipCYxfnqdwNvpT8C+JH05xsH5LsBAXmU0i/MuRijRxNpfM7RHgvR16Ld/RjznjIQYitAj0hTDSCG5nP36xqImNHxgHwj8F7NtcogFONcfyxHkfEG0Blg5ONohHKvnpGtGSTJ9ADGvkgxL+MQR8T0lStQetBT1PwX4Xtl2SuFhqNU2mXpWGbIlwMu6p0KotPM3BHCUeHxyypAP+gSSF/9ff/Lm2yYRn4jvy3EOXpKP/VY0bW8dKreFg6NQBVu8+HpYdZFjsGI7+kTLGRvqqFOKMr19wsGaceIR768SEOk7pVqdFjVhXgIpvQAAjByq1XyhLmSs/ikBzsNW+xjAnWAHUMlIAaLBAPU/I8P/dFGOTMx593nJZbghrWrRape7mLreN8Ym/QiSpS6Se4n19VMBgGAnR4SJTyX1YNnpknZj0qZvDKOY8gcO2WbD/sA7HG+5ymTF0y8A2BbdVmHwYT4nXtXnAgVoAk8cBTIxSlM3tL9FKhdkshlwBqORG4SU4lAuVk82ehQGF152Ik9v3OPxDxPmZJ9+qoVyyGDVtYFswXmspOIOTAG61l1xju50rmg5YEXqzN254cRbq4G1e6FJw9Xcpmr5U+4wmi7iLz9rJ1MIOhH0WwMulyXFaoK0owykFicvxUd1IyFExskXAAAMLz4sPYWYfFf2H3Ts02LkpEL8A3hGD3R3Q4Fyi13glag8itCkRCkR2JDKw6qpjqhgxjaBTkXmq7xZEyyoMq3VRkNkDLFaSC5UsfI+4j6r6UUGE4yIOlSRLE9o30xw6OOPELMRA6mU5iB5sgDZEdzkNSgs7VDzQn3UBedMiRCfHtX9mTwVXVgACKYxm1PQKU1PQL+aHFUuudAJeNRH2yL0dtQC3WM4F0wgotRlV7O8b6F7oCyrI69flVrgFbzx7PdH6mAnaJmmL5IpmonB616pDzjAIdj4UuLM4IkGS/2jxcTMu+meYwdMnG1m3XU9YPP3tj/eXZZsyYyxKGiMQu+FxIJ0NMkTcHUP6LMyPYSAdLCkKQpCkWVC8LwvC8LwvC8LwvC8LwvC8LwvC8LwvC8LwvC8LuXzg1QJxSlAnGYBt8/cbRwB0XH5wqgzEY955PAuN1KytgX/OpaX1LNpmVr3bVYSTPmsHFAiObwAnndvwM8ZSVdbK4RrS0r3eBr1csii5i4Vx1P98prRguOg1Yk8abyjCD/j7mas138VhJtGRYmjtgSXc61bfCoibuC8LwvC8LwvC8LwvC8LvZkSI21e1gqW61Ugv0W+r4uRtu70mWRp61f087yUEpwYIuJ/2+0cBPv4wKDaxfXopecGjS0fyNqvrKI+wZrDxVHGQgFNTydACZKDyEAAXz1EgbgASXyYAAClosiCOgAAn8npeWHxUAABagAWoAEX49CAAC0mNcAACwAAXGLS3TgAAjvAACNYuhPtwWBw+AAgsBhLAAC1AAjAToG0CZ9aabWAADZZZvA5h0lM9bfQAr9O/zyYp8AGEACIwAkT/KMu3cRm6UcQ7NiYcmF3dzEYKqWBFolt0SWt3WPPeYCRUD6OLyV7b0TJQbF8swRO+MdZ+RZ2OvAHG7CwEUynk89SBKTdmVIM2z0ymmwq7YTBHC2lAAdW9VaEbFuxkLXhdS7U7FlFwqTo7HlLJpq1KZjlXiCLO41sHgQ+A0mjMMRTmpwAFOoATKEb6VbXCC2gBD1tvg/hszpvGOdF/p/w9PTP0wQCQRYv3Tj04eN6fE1cuqOzpwm9RDCin7jzV106AdAdkAAIgI+FD9puj1LRQtROH+isuZksT6xwh4D9C6tTbDQub6KR2o+TAAAdWwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==" alt="Ampacity Logo">
      </div>
      <div>
        <div class="logo-text">Ampacity Renewables</div>
        <div class="logo-subtitle">Solar Education</div>
      </div>
    </div>
    
    <nav class="progress-tracker">
      <div class="step active" data-step="module"><div class="step-number">1</div><div class="step-text">Module</div></div>
      <div class="step" data-step="string"><div class="step-number">2</div><div class="step-text">String</div></div>
      <div class="step" data-step="tracker"><div class="step-number">3</div><div class="step-text">Tracker</div></div>
      <div class="step" data-step="combiner"><div class="step-number">4</div><div class="step-text">Combiner</div></div>
      <div class="step" data-step="cabling"><div class="step-number">5</div><div class="step-text">Cabling</div></div>
      <div class="step" data-step="inverter"><div class="step-number">6</div><div class="step-text">Inverter</div></div>
    </nav>
    
  </header>
  
  <!-- ===== LEFT PANEL ===== -->
  <div class="ui-panel" id="left-panel">
    <div class="panel-header">
      <button class="panel-hide-btn" id="panelHideBtn" onclick="toggleLeftPanel()" title="Hide Panel">
        <span id="panelHideIcon">◀</span>
      </button>
      <div class="panel-title"><h2 id="title">Solar Panel Module</h2></div>
      <div class="panel-subtitle" id="subtitle">Step 1: The Basic Building Block</div>
    </div>
    <div class="panel-body" id="content"></div>
  </div>
  
  <!-- Show Panel Button (when hidden) -->
  <button class="panel-show-btn" id="panelShowBtn" onclick="toggleLeftPanel()" title="Show Panel">▶</button>
  
  <!-- ===== RIGHT PANEL (Learning Path) ===== -->
  <div class="energy-dashboard" id="learningPathPanel">
    <button id="hideLearningPath" onclick="toggleLearningPath()" style="position:absolute; top:10px; right:12px; background:transparent; color:#556; border:none; font-size:14px; cursor:pointer; padding:2px 6px; transition: color 0.2s;" onmouseover="this.style.color='#fff'" onmouseout="this.style.color='#556'" title="Hide Learning Path">✕</button>
    <div class="dashboard-title"><span class="step-indicator"></span>Learning Path</div>
    <div id="stats"></div>
  </div>
  
  <!-- Show Learning Path Button (when hidden) -->
  <button id="showLearningPathBtn" onclick="toggleLearningPath()" style="display:none; position:fixed; top:90px; right:20px; background:rgba(15,23,42,0.95); color:#94a3b8; border:1px solid rgba(56,189,248,0.2); border-radius:8px; padding:12px 16px; cursor:pointer; z-index:100; font-size:11px; text-transform:uppercase; letter-spacing:1px; transition: all 0.2s ease;" onmouseover="this.style.borderColor='rgba(56,189,248,0.5)'; this.style.background='rgba(15,23,42,1)';" onmouseout="this.style.borderColor='rgba(56,189,248,0.2)'; this.style.background='rgba(15,23,42,0.95)';">
    <span style="color:#f472b6;">●</span> Learning Path
  </button>
  
  <!-- Detailed Component Panel - slides in from right -->
  <div id="detail-panel" style="display:none; position:fixed; top:0; right:0; width:480px; height:100%; background:rgba(15,35,45,0.98); z-index:1000; overflow-y:auto; box-shadow:-5px 0 30px rgba(0,0,0,0.5); transform:translateX(100%); transition:transform 0.3s ease;">
    <div style="position:sticky; top:0; background:rgba(15,35,45,1); padding:20px; border-bottom:1px solid rgba(255,255,255,0.1); z-index:10;">
      <button onclick="closeDetailPanel()" style="position:absolute; top:15px; right:15px; background:transparent; color:#888; border:none; font-size:28px; cursor:pointer; padding:5px;">&times;</button>
      <h2 id="detail-title" style="margin:0 0 5px 0; color:#fff; font-size:1.4em; font-weight:600; text-transform:uppercase; letter-spacing:1px;"></h2>
      <div id="detail-category" style="color:#4aa; font-size:0.8em; text-transform:uppercase; letter-spacing:2px;"></div>
    </div>
    
    <div style="padding:20px;">
      <!-- Main Image -->
      <div id="detail-image" style="width:100%; height:200px; background:#1a3a45; border-radius:4px; margin-bottom:20px; display:flex; align-items:center; justify-content:center; overflow:hidden;">
        <div id="detail-image-placeholder" style="color:#4aa; font-size:0.9em;">Component Diagram</div>
      </div>
      
      <!-- Description -->
      <div style="margin-bottom:25px;">
        <h3 style="color:#4aa; font-size:0.85em; text-transform:uppercase; letter-spacing:1px; margin:0 0 10px 0; padding-bottom:8px; border-bottom:1px solid rgba(255,255,255,0.1);">Overview</h3>
        <p id="detail-desc" style="color:#ccc; line-height:1.7; margin:0; font-size:0.9em;"></p>
      </div>
      
      <!-- Key Specifications -->
      <div style="margin-bottom:25px;">
        <h3 style="color:#4aa; font-size:0.85em; text-transform:uppercase; letter-spacing:1px; margin:0 0 15px 0; padding-bottom:8px; border-bottom:1px solid rgba(255,255,255,0.1);">Technical Specifications</h3>
        <div id="detail-specs" style="display:grid; grid-template-columns:1fr 1fr; gap:10px;"></div>
      </div>
      
      <!-- Additional Images -->
      <div style="margin-bottom:25px;">
        <h3 style="color:#4aa; font-size:0.85em; text-transform:uppercase; letter-spacing:1px; margin:0 0 15px 0; padding-bottom:8px; border-bottom:1px solid rgba(255,255,255,0.1);">Installation Details</h3>
        <div id="detail-gallery" style="display:grid; grid-template-columns:1fr 1fr; gap:10px;"></div>
      </div>
      
      <!-- Did You Know Section -->
      <div id="detail-facts" style="background:rgba(74,170,170,0.1); border-left:3px solid #4aa; padding:15px; border-radius:0 4px 4px 0; margin-bottom:20px;">
        <h4 style="color:#4aa; font-size:0.8em; text-transform:uppercase; letter-spacing:1px; margin:0 0 8px 0;">Did You Know?</h4>
        <p id="detail-fact-text" style="color:#aaa; font-size:0.85em; line-height:1.6; margin:0;"></p>
      </div>
      
      <!-- Related Components -->
      <div>
        <h3 style="color:#4aa; font-size:0.85em; text-transform:uppercase; letter-spacing:1px; margin:0 0 15px 0; padding-bottom:8px; border-bottom:1px solid rgba(255,255,255,0.1);">Related Components</h3>
        <div id="detail-related" style="display:flex; gap:10px; flex-wrap:wrap;"></div>
      </div>
    </div>
  </div>
  
  <!-- Overlay for detail panel -->
  <div id="detail-overlay" onclick="closeDetailPanel()" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.5); z-index:999;"></div>
  
  <!-- Label container for 2D labels that follow 3D markers -->
  <div id="labels-container" style="position:fixed; top:75px; left:0; width:100%; height:calc(100% - 75px); pointer-events:none; z-index:50; overflow:hidden;"></div>
  
  <button id="toggle-markers" onclick="toggleMarkers()" style="position:fixed; top:20px; right:20px; background:linear-gradient(135deg, rgba(56,189,248,0.9), rgba(20,100,150,0.9)); color:#fff; border:2px solid #38bdf8; padding:8px 14px; border-radius:25px; cursor:pointer; font-weight:500; font-size:13px; z-index:1000; box-shadow:0 4px 15px rgba(0,0,0,0.4), 0 0 20px rgba(56,189,248,0.3);">
    🏷️ Show Labels
  </button>
  
  <!-- Site Generator Dropdown -->
  <div id="site-gen-wrapper" style="position:fixed; top:20px; right:170px; z-index:1001;">
    <button id="create-site-btn" onclick="toggleSiteGenMenu()" style="background:linear-gradient(135deg, rgba(16,185,129,0.9), rgba(5,150,105,0.9)); color:#fff; border:2px solid #10b981; padding:8px 14px; border-radius:25px; cursor:pointer; font-weight:600; font-size:13px; box-shadow:0 4px 15px rgba(0,0,0,0.4), 0 0 20px rgba(16,185,129,0.3); transition: all 0.2s;" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(0,0,0,0.4), 0 0 25px rgba(16,185,129,0.4)';" onmouseout="this.style.transform='none'; this.style.boxShadow='0 4px 15px rgba(0,0,0,0.4), 0 0 20px rgba(16,185,129,0.3)';">
      🏗️ Site Generator ▾
    </button>
    <div id="site-gen-menu" style="display:none; position:absolute; top:calc(100% + 10px); right:0; min-width:310px; background:linear-gradient(165deg, rgba(12,20,38,0.99), rgba(8,14,28,0.99)); border:1px solid rgba(16,185,129,0.25); border-radius:14px; box-shadow:0 12px 48px rgba(0,0,0,0.7), 0 0 30px rgba(16,185,129,0.08), inset 0 1px 0 rgba(255,255,255,0.04); backdrop-filter:blur(16px); overflow:hidden;">
      <div style="padding:14px 18px 10px; border-bottom:1px solid rgba(255,255,255,0.05);">
        <div style="font-size:9px; font-weight:700; color:#10b981; letter-spacing:2px; text-transform:uppercase;">Choose a Tool</div>
      </div>
      <a href="solar-farm-v2.html" style="display:flex; align-items:center; gap:14px; padding:16px 18px; text-decoration:none; transition:all 0.25s ease; border-bottom:1px solid rgba(255,255,255,0.04);" onmouseover="this.style.background='rgba(16,185,129,0.1)'; this.querySelector('.sg-icon').style.boxShadow='0 0 18px rgba(16,185,129,0.4)';" onmouseout="this.style.background='transparent'; this.querySelector('.sg-icon').style.boxShadow='0 4px 12px rgba(0,0,0,0.3)';">
        <div class="sg-icon" style="width:40px; height:40px; border-radius:10px; background:linear-gradient(135deg,#10b981,#059669); display:flex; align-items:center; justify-content:center; flex-shrink:0; box-shadow:0 4px 12px rgba(0,0,0,0.3); transition:box-shadow 0.25s;">
          <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="#fff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <rect x="2" y="6" width="6" height="4" rx="0.5" fill="rgba(255,255,255,0.15)"/>
            <rect x="9" y="6" width="6" height="4" rx="0.5" fill="rgba(255,255,255,0.15)"/>
            <rect x="16" y="6" width="6" height="4" rx="0.5" fill="rgba(255,255,255,0.15)"/>
            <rect x="2" y="12" width="6" height="4" rx="0.5" fill="rgba(255,255,255,0.1)"/>
            <rect x="9" y="12" width="6" height="4" rx="0.5" fill="rgba(255,255,255,0.1)"/>
            <rect x="16" y="12" width="6" height="4" rx="0.5" fill="rgba(255,255,255,0.1)"/>
            <circle cx="12" cy="3" r="1.5" fill="#FFD700" stroke="#FFD700" stroke-width="0.5"/>
            <line x1="12" y1="1" x2="12" y2="0" stroke="#FFD700" stroke-width="1"/>
            <line x1="14" y1="1.5" x2="15" y2="0.5" stroke="#FFD700" stroke-width="1"/>
            <line x1="10" y1="1.5" x2="9" y2="0.5" stroke="#FFD700" stroke-width="1"/>
            <line x1="5" y1="18" x2="5" y2="22" stroke="rgba(255,255,255,0.5)" stroke-width="1"/>
            <line x1="12" y1="18" x2="12" y2="22" stroke="rgba(255,255,255,0.5)" stroke-width="1"/>
            <line x1="19" y1="18" x2="19" y2="22" stroke="rgba(255,255,255,0.5)" stroke-width="1"/>
          </svg>
        </div>
        <div>
          <div style="font-size:13px; font-weight:700; color:#fff; margin-bottom:3px; letter-spacing:0.3px;">3D Solar Farm Generator</div>
          <div style="font-size:10px; color:#6b82a8; line-height:1.4;">Configure & visualize a full solar farm with waypoint navigation</div>
        </div>
      </a>
      <a href="hsat-site-designer.html" style="display:flex; align-items:center; gap:14px; padding:16px 18px; text-decoration:none; transition:all 0.25s ease;" onmouseover="this.style.background='rgba(0,180,220,0.1)'; this.querySelector('.sg-icon').style.boxShadow='0 0 18px rgba(0,212,255,0.4)';" onmouseout="this.style.background='transparent'; this.querySelector('.sg-icon').style.boxShadow='0 4px 12px rgba(0,0,0,0.3)';">
        <div class="sg-icon" style="width:40px; height:40px; border-radius:10px; background:linear-gradient(135deg,#00b8d4,#2962ff); display:flex; align-items:center; justify-content:center; flex-shrink:0; box-shadow:0 4px 12px rgba(0,0,0,0.3); transition:box-shadow 0.25s;">
          <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="#fff" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
            <path d="M4 4h6v6H4z" fill="rgba(255,255,255,0.12)"/>
            <path d="M14 4h6v6h-6z" fill="rgba(255,255,255,0.12)"/>
            <path d="M4 14h6v6H4z" fill="rgba(255,255,255,0.12)"/>
            <path d="M14 14h6v6h-6z" fill="rgba(255,255,255,0.08)"/>
            <line x1="10" y1="7" x2="14" y2="7" stroke="#ff5252" stroke-width="1.5"/>
            <line x1="7" y1="10" x2="7" y2="14" stroke="#ff5252" stroke-width="1.5"/>
            <line x1="10" y1="17" x2="14" y2="17" stroke="#00e676" stroke-width="1.5"/>
            <line x1="17" y1="10" x2="17" y2="14" stroke="#00e676" stroke-width="1.5"/>
            <circle cx="12" cy="12" r="2" fill="rgba(0,212,255,0.3)" stroke="#00d4ff" stroke-width="1.5"/>
          </svg>
        </div>
        <div>
          <div style="font-size:13px; font-weight:700; color:#fff; margin-bottom:3px; letter-spacing:0.3px;">eBOS Style Site Designer</div>
          <div style="font-size:10px; color:#6b82a8; line-height:1.4;">Advanced layout builder with electrical hierarchy & real-time 3D</div>
        </div>
      </a>
    </div>
  </div>
  
  <!-- Dynamic Compass - Rotates with camera view -->
  <div id="compass" style="position:fixed; bottom:20px; right:20px; width:80px; height:80px; background:rgba(15,35,45,0.95); border:2px solid #38bdf8; border-radius:50%; z-index:100; box-shadow:0 3px 15px rgba(0,0,0,0.5); overflow:hidden;">
    <!-- Rotating ring with N/S/E/W labels -->
    <div id="compass-ring" style="width:100%; height:100%; position:absolute; top:0; left:0; transition: transform 0.1s ease-out;">
      <!-- North -->
      <div style="position:absolute; top:3px; left:50%; transform:translateX(-50%); text-align:center;">
        <div style="font-size:12px; font-weight:bold; color:#ff1493;">N</div>
      </div>
      <!-- South -->
      <div style="position:absolute; bottom:3px; left:50%; transform:translateX(-50%); text-align:center;">
        <div style="font-size:12px; font-weight:bold; color:#ff1493;">S</div>
      </div>
      <!-- East -->
      <div style="position:absolute; right:5px; top:50%; transform:translateY(-50%); text-align:center;">
        <div style="font-size:12px; font-weight:bold; color:#ffaa00;">E</div>
      </div>
      <!-- West -->
      <div style="position:absolute; left:5px; top:50%; transform:translateY(-50%); text-align:center;">
        <div style="font-size:12px; font-weight:bold; color:#ffaa00;">W</div>
      </div>
    </div>
    <!-- Fixed center arrow (always points up = direction you're facing) -->
    <div style="position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); pointer-events:none;">
      <!-- Arrow pointing up (your viewing direction) -->
      <div style="width:0; height:0; border-left:8px solid transparent; border-right:8px solid transparent; border-bottom:22px solid #38bdf8; margin-bottom:2px;"></div>
      <!-- Center dot -->
      <div style="width:6px; height:6px; background:#fff; border-radius:50%; margin:-4px auto 0;"></div>
      <!-- Tail -->
      <div style="width:0; height:0; border-left:5px solid transparent; border-right:5px solid transparent; border-top:12px solid #1e3a5f; margin:-2px auto 0;"></div>
    </div>
  </div>
  
  <!-- Power Flow Legend (hidden by default, shows when power flow active) -->
  <div id="powerFlowLegend" style="display:none; position:fixed; bottom:20px; right:20px; background:rgba(15,35,45,0.95); border:2px solid #38bdf8; border-radius:12px; padding:12px; z-index:100; box-shadow:0 4px 20px rgba(0,0,0,0.5); min-width:180px; max-width:200px;">
    <h4 style="margin:0 0 8px 0; color:#fff; font-size:12px; border-bottom:1px solid rgba(255,255,255,0.2); padding-bottom:6px;">⚡ Power Flow</h4>
    <div style="display:flex; align-items:center; margin-bottom:5px;">
      <div style="width:12px; height:12px; background:#00ffff; border-radius:50%; margin-right:8px; box-shadow:0 0 6px #00ffff;"></div>
      <span style="color:#fff; font-size:11px;"><strong>DC</strong> - Direct Current</span>
    </div>
    <div style="display:flex; align-items:center; margin-bottom:8px;">
      <div style="width:12px; height:12px; background:#ff6600; border-radius:50%; margin-right:8px; box-shadow:0 0 6px #ff6600;"></div>
      <span style="color:#fff; font-size:11px;"><strong>AC</strong> - Alternating Current</span>
    </div>
    <div style="font-size:10px; color:#94a3b8; border-top:1px solid rgba(255,255,255,0.1); padding-top:6px; line-height:1.4;">
      <p style="margin:3px 0;"><span style="color:#00ffff;">1.</span> Module → DC</p>
      <p style="margin:3px 0;"><span style="color:#00ffff;">2.</span> String connects</p>
      <p style="margin:3px 0;"><span style="color:#00ffff;">3.</span> Combiner box</p>
      <p style="margin:3px 0;"><span style="color:#ff6600;">4.</span> Inverter: DC→AC</p>
      <p style="margin:3px 0;"><span style="color:#ff6600;">5.</span> AC to grid</p>
    </div>
  </div>
  
  <div class="controls">
    <button class="control-btn" id="prev">← Prev Step</button>
    <button class="control-btn" id="next">Next Step →</button>
    <button class="control-btn" id="topview">Top View</button>
    <button class="control-btn" id="reset">Reset View</button>
    <div style="position: relative; display: inline-block;">
      <button class="control-btn feature-btn" id="dayCycleBtn">🌅 Sun Tracking</button>
      <div class="tooltip-bubble" id="sunTooltip">
        <h4>☀️ Sun Tracking Mode</h4>
        <p>Watch the sun move across the sky! The solar trackers will <strong>automatically rotate</strong> to follow the sun, just like real single-axis tracking systems. Lighting changes from dawn to dusk.</p>
        <div class="tooltip-actions">
          <button class="tooltip-close" onclick="closeSunTooltip()">Close</button>
          <button class="tooltip-start" onclick="startSunTracking()">▶ Start</button>
        </div>
      </div>
    </div>
    <div style="position: relative; display: inline-block;">
      <button class="control-btn feature-btn" id="electricFlowBtn">⚡ Power Flow</button>
      <div class="tooltip-bubble" id="powerTooltip" style="width: 320px;">
        <h4>⚡ Power Flow Animation</h4>
        <p style="margin-bottom:10px;">Watch electricity flow through a single tracker row — from sunlight to grid!</p>
        <div style="font-size:12px; line-height:1.6; margin-bottom:10px;">
          <p><strong style="color:#00ffff;">● Cyan (DC)</strong> = Direct Current from panels</p>
          <p><strong style="color:#ff6600;">● Orange (AC)</strong> = Alternating Current to grid</p>
        </div>
        <div style="font-size:11px; color:#94a3b8; border-top:1px solid rgba(255,255,255,0.1); padding-top:8px; margin-bottom:10px;">
          <p>☀️ Sunlight hits panels → generates DC</p>
          <p>🔗 String wiring collects DC</p>
          <p>📦 Combiner box aggregates strings</p>
          <p>⚡ Inverter converts DC → AC</p>
          <p>🔌 AC power flows to grid</p>
        </div>
        <div class="tooltip-actions">
          <button class="tooltip-close" onclick="closePowerTooltip()">Close</button>
          <button class="tooltip-start" onclick="startPowerFlow()">▶ Start</button>
        </div>
      </div>
    </div>
    <button class="control-btn quiz-btn" id="quizBtn">📝 Take Quiz</button>
    <div style="position: relative; display: inline-block;">
      <button class="control-btn feature-btn" id="panelStyleBtn">🔲 Panel Style</button>
      <div class="tooltip-bubble panel-style-tooltip" id="panelStyleTooltip">
        <h4>🔲 Panel Configuration</h4>
        <p>Change the solar panel arrangement:</p>
        <div class="panel-style-options">
          <button class="panel-style-option" data-style="2L" onclick="changePanelStyle('2L')">
            <span class="style-icon">▬▬</span>
            <span class="style-label">2L</span>
            <span class="style-desc">2 Landscape</span>
          </button>
          <button class="panel-style-option" data-style="2P" onclick="changePanelStyle('2P')">
            <span class="style-icon">▮▮</span>
            <span class="style-label">2P</span>
            <span class="style-desc">2 Portrait</span>
          </button>
          <button class="panel-style-option active" data-style="1P" onclick="changePanelStyle('1P')">
            <span class="style-icon">▮</span>
            <span class="style-label">1P</span>
            <span class="style-desc">1 Portrait</span>
          </button>
        </div>
        <button class="tooltip-close" onclick="closePanelStyleTooltip()" style="margin-top:10px; width:100%;">Close</button>
      </div>
    </div>
  </div>
  
  <!-- ===== QUIZ MODAL ===== -->
  <div id="quizModal" class="quiz-modal">
    <div class="quiz-container">
      <div class="quiz-header">
        <h2>🎓 Solar Farm Knowledge Quiz</h2>
        <p>Test your understanding of solar farm components!</p>
        <button class="quiz-close" id="quizClose">✕</button>
      </div>
      <div class="quiz-progress">
        <div class="quiz-progress-bar" id="quizProgressBar"></div>
      </div>
      <div class="quiz-content" id="quizContent">
        <!-- Questions will be inserted here -->
      </div>
      <div class="quiz-footer">
        <div class="quiz-score" id="quizScore">Question 1 of 10</div>
        <button class="quiz-btn-action" id="quizNext">Next Question →</button>
      </div>
    </div>
  </div>
  

  <!-- ===== SITE BUILDER MODAL ===== -->
  <div id="siteBuilderModal" class="site-builder-modal">
    <div class="sb-container">
      <div class="sb-head">
        <h2>🏗️ Create a Site</h2>
        <p>Select your solar site configuration — invalid options are automatically disabled</p>
        <button class="sb-x" onclick="closeSiteBuilder()">✕</button>
      </div>
      <div class="sb-flow-bar">
        <div class="sb-flow-node" id="sbFlowModule"><div class="sb-flow-dot"></div><div><div class="sb-flow-label">Module</div><div class="sb-flow-val" id="sbFlowModuleVal">—</div></div></div>
        <div class="sb-flow-arrow" id="sbFlowArrow1">→</div>
        <div class="sb-flow-node" id="sbFlowInverter"><div class="sb-flow-dot"></div><div><div class="sb-flow-label">Inverter</div><div class="sb-flow-val" id="sbFlowInverterVal">—</div></div></div>
        <div class="sb-flow-arrow" id="sbFlowArrow2">→</div>
        <div class="sb-flow-node" id="sbFlowDC"><div class="sb-flow-dot"></div><div><div class="sb-flow-label">DC Collection</div><div class="sb-flow-val" id="sbFlowDCVal">—</div></div></div>
        <div class="sb-flow-arrow" id="sbFlowArrow3">→</div>
        <div class="sb-flow-node" id="sbFlowCombo"><div class="sb-flow-dot"></div><div><div class="sb-flow-label">DC Combination</div><div class="sb-flow-val" id="sbFlowComboVal">—</div></div></div>
      </div>
      <div class="sb-body">
        <div class="sb-section">
          <h3>Module / String Size</h3>
          <div class="sb-opts" data-field="module">
            <button class="sb-opt" data-value="bifacial-600" onclick="sbSelect('module','bifacial-600',this)">Bifacial 600W<div class="sb-opt-sub">28 mods/string</div></button>
            <button class="sb-opt" data-value="first-solar-525" onclick="sbSelect('module','first-solar-525',this)">First Solar 525W<div class="sb-opt-sub">6 mods/string</div></button>
          </div>
        </div>
        <div class="sb-section">
          <h3>Inverter Type</h3>
          <div class="sb-opts" data-field="inverter">
            <button class="sb-opt" data-value="distributed" onclick="sbSelect('inverter','distributed',this)">Distributed String Inverters<div class="sb-opt-sub">Individual inverters per string</div></button>
            <button class="sb-opt" data-value="centralized-cluster" onclick="sbSelect('inverter','centralized-cluster',this)">Centralized String Inverter Clusters<div class="sb-opt-sub">Grouped inverter clusters</div></button>
            <button class="sb-opt" data-value="central" onclick="sbSelect('inverter','central',this)">Central Inverters<div class="sb-opt-sub">Single large central inverter</div></button>
          </div>
        </div>
        <div class="sb-section">
          <h3>DC Collection</h3>
          <div class="sb-opts" data-field="dcCollection">
            <button class="sb-opt" data-value="string-homeruns" onclick="sbSelect('dcCollection','string-homeruns',this)">String Homeruns<div class="sb-opt-sub">Direct wire runs from each string</div></button>
            <button class="sb-opt" data-value="harnesses" onclick="sbSelect('dcCollection','harnesses',this)">Harnesses<div class="sb-opt-sub">Bundled cable assemblies</div></button>
            <button class="sb-opt" data-value="trunk-bus" onclick="sbSelect('dcCollection','trunk-bus',this)">Trunk Bus<div class="sb-opt-sub">High-capacity bus system</div></button>
          </div>
        </div>
        <div class="sb-section">
          <h3>DC Combination</h3>
          <div class="sb-opts" data-field="dcCombo">
            <button class="sb-opt" data-value="combiner-boxes" onclick="sbSelect('dcCombo','combiner-boxes',this)">Combiner Boxes<div class="sb-opt-sub">Combine multiple string outputs</div></button>
            <button class="sb-opt" data-value="lbds" onclick="sbSelect('dcCombo','lbds',this)">LBD's<div class="sb-opt-sub">Load Break Disconnects</div></button>
            <button class="sb-opt" data-value="none" onclick="sbSelect('dcCombo','none',this)">None<div class="sb-opt-sub">No DC combination needed</div></button>
          </div>
        </div>
        <div style="text-align:center; padding:8px 0 4px;">
          <button class="sb-btn-view" id="sbViewBtn" onclick="openSiteViewer()">🌐 Open 3D Site Viewer</button>
        </div>
      </div>
      <div class="sb-footer">
        <div class="sb-footer-info" id="sbFooterInfo">Select your configuration</div>
        <button class="sb-btn-reset" onclick="resetSiteBuilder()">↺ Start Over</button>
      </div>
    </div>
  </div>

    <!-- Fullscreen 3D Site Viewer -->
  <div id="siteViewerFS">
    <div class="sv-topbar">
      <h1>⚡ Ampacity Renewables — 3D Site Viewer</h1>
      <div style="display:flex;align-items:center;gap:14px;">
        <div class="sv-badge" id="svBadge"></div>
        <button class="sv-close-btn" onclick="closeSiteViewer()">✕ Close Viewer</button>
      </div>
    </div>
    <div class="sv-ctrl-panel">
      <button class="sv-ctrl-btn" onclick="svResetView()">🏠 Reset View</button>
      <button class="sv-ctrl-btn" onclick="svTopView()">🔝 Top View</button>
      <button class="sv-ctrl-btn active" id="svAutoBtn" onclick="svToggleAuto()">🔄 Auto-Rotate</button>
    </div>
    <div class="sv-hint" id="svHint">🖱️ Drag to orbit · Scroll to zoom · Right-click to pan</div>
    <div class="sv-cfg-panel" id="svCfgPanel"></div>
    <div class="sv-legend">
      <div class="sv-leg-item"><div class="sv-leg-dot" style="background:#4a6aaa;"></div>Panels</div>
      <div class="sv-leg-item"><div class="sv-leg-dot" style="background:#ff4444;"></div>DC Wiring</div>
      <div class="sv-leg-item"><div class="sv-leg-dot" style="background:#1a1a1a;border:1px solid #555;"></div>Inverters</div>
      <div class="sv-leg-item"><div class="sv-leg-dot" style="background:#ff8800;"></div>AC</div>
      <div class="sv-leg-item"><div class="sv-leg-dot" style="background:#3b82f6;"></div>Substation</div>
    </div>
  </div>

  <script>
    let scene, camera, renderer, currentStep = 'module', animationId;
    let isTopView = false;
    let demoTrackerGroup = null;  // Reference to demo tracker display
    let demoCombinerGroup = null; // Reference to demo combiner display
    let combinerDoorGroup = null; // Reference to combiner door for open/close
    let combinerDoorOpen = true; // Track door state
    
    // Panel style: '2L' = 2 Landscape, '2P' = 2 Portrait, '1P' = 1 Portrait
    let currentPanelStyle = '1P';
    
    // Sun tracking & Day/Night cycle
    let sunLight, sunMesh, sunAngle = 0.25; // 0 = sunrise, 0.5 = noon, 1 = sunset
    let isDayCycleActive = false;
    let trackerRows = []; // Store tracker references for rotation
    let junctionBoxes = []; // Store junction box references with row info: {mesh, rowZ}
    let redCables = []; // Store red cable references with row info: {mesh, rowZ}
    let bearingPlates = []; // Store bearing plate references with row info: {mesh, rowZ, originalMat}
    let combinerBoxes = []; // Store combiner box references with row info: {mesh, rowZ, xCenter, originalMat}
    let inverterBoxes = []; // Store inverter box references with row info: {mesh, rowZ, xCenter, originalMat}
    
    // Electricity flow particles
    let electricityParticles = [];
    let isElectricityFlowActive = false;
    const flowPaths = []; // Store paths from panels to inverters
    
    // Camera control variables
    let targetX = 0, targetY = 10, targetZ = 0;
    let spherical = { radius: 200, theta: Math.PI / 4, phi: Math.PI / 3 };
    
    const defaultCam = { x: 140, y: 80, z: 180 };
    const topViewCam = { x: 0, y: 400, z: 10 };
    
    const contentData = {
      module: {
        title: "1. Solar Panel Module",
        subtitle: "Step 1: The Basic Building Block",
        content: `
          <div class="info-box">
            <h3>What is a Solar Module?</h3>
            <p>A solar panel (module) converts sunlight into electricity using photovoltaic cells.</p>
          </div>
          <div class="info-box">
            <h3>Explanation</h3>
            <p>• Like a tile on your roof, but generates electricity</p>
            <p>• Made of silicon cells (like computer chips)</p>
            <p>• Produces DC electricity (like a battery)</p>
          </div>
        `,
        stats: `<div class="stat-card"><div class="stat-value">Step 1 of 6</div><div class="stat-label">Module → String → Tracker → Combiner → Cabling → Inverter</div></div>`,
        cam: {x: 140, y: 11, z: -23},
        lookAt: {x: 140, y: 6, z: -27}
      },
      string: {
        title: "2. String Circuit",
        subtitle: "Step 2: How Panels Connect",
        content: `
          <div class="info-box" style="background: rgba(0,255,136,0.15); border-left: 3px solid #00ff88;">
            <h3>⚡ Watch the Electricity Flow!</h3>
            <p>See the <strong style="color:#00ffff;">cyan particles</strong> flowing through the red wire — this shows DC electricity moving from panel to panel.</p>
          </div>
          <div class="info-box">
            <h3>What is a String?</h3>
            <p>A <strong>string</strong> is a series of solar panels wired together. The voltage adds up as electricity flows through each panel.</p>
          </div>
          <div class="info-box">
            <h3>How It Works</h3>
            <p>1. <strong>Sunlight hits panel</strong> → generates DC electricity</p>
            <p>2. <strong>Electricity flows</strong> through the red wire (DC+)</p>
            <p>3. <strong>Panels connect</strong> at MC4 connectors (green dots)</p>
            <p>4. <strong>String output</strong> goes to combiner/inverter →</p>
          </div>
          <button id="viewCablesBtn" class="view-demo-btn" style="background: linear-gradient(135deg, #cc3333, #ff5555); margin: 10px 0;">
            🔌 View DC Cables (Back of Panel)
          </button>
          <div class="info-box" style="background: rgba(0,80,80,0.3); border-left: 3px solid #00ffaa;">
            <h3>🔍 What You're Seeing</h3>
            <p><span style="color:#00ffff;">●●●</span> <strong style="color:#00ffff;">Cyan particles</strong> = Electricity flowing on DC+</p>
            <p><span style="color:#ff4444;">━━</span> <strong style="color:#ff4444;">Red wire (top)</strong> = DC+ positive cable</p>
            <p><span style="color:#3366cc;">━━</span> <strong style="color:#3366cc;">Blue wire (bottom)</strong> = DC- negative cable</p>
            <p><span style="color:#00ff00;">●</span> <strong style="color:#00ff00;">Green dots</strong> = MC4 connection points</p>
            <p><span style="color:#00ff88;">➤</span> <strong style="color:#00ff88;">Arrow</strong> = Flow direction to inverter</p>
          </div>
        `,
        stats: ``,
        cam: {x: 165, y: 14, z: -25},
        lookAt: {x: 140, y: 6, z: -45}
      },
      tracker: {
        title: "3. Solar Tracker",
        subtitle: "Step 3: Following the Sun",
        content: `
          <div class="info-box" style="background: rgba(0,255,170,0.15); border-left: 3px solid #00ffaa;">
            <h3>👁️ The Tracker Bearing Plate is Highlighted</h3>
            <p>Look for the <strong style="color:#00ffaa;">glowing cyan curved plate</strong> on the tracker — this is the bearing that allows the panels to rotate!</p>
          </div>
          <div class="info-box">
            <h3>What is a Solar Tracker?</h3>
            <p>A device that orients solar panels to <strong>follow the sun's path</strong> across the sky, maximizing sunlight absorption and boosting energy production <strong>15-40%</strong> compared to fixed systems.</p>
          </div>
          <div class="info-box">
            <h3>How Trackers Work</h3>
            <p><strong>1. Sensing the Sun</strong> - Uses sensors or programmed algorithms (astronomical data) to know the sun's position</p>
            <p><strong>2. Movement</strong> - Motors slowly adjust the panel angle throughout the day to keep it facing the sun</p>
            <p><strong>3. Maximizing Output</strong> - By staying perpendicular, they reduce the "angle of incidence" = more light hits the panel</p>
          </div>
          <div class="info-box">
            <h3>Types of Trackers</h3>
            <p><strong>Single-Axis</strong> - Rotates east-to-west (common in large solar farms) ← <em>This is what you see here!</em></p>
            <p><strong>Dual-Axis</strong> - Rotates both east-west AND north-south (highest efficiency, higher cost)</p>
          </div>
          <div style="text-align:center; margin: 15px 0;">
            <button id="viewTrackerBtn" class="view-demo-btn">
              🔍 VIEW TRACKER CLOSE-UP
            </button>
          </div>
          <div class="info-box">
            <h3>Industry Leading Partners</h3>
            <p><strong style="color:#ffdd00;">Nextracker</strong> - NX Horizon with TrueCapture™</p>
            <p><strong style="color:#2255aa;">Array Technologies</strong> - DuraTrack HZ v3 with SmarTrack™</p>
          </div>
          <div class="info-box" style="background: rgba(0,80,80,0.3); border-left: 3px solid #0fa;">
            <h3>🔍 What You're Seeing</h3>
            <p><span style="color:#00ffaa;">▣</span> <strong style="color:#00ffaa;">Glowing cyan plate</strong> = Bearing plate (HIGHLIGHTED)</p>
            <p>The curved metal plate connects the torque tube to the post and allows rotation.</p>
            <p style="margin-top: 8px; font-size: 12px; color: #888;">Click "VIEW TRACKER CLOSE-UP" to see Nextracker & Array Technologies styles</p>
          </div>
        `,
        stats: ``,
        cam: {x: 150, y: 7, z: -72},
        lookAt: {x: 140, y: 4, z: -63}
      },
      combiner: {
        title: "4. Combiner Box",
        subtitle: "Step 4: Combining Multiple Strings",
        content: `
          <div class="info-box">
            <h3>What is a Combiner Box?</h3>
            <p>An electrical enclosure that safely <strong>bundles multiple solar panel strings</strong> into a single, higher-current output for the inverter, adding crucial protection like fuses and surge suppression.</p>
          </div>
          <div class="info-box">
            <h3>Key Functions</h3>
            <p><strong>1. Aggregation</strong> - Combines multiple strings (parallel connections) into one output cable</p>
            <p><strong>2. Protection</strong> - Houses fuses, circuit breakers, and Surge Protection Devices (SPDs)</p>
            <p><strong>3. Organization</strong> - Centralized enclosure for wiring, improving safety & maintenance</p>
            <p><strong>4. Monitoring</strong> - Advanced boxes track string voltage, current, and temperature</p>
          </div>
          <div class="info-box">
            <h3>Types of Combiner Boxes</h3>
            <p><strong>DC Combiner</strong> - Most common, combines DC outputs before the inverter ← <em>This is what you see here!</em></p>
            <p><strong>AC Combiner</strong> - Combines AC outputs from multiple inverters</p>
          </div>
          <div style="text-align:center; margin: 15px 0;">
            <button id="viewCombinerBtn" class="view-demo-btn green">
              🔍 VIEW COMBINER CLOSE-UP
            </button>
          </div>
          <div class="info-box" style="background: rgba(0,255,170,0.15); border-left: 3px solid #00ffaa;">
            <h3>👁️ The Combiner Box is Highlighted</h3>
            <p>Look for the <strong style="color:#00ffaa;">glowing cyan box</strong> — this is the combiner that collects power from multiple panel strings!</p>
          </div>
          <div class="info-box" style="background: rgba(0,80,80,0.3); border-left: 3px solid #0fa;">
            <h3>🔍 What You're Seeing</h3>
            <p><span style="color:#00ffaa;">▢</span> <strong style="color:#00ffaa;">Glowing box</strong> = Combiner Box (HIGHLIGHTED)</p>
            <p><span style="color:#a33;">●</span> <strong style="color:#f66;">Red cables</strong> = DC+ inputs from strings</p>
            <p><span style="color:#333;">●</span> <strong style="color:#888;">Black cables</strong> = DC- return path from strings</p>
            <p><span style="color:#ff0;">▮</span> <strong style="color:#ff0;">Yellow components</strong> = Fuses (overcurrent protection)</p>
            <p><span style="color:#0af;">▮</span> <strong style="color:#0af;">Blue device</strong> = Surge Protection Device (SPD)</p>
          </div>
        `,
        stats: ``,
        cam: {x: 140, y: 3.5, z: -20},
        lookAt: {x: 140, y: 2.8, z: -24.5}
      },
      cabling: {
        title: "5. DC & AC Cabling",
        subtitle: "Step 5: Transporting the Power",
        content: `
          <div class="info-box">
            <h3>What is Cabling?</h3>
            <p>Cabling systems transport DC power from panels to inverters and AC power to the grid. Different project sizes use different approaches.</p>
          </div>
          <div class="info-box" style="background: rgba(255,100,50,0.1); border-left: 3px solid #ff6633;">
            <h3>🔌 DC Cabling Types</h3>
            <p><strong style="color:#ff6633;">1. DC Wire Harnesses</strong></p>
            <p style="font-size:0.9em; margin-left:15px;">Pre-assembled cable bundles with connectors. Faster installation, factory quality control. Popular for utility-scale projects.</p>
            <p><strong style="color:#ff6633;">2. String Homeruns</strong></p>
            <p style="font-size:0.9em; margin-left:15px;">Individual cables run directly from each string to the inverter/combiner. Simple design, easy troubleshooting. Common in smaller systems.</p>
            <p><strong style="color:#ff6633;">3. Trunk Bus</strong></p>
            <p style="font-size:0.9em; margin-left:15px;">A main cable "trunk" runs along rows with tap connections for each string. Reduces total cable length and installation time.</p>
          </div>
          <div class="info-box" style="background: rgba(255,170,0,0.1); border-left: 3px solid #ffaa00;">
            <h3>⚡ AC Cabling</h3>
            <p>After the inverter converts DC to AC, cables run through conduit to the substation. AC cables are typically run underground in trenches or overhead on cable trays.</p>
          </div>
        `,
        stats: ``,
        cam: {x: 155, y: 8, z: 60},
        lookAt: {x: 140, y: 3, z: 45}
      },
      inverter: {
        title: "6. String Inverters",
        subtitle: "Step 6: Converting to Grid Power",
        content: `
          <div class="info-box" style="background: rgba(0,255,170,0.15); border-left: 3px solid #00ffaa;">
            <h3>👁️ The Inverter is Highlighted</h3>
            <p>Look for the <strong style="color:#00ffaa;">glowing cyan boxes</strong> on the posts — these are the string inverters that convert DC to AC power!</p>
          </div>
          <div class="info-box">
            <h3>What is an Inverter?</h3>
            <p>Inverters convert DC power from panels into AC power for the electrical grid. The type of inverter setup affects system design, cost, and performance.</p>
          </div>
          <div class="info-box" style="background: rgba(56,189,248,0.1); border-left: 3px solid #38bdf8;">
            <h3>⚡ Inverter Configurations</h3>
            <p><strong style="color:#38bdf8;">1. Distributed String Inverters</strong> (shown here)</p>
            <p style="font-size:0.9em; margin-left:15px;">Individual inverters mounted on each tracker/row. Offers per-string monitoring, easy maintenance, and reduced DC wiring. Popular for modern utility-scale projects.</p>
            <p><strong style="color:#38bdf8;">2. Centralized String Inverter Clusters</strong></p>
            <p style="font-size:0.9em; margin-left:15px;">Multiple string inverters grouped at central locations (inverter pads). Balances distributed benefits with easier access and reduced infrastructure.</p>
            <p><strong style="color:#38bdf8;">3. Central Inverters</strong></p>
            <p style="font-size:0.9em; margin-left:15px;">Large megawatt-scale inverters in a central location. Requires extensive DC collection but offers economies of scale. Traditional approach for very large projects.</p>
          </div>
          <div class="info-box" style="background: rgba(0,80,80,0.3); border-left: 3px solid #0fa;">
            <h3>🔍 What You're Seeing</h3>
            <p><span style="color:#00ffaa;">▢</span> <strong style="color:#00ffaa;">Glowing boxes</strong> = String inverters (HIGHLIGHTED)</p>
            <p><span style="color:#333;">▮</span> <strong style="color:#666;">Gray boxes</strong> = Inverter enclosures</p>
            <p><span style="color:#ffaa00;">━</span> <strong style="color:#ffaa00;">Orange conduit</strong> = AC output to substation</p>
          </div>
        `,
        stats: ``,
        cam: {x: 100, y: 5, z: -10},
        lookAt: {x: 100, y: 2.5, z: -30}
      }
    };

    function init() {
      setTimeout(() => { const ld = document.getElementById('loading'); ld.classList.add('fade-out'); setTimeout(() => ld.style.display = 'none', 700); }, 800);
      init3D();
      setupListeners();
      updateContent();
      // Show initial highlight after a brief delay
      setTimeout(() => highlightComponent('module'), 100);
    }

    function init3D() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x7ec8e3);
      scene.fog = new THREE.Fog(0x7ec8e3, 300, 800);
      
      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
      camera.position.set(defaultCam.x, defaultCam.y, defaultCam.z);
      camera.lookAt(targetX, targetY, targetZ);
      
      // Create renderer with optimized settings to prevent context loss
      renderer = new THREE.WebGLRenderer({ 
        antialias: true,
        powerPreference: "high-performance",
        preserveDrawingBuffer: false,
        stencil: false
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limit pixel ratio
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.getElementById('canvas-container').appendChild(renderer.domElement);
      
      // Handle WebGL context loss and restore
      renderer.domElement.addEventListener('webglcontextlost', function(event) {
        event.preventDefault();
        console.log('WebGL context lost. Attempting to restore...');
        cancelAnimationFrame(animationId);
      }, false);
      
      renderer.domElement.addEventListener('webglcontextrestored', function(event) {
        console.log('WebGL context restored.');
        init3D();
        animate();
      }, false);
      
      scene.add(new THREE.AmbientLight(0xffffff, 0.5));
      sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
      sunLight.position.set(100, 200, 80);
      sunLight.castShadow = true;
      sunLight.shadow.camera.left = -300;
      sunLight.shadow.camera.right = 300;
      sunLight.shadow.camera.top = 300;
      sunLight.shadow.camera.bottom = -300;
      sunLight.shadow.mapSize.width = 2048;
      sunLight.shadow.mapSize.height = 2048;
      scene.add(sunLight);
      
      // Create visible sun - BIGGER
      const sunGeo = new THREE.SphereGeometry(25, 32, 32);
      const sunMat = new THREE.MeshBasicMaterial({ 
        color: 0xffdd44,
        transparent: true,
        opacity: 1.0
      });
      sunMesh = new THREE.Mesh(sunGeo, sunMat);
      sunMesh.position.set(100, 200, 80);
      scene.add(sunMesh);
      
      // Sun glow - BIGGER
      const sunGlowGeo = new THREE.SphereGeometry(45, 32, 32);
      const sunGlowMat = new THREE.MeshBasicMaterial({ 
        color: 0xffaa00,
        transparent: true,
        opacity: 0.4
      });
      const sunGlow = new THREE.Mesh(sunGlowGeo, sunGlowMat);
      sunMesh.add(sunGlow);
      
      // Outer glow
      const sunGlowOuter = new THREE.Mesh(
        new THREE.SphereGeometry(70, 32, 32),
        new THREE.MeshBasicMaterial({ color: 0xffcc00, transparent: true, opacity: 0.15 })
      );
      sunMesh.add(sunGlowOuter);
      
      // Sun rays
      const rayMat = new THREE.MeshBasicMaterial({ 
        color: 0xffee66, 
        transparent: true, 
        opacity: 0.6 
      });
      for (let i = 0; i < 12; i++) {
        const rayGeo = new THREE.CylinderGeometry(0.5, 3, 80, 8);
        const ray = new THREE.Mesh(rayGeo, rayMat);
        ray.rotation.z = (i / 12) * Math.PI * 2;
        ray.position.x = Math.cos((i / 12) * Math.PI * 2) * 50;
        ray.position.y = Math.sin((i / 12) * Math.PI * 2) * 50;
        sunMesh.add(ray);
      }
      
      // Ground
      const groundCanvas = document.createElement('canvas');
      groundCanvas.width = 512;
      groundCanvas.height = 512;
      const gCtx = groundCanvas.getContext('2d');
      gCtx.fillStyle = '#5a8a50';
      gCtx.fillRect(0, 0, 512, 512);
      for (let i = 0; i < 8000; i++) {
        gCtx.fillStyle = `rgba(${60 + Math.random() * 50}, ${100 + Math.random() * 60}, ${50 + Math.random() * 40}, 0.4)`;
        gCtx.fillRect(Math.random() * 512, Math.random() * 512, 2, 4);
      }
      const groundTexture = new THREE.CanvasTexture(groundCanvas);
      groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
      groundTexture.repeat.set(30, 30);
      
      const ground = new THREE.Mesh(
        new THREE.PlaneGeometry(1200, 1200),
        new THREE.MeshStandardMaterial({ map: groundTexture, color: 0x6a9a5a })
      );
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = 0;
      ground.receiveShadow = true;
      scene.add(ground);
      
      // Dirt road
      const road = new THREE.Mesh(
        new THREE.PlaneGeometry(15, 400),
        new THREE.MeshStandardMaterial({ color: 0xc4a86a })
      );
      road.rotation.x = -Math.PI / 2;
      road.position.set(0, 0.1, 0);
      scene.add(road);
      
      createTrees();
      createFarm();
      createHighlights();
      createMarkers();
      animate();
    }
    
    // === HIGHLIGHT SYSTEM FOR EDUCATIONAL STEPS ===
    let highlightGroup;
    let activeHighlight = null;
    let highlightTime = 0;
    
    const highlightPositions = {
      module: { x: 140, y: 6, z: -27, scale: 1.0, elongated: false },       // Solar panel surface
      string: { x: 140, y: 6.0, z: -45, scale: 1.2, elongated: true, length: 42 },  // String circuit visualization
      tracker: { x: 140, y: 4, z: -63, scale: 1.0, elongated: false, isTracker: true },       // Torque tube and bearing
      combiner: { x: 140, y: 2.8, z: -24.5, scale: 1.0, elongated: false, isCombiner: true },       // Combiner box on post
      cabling: { x: 140, y: 3, z: 45, scale: 1.5, elongated: false, isCabling: true },  // DC cables
      inverter: { x: 105, y: 2.5, z: -27, scale: 1.0, elongated: false, isInverter: true }        // String inverters on posts
    };
    
    function createHighlights() {
      highlightGroup = new THREE.Group();
      scene.add(highlightGroup);
      
      // Create highlight ring for each step
      Object.keys(highlightPositions).forEach(step => {
        const pos = highlightPositions[step];
        const ringGroup = new THREE.Group();
        ringGroup.userData.step = step;
        
        if (pos.elongated) {
          // STRING HIGHLIGHT - Clean, intuitive design
          // Shows how panels connect in series with flowing electricity
          
          // Glowing outline box around the string section
          const outlineGeo = new THREE.BoxGeometry(pos.length + 4, 4, 8);
          const outlineEdges = new THREE.EdgesGeometry(outlineGeo);
          const outlineMat = new THREE.LineBasicMaterial({ 
            color: 0x00ff88, 
            transparent: true, 
            opacity: 0.8 
          });
          const outlineBox = new THREE.LineSegments(outlineEdges, outlineMat);
          outlineBox.position.set(pos.x, pos.y + 1.5, pos.z);
          ringGroup.add(outlineBox);
          
          // Glowing floor/base for the string section
          const baseMat = new THREE.MeshBasicMaterial({ 
            color: 0x00ff88, 
            transparent: true, 
            opacity: 0.15,
            side: THREE.DoubleSide
          });
          const baseGeo = new THREE.PlaneGeometry(pos.length + 4, 8);
          const basePlane = new THREE.Mesh(baseGeo, baseMat);
          basePlane.rotation.x = -Math.PI / 2;
          basePlane.position.set(pos.x, pos.y - 0.5, pos.z);
          ringGroup.add(basePlane);
          
          // DC+ Wire running through the string (red cable)
          const wireMat = new THREE.MeshBasicMaterial({ 
            color: 0xff4444, 
            transparent: true, 
            opacity: 1.0
          });
          const wireGeo = new THREE.CylinderGeometry(0.18, 0.18, pos.length - 4, 8);
          const wire = new THREE.Mesh(wireGeo, wireMat);
          wire.rotation.z = Math.PI / 2;
          wire.position.set(pos.x, pos.y + 0.5, pos.z + 1.5);
          ringGroup.add(wire);
          
          // DC+ wire glow
          const wireGlowMat = new THREE.MeshBasicMaterial({ 
            color: 0xff4444, 
            transparent: true, 
            opacity: 0.3
          });
          const wireGlowGeo = new THREE.CylinderGeometry(0.35, 0.35, pos.length - 4, 8);
          const wireGlow = new THREE.Mesh(wireGlowGeo, wireGlowMat);
          wireGlow.rotation.z = Math.PI / 2;
          wireGlow.position.set(pos.x, pos.y + 0.5, pos.z + 1.5);
          ringGroup.add(wireGlow);
          
          // DC- Wire (black cable) - made more visible with blue tint
          const wire2Mat = new THREE.MeshBasicMaterial({ 
            color: 0x3344aa, 
            transparent: true, 
            opacity: 1.0
          });
          const wire2Geo = new THREE.CylinderGeometry(0.18, 0.18, pos.length - 4, 8);
          const wire2 = new THREE.Mesh(wire2Geo, wire2Mat);
          wire2.rotation.z = Math.PI / 2;
          wire2.position.set(pos.x, pos.y + 0.1, pos.z + 1.5);
          ringGroup.add(wire2);
          
          // DC- wire glow
          const wire2GlowMat = new THREE.MeshBasicMaterial({ 
            color: 0x3344aa, 
            transparent: true, 
            opacity: 0.25
          });
          const wire2GlowGeo = new THREE.CylinderGeometry(0.35, 0.35, pos.length - 4, 8);
          const wire2Glow = new THREE.Mesh(wire2GlowGeo, wire2GlowMat);
          wire2Glow.rotation.z = Math.PI / 2;
          wire2Glow.position.set(pos.x, pos.y + 0.1, pos.z + 1.5);
          ringGroup.add(wire2Glow);
          
          // Wire labels at the start - "DC+" and "DC-"
          const redLabelGeo = new THREE.BoxGeometry(3, 0.5, 0.5);
          const redLabelMat = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 1.0 });
          const redLabel = new THREE.Mesh(redLabelGeo, redLabelMat);
          redLabel.position.set(pos.x - pos.length/2 + 3, pos.y + 0.5, pos.z + 1.5);
          ringGroup.add(redLabel);
          
          const blueLabelGeo = new THREE.BoxGeometry(3, 0.5, 0.5);
          const blueLabelMat = new THREE.MeshBasicMaterial({ color: 0x2233aa, transparent: true, opacity: 1.0 });
          const blueLabel = new THREE.Mesh(blueLabelGeo, blueLabelMat);
          blueLabel.position.set(pos.x - pos.length/2 + 3, pos.y + 0.1, pos.z + 1.5);
          ringGroup.add(blueLabel);
          
          // Panel indicators with connection points
          const numPanels = 6;
          for (let p = 0; p < numPanels; p++) {
            const pX = pos.x - pos.length/2 + 5 + p * 7;
            
            // Panel outline glow (shows each panel in the string)
            const panelGlowGeo = new THREE.BoxGeometry(6, 0.2, 3);
            const panelGlowMat = new THREE.MeshBasicMaterial({ 
              color: 0x00ffaa, 
              transparent: true, 
              opacity: 0.4 
            });
            const panelGlow = new THREE.Mesh(panelGlowGeo, panelGlowMat);
            panelGlow.position.set(pX, pos.y + 0.8, pos.z);
            ringGroup.add(panelGlow);
            
            // Connection point between panels (green dot) - on the red wire
            if (p < numPanels - 1) {
              const connectorGeo = new THREE.SphereGeometry(0.35, 12, 12);
              const connectorMat = new THREE.MeshBasicMaterial({ 
                color: 0x00ff00, 
                transparent: true, 
                opacity: 1.0
              });
              const connector = new THREE.Mesh(connectorGeo, connectorMat);
              connector.position.set(pX + 3.5, pos.y + 0.5, pos.z + 1.5);
              connector.userData.isMC4 = true;
              ringGroup.add(connector);
              
              // Glow around connector
              const connectorGlow = new THREE.Mesh(
                new THREE.SphereGeometry(0.6, 12, 12),
                new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.3 })
              );
              connectorGlow.position.copy(connector.position);
              ringGroup.add(connectorGlow);
            }
          }
          
          // Animated electricity particles flowing through the RED wire (DC+)
          for (let i = 0; i < 10; i++) {
            const particleGeo = new THREE.SphereGeometry(0.3, 8, 8);
            const particleMat = new THREE.MeshBasicMaterial({ 
              color: 0x00ffff, 
              transparent: true, 
              opacity: 0.95
            });
            const particle = new THREE.Mesh(particleGeo, particleMat);
            const startX = pos.x - pos.length/2 + 3;
            particle.position.set(startX + i * 4, pos.y + 0.5, pos.z + 1.5);
            particle.userData.isStringParticle = true;
            particle.userData.startX = startX;
            particle.userData.endX = pos.x + pos.length/2 - 3;
            particle.userData.offset = i / 10;
            particle.userData.baseZ = pos.z + 1.5;
            particle.userData.baseY = pos.y + 0.5;
            ringGroup.add(particle);
            
            // Particle glow trail
            const particleGlow = new THREE.Mesh(
              new THREE.SphereGeometry(0.6, 8, 8),
              new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.35 })
            );
            particleGlow.position.copy(particle.position);
            particleGlow.userData.isStringParticle = true;
            particleGlow.userData.startX = particle.userData.startX;
            particleGlow.userData.endX = particle.userData.endX;
            particleGlow.userData.offset = particle.userData.offset;
            particleGlow.userData.baseZ = particle.userData.baseZ;
            particleGlow.userData.baseY = particle.userData.baseY;
            particleGlow.userData.isGlow = true;
            ringGroup.add(particleGlow);
          }
          
          // Direction arrow at the end (showing flow to inverter)
          const arrowGeo = new THREE.ConeGeometry(0.7, 2.0, 8);
          const arrowMat = new THREE.MeshBasicMaterial({ 
            color: 0x00ff88, 
            transparent: true, 
            opacity: 1.0
          });
          
          // Arrow pointing right (toward inverter)
          const rightArrow = new THREE.Mesh(arrowGeo, arrowMat);
          rightArrow.position.set(pos.x + pos.length/2 - 1, pos.y + 0.5, pos.z + 1.5);
          rightArrow.rotation.z = Math.PI / 2;
          rightArrow.userData.baseX = pos.x + pos.length/2 - 1;
          ringGroup.add(rightArrow);
          
          // Arrow glow
          const arrowGlow = new THREE.Mesh(
            new THREE.ConeGeometry(1.0, 2.5, 8),
            new THREE.MeshBasicMaterial({ color: 0x00ff88, transparent: true, opacity: 0.35 })
          );
          arrowGlow.position.copy(rightArrow.position);
          arrowGlow.rotation.copy(rightArrow.rotation);
          arrowGlow.userData.baseX = rightArrow.userData.baseX;
          ringGroup.add(arrowGlow);
          
        } else {
          // ARROW HIGHLIGHT (pointing down at component)
          
          // Special highlight for cabling - shows cable runs
          if (pos.isCabling) {
            // Multiple cable line highlights - smaller for close-up
            const cableMat = new THREE.MeshBasicMaterial({ 
              color: 0xff4444, 
              transparent: true, 
              opacity: 0.8
            });
            const cableMatBlack = new THREE.MeshBasicMaterial({ 
              color: 0x4444ff, 
              transparent: true, 
              opacity: 0.8
            });
            
            // Horizontal cable runs (red and blue for DC+ and DC-)
            for (let c = 0; c < 3; c++) {
              const cableGeo = new THREE.CylinderGeometry(0.15, 0.15, 40, 8);
              const cable = new THREE.Mesh(cableGeo, c % 2 === 0 ? cableMat.clone() : cableMatBlack.clone());
              cable.rotation.z = Math.PI / 2;
              cable.position.set(pos.x, pos.y + c * 0.4, pos.z + (c - 1) * 1);
              ringGroup.add(cable);
            }
            
            // Glowing pulses along cables
            for (let p = 0; p < 6; p++) {
              const pulseGeo = new THREE.SphereGeometry(0.3, 16, 16);
              const pulseMat = new THREE.MeshBasicMaterial({ 
                color: p % 2 === 0 ? 0xff6666 : 0x6666ff, 
                transparent: true, 
                opacity: 0.9
              });
              const pulse = new THREE.Mesh(pulseGeo, pulseMat);
              pulse.position.set(pos.x - 15 + p * 6, pos.y + (p % 3) * 0.4, pos.z + ((p % 3) - 1) * 1);
              pulse.userData.isCablePulse = true;
              pulse.userData.baseX = pos.x - 15 + p * 6;
              ringGroup.add(pulse);
            }
            
            // Large label arrow
            const mainArrowGeo = new THREE.ConeGeometry(0.6, 2, 8);
            const mainArrowMat = new THREE.MeshBasicMaterial({ 
              color: 0xffaa00, 
              transparent: true, 
              opacity: 0.95
            });
            const mainArrow = new THREE.Mesh(mainArrowGeo, mainArrowMat);
            mainArrow.rotation.x = Math.PI;
            mainArrow.position.set(pos.x, pos.y + 4, pos.z);
            mainArrow.userData.isMainArrow = true;
            mainArrow.userData.baseY = pos.y + 4;
            ringGroup.add(mainArrow);
            
            // Vertical drop cables visualization
            for (let d = 0; d < 4; d++) {
              const dropGeo = new THREE.CylinderGeometry(0.08, 0.08, 2, 8);
              const dropMat = new THREE.MeshBasicMaterial({ 
                color: d % 2 === 0 ? 0xff4444 : 0x4444ff, 
                transparent: true, 
                opacity: 0.7
              });
              const drop = new THREE.Mesh(dropGeo, dropMat);
              drop.position.set(pos.x - 12 + d * 8, pos.y + 2.5, pos.z);
              ringGroup.add(drop);
            }
            
          } else if (pos.isTracker) {
            // TRACKER HIGHLIGHT - Outline created dynamically in highlightComponent
            // Nothing needed here - the bearing plates glow when step is selected
            
          } else if (pos.isCombiner) {
            // COMBINER HIGHLIGHT - Highlight created dynamically in highlightComponent
            // Nothing needed here - the combiner boxes glow when step is selected
            
          } else if (pos.isInverter) {
            // INVERTER HIGHLIGHT - Highlight created dynamically in highlightComponent
            // Nothing needed here - the inverter boxes glow when step is selected
            
          } else {
            // Standard arrow highlight - smaller for close-up views
            // Main downward pointing arrow
            const mainArrowGeo = new THREE.ConeGeometry(0.4, 1.2, 8);
            const mainArrowMat = new THREE.MeshBasicMaterial({ 
              color: 0x00ffaa, 
              transparent: true, 
              opacity: 0.9
            });
            const mainArrow = new THREE.Mesh(mainArrowGeo, mainArrowMat);
            mainArrow.rotation.x = Math.PI; // Point downward
            mainArrow.position.set(pos.x, pos.y + 2.5, pos.z);
            mainArrow.userData.isMainArrow = true;
            mainArrow.userData.baseY = pos.y + 2.5;
            ringGroup.add(mainArrow);
            
            // Trail arrows above (creating motion effect)
            for (let t = 1; t <= 3; t++) {
              const trailArrow = new THREE.Mesh(
                new THREE.ConeGeometry(0.3 - t * 0.05, 0.8, 6),
                new THREE.MeshBasicMaterial({ 
                  color: 0x00ffaa, 
                  transparent: true, 
                  opacity: 0.5 - t * 0.12
                })
              );
              trailArrow.rotation.x = Math.PI;
              trailArrow.position.set(pos.x, pos.y + 2.5 + t * 1, pos.z);
              ringGroup.add(trailArrow);
            }
            
            // Four arrows pointing inward from sides
            for (let i = 0; i < 4; i++) {
              const angle = (i / 4) * Math.PI * 2;
              const arrowGeo = new THREE.ConeGeometry(0.25, 0.8, 6);
              const arrowMat = new THREE.MeshBasicMaterial({ 
                color: 0x00ffaa, 
                transparent: true, 
                opacity: 0.8
              });
              const arrow = new THREE.Mesh(arrowGeo, arrowMat);
              const dist = pos.scale * 1.5;
              arrow.position.set(
                pos.x + Math.cos(angle) * dist,
                pos.y + 0.5,
                pos.z + Math.sin(angle) * dist
              );
              // Point arrows inward toward center
              arrow.rotation.x = Math.PI / 2;
              arrow.rotation.z = angle + Math.PI / 2;
              arrow.userData.baseAngle = angle;
              arrow.userData.baseDist = dist;
              ringGroup.add(arrow);
            }
          }
        }
        
        ringGroup.visible = false;
        highlightGroup.add(ringGroup);
      });
    }
    
    function highlightComponent(step) {
      // Hide all highlights
      highlightGroup.children.forEach(group => {
        group.visible = false;
      });
      
      // Remove any tracker outline meshes
      if (window.trackerOutline) {
        scene.remove(window.trackerOutline);
        window.trackerOutline = null;
      }
      
      // Restore bearing plates to original material
      bearingPlates.forEach(item => {
        if (item.isHighlighted) {
          item.mesh.material = item.originalMat;
          item.isHighlighted = false;
        }
      });
      
      // Restore combiner boxes to original material
      combinerBoxes.forEach(item => {
        if (item.isHighlighted) {
          item.mesh.material = item.originalMat;
          item.isHighlighted = false;
        }
      });
      
      // Restore inverter boxes to original material
      inverterBoxes.forEach(item => {
        if (item.isHighlighted) {
          item.mesh.material = item.originalMat;
          item.isHighlighted = false;
        }
      });
      
      // Show the highlight for the current step
      const highlight = highlightGroup.children.find(g => g.userData.step === step);
      if (highlight) {
        highlight.visible = true;
        activeHighlight = highlight;
        highlightTime = 0;
      }
      
      // If tracker step, make the bearing plate at z=-63 glow
      if (step === 'tracker') {
        const targetZ = -63;
        const glowMat = new THREE.MeshBasicMaterial({ 
          color: 0x00ffaa, 
          transparent: true, 
          opacity: 0.9,
          side: THREE.DoubleSide
        });
        
        bearingPlates.forEach(item => {
          // Highlight bearing plates on the right block (x > 0) at the target row
          if (Math.abs(item.rowZ - targetZ) < 1 && item.xCenter > 0) {
            item.mesh.material = glowMat;
            item.isHighlighted = true;
          }
        });
      }
      
      // If combiner step, make the combiner boxes at z=-27 glow
      if (step === 'combiner') {
        const targetZ = -27;
        const glowMat = new THREE.MeshBasicMaterial({ 
          color: 0x00ffaa, 
          transparent: true, 
          opacity: 0.9
        });
        
        combinerBoxes.forEach(item => {
          // Highlight combiner boxes on the right block (x > 0) at the target row
          if (Math.abs(item.rowZ - targetZ) < 1 && item.xCenter > 0) {
            item.mesh.material = glowMat;
            item.isHighlighted = true;
          }
        });
      }
      
      // If inverter step, make the inverter boxes at z=-27 glow
      if (step === 'inverter') {
        const targetZ = -27;
        const glowMat = new THREE.MeshBasicMaterial({ 
          color: 0x00ffaa, 
          transparent: true, 
          opacity: 0.9
        });
        
        inverterBoxes.forEach(item => {
          // Highlight inverters on the right block (x > 0) at the target row
          if (Math.abs(item.rowZ - targetZ) < 1 && item.xCenter > 0) {
            item.mesh.material = glowMat;
            item.isHighlighted = true;
          }
        });
      }
    }
    
    function animateHighlights() {
      if (!activeHighlight || !activeHighlight.visible) return;
      
      highlightTime += 0.05;
      const step = activeHighlight.userData.step;
      const pos = highlightPositions[step];
      
      activeHighlight.children.forEach(child => {
        if (child.userData.isMC4) {
          // MC4 connection points pulse
          const pulse = 1 + Math.sin(highlightTime * 4) * 0.3;
          child.scale.set(pulse, pulse, pulse);
          child.material.opacity = 0.7 + Math.sin(highlightTime * 4) * 0.3;
        }
        
        // Animated string particles (flowing electricity)
        if (child.userData.isStringParticle) {
          const range = child.userData.endX - child.userData.startX;
          const progress = ((highlightTime * 0.8 + child.userData.offset) % 1);
          child.position.x = child.userData.startX + progress * range;
          child.position.z = child.userData.baseZ + Math.sin(highlightTime * 3 + child.userData.offset * 10) * 0.1;
          if (child.userData.baseY) {
            child.position.y = child.userData.baseY + Math.sin(highlightTime * 4 + child.userData.offset * 8) * 0.05;
          }
          
          if (!child.userData.isGlow) {
            const pulse = 0.9 + Math.sin(highlightTime * 5 + child.userData.offset * 10) * 0.3;
            child.scale.set(pulse, pulse, pulse);
            child.material.opacity = 0.9 + Math.sin(highlightTime * 4) * 0.1;
          } else {
            child.material.opacity = 0.3 + Math.sin(highlightTime * 4) * 0.15;
          }
        }
        if (child.userData.isCablePulse) {
          // Cable pulse animation - move along cable
          const baseX = child.userData.baseX;
          child.position.x = baseX + Math.sin(highlightTime * 2 + baseX * 0.1) * 1.5;
          child.material.opacity = 0.6 + Math.sin(highlightTime * 4 + baseX * 0.1) * 0.4;
          const scale = 0.8 + Math.sin(highlightTime * 3) * 0.2;
          child.scale.set(scale, scale, scale);
        }
        if (child.geometry.type === 'CylinderGeometry') {
          // Cable/wire highlights pulse - make more visible
          child.material.opacity = 0.7 + Math.sin(highlightTime * 2) * 0.3;
          const pulse = 1 + Math.sin(highlightTime * 3) * 0.15;
          child.scale.set(pulse, 1, pulse);
        }
        if (child.geometry.type === 'ConeGeometry') {
          // Arrows animation - make them pulse and move VISIBLY
          if (child.userData.isMainArrow) {
            // Main downward arrow bobs up and down - smaller movement
            const bob = Math.sin(highlightTime * 3) * 0.3;
            child.position.y = child.userData.baseY + bob;
            child.material.opacity = 0.7 + Math.sin(highlightTime * 2) * 0.3;
            const scale = 1 + Math.sin(highlightTime * 2) * 0.1;
            child.scale.set(scale, scale, scale);
          } else if (child.userData.baseAngle !== undefined) {
            // Side arrows pulse inward/outward - smaller movement
            const pulseDist = child.userData.baseDist + Math.sin(highlightTime * 3) * 0.2;
            child.position.x = pos.x + Math.cos(child.userData.baseAngle) * pulseDist;
            child.position.z = pos.z + Math.sin(child.userData.baseAngle) * pulseDist;
            child.material.opacity = 0.6 + Math.sin(highlightTime * 2) * 0.3;
            const scale = 1 + Math.sin(highlightTime * 2) * 0.15;
            child.scale.set(scale, scale, scale);
          } else if (child.userData.baseX !== undefined) {
            // Elongated arrows pulse horizontally - BIG VISIBLE MOVEMENT
            const dir = child.userData.baseX < pos.x ? 1 : -1;
            child.position.x = child.userData.baseX + Math.sin(highlightTime * 4) * 2.5 * dir;
            child.material.opacity = 0.85 + Math.sin(highlightTime * 3) * 0.15;
            const scale = 1.0 + Math.sin(highlightTime * 3) * 0.3;
            child.scale.set(scale, scale, scale);
          }
        }
        if (child.geometry.type === 'BoxGeometry') {
          // Box highlights pulse (for string highlight elements)
          child.material.opacity = 0.4 + Math.sin(highlightTime * 2) * 0.2;
        }
      });
    }

    function createTrees() {
      const trunkMat = new THREE.MeshStandardMaterial({ color: 0x4a3520 });
      const foliageMat = new THREE.MeshStandardMaterial({ color: 0x1a5a30 });
      
      for (let i = 0; i < 60; i++) {
        const tree = new THREE.Group();
        const x = -400 + i * 13 + Math.random() * 5;
        const z = -220 - Math.random() * 60;
        
        const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 1, 10, 8), trunkMat);
        trunk.position.y = 5;
        trunk.castShadow = true;
        tree.add(trunk);
        
        const height = 16 + Math.random() * 10;
        const foliage = new THREE.Mesh(new THREE.ConeGeometry(5 + Math.random() * 2, height, 8), foliageMat);
        foliage.position.y = 10 + height / 2;
        foliage.castShadow = true;
        tree.add(foliage);
        
        tree.position.set(x, 0, z);
        scene.add(tree);
      }
    }

    function createFarm() {
      // Panel texture
      const panelCanvas = document.createElement('canvas');
      panelCanvas.width = 256;
      panelCanvas.height = 256;
      const pCtx = panelCanvas.getContext('2d');
      
      pCtx.fillStyle = '#4a5a8a';
      pCtx.fillRect(0, 0, 256, 256);
      
      const cols = 6, rows = 10;
      const cellW = 256 / cols, cellH = 256 / rows;
      
      pCtx.strokeStyle = '#ffffff';
      pCtx.lineWidth = 1.5;
      for (let c = 0; c <= cols; c++) {
        pCtx.beginPath();
        pCtx.moveTo(c * cellW, 0);
        pCtx.lineTo(c * cellW, 256);
        pCtx.stroke();
      }
      for (let r = 0; r <= rows; r++) {
        pCtx.beginPath();
        pCtx.moveTo(0, r * cellH);
        pCtx.lineTo(256, r * cellH);
        pCtx.stroke();
      }
      
      const panelTexture = new THREE.CanvasTexture(panelCanvas);
      
      // Materials
      const panelMat = new THREE.MeshStandardMaterial({ map: panelTexture, metalness: 0.7, roughness: 0.05, envMapIntensity: 2.0 });
      const frameMat = new THREE.MeshStandardMaterial({ color: 0xd0d0d0, metalness: 0.6, roughness: 0.4 });
      const torqueMat = new THREE.MeshStandardMaterial({ color: 0x505560, metalness: 0.7, roughness: 0.3 });
      const postMat = new THREE.MeshStandardMaterial({ color: 0x606868, metalness: 0.5, roughness: 0.5 });
      const inverterMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, metalness: 0.6, roughness: 0.4 });
      const inverterGrayMat = new THREE.MeshStandardMaterial({ color: 0x3a3a3a, metalness: 0.5, roughness: 0.5 });
      const ventMat = new THREE.MeshStandardMaterial({ color: 0x252525, metalness: 0.3, roughness: 0.6 });
      
      // Store materials globally for rebuild
      window.farmMats = { panelMat, frameMat, torqueMat, postMat, inverterMat, inverterGrayMat, ventMat };
      
      // Create all tracker rows based on current panel style
      createAllTrackerRows();
      
      // SUBSTATION
      const substation = new THREE.Group();
      
      const building = new THREE.Mesh(
        new THREE.BoxGeometry(15, 8, 10),
        new THREE.MeshStandardMaterial({ color: 0xf5f5f5 })
      );
      building.position.y = 4;
      building.castShadow = true;
      substation.add(building);
      
      const roof = new THREE.Mesh(
        new THREE.BoxGeometry(17, 1.2, 12),
        new THREE.MeshStandardMaterial({ color: 0x3b82f6 })
      );
      roof.position.y = 8.6;
      substation.add(roof);
      
      const door = new THREE.Mesh(
        new THREE.BoxGeometry(3, 5, 0.2),
        new THREE.MeshStandardMaterial({ color: 0x6b2176 })
      );
      door.position.set(0, 2.5, 5.2);
      substation.add(door);
      
      // === REALISTIC WOODEN UTILITY POLE ===
      const poleGroup = new THREE.Group();
      
      const woodPoleMat = new THREE.MeshStandardMaterial({ 
        color: 0x5a4030, 
        roughness: 0.9,
        metalness: 0.0
      });
      const steelMat = new THREE.MeshStandardMaterial({ color: 0x666666, metalness: 0.7, roughness: 0.4 });
      const ceramicMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.4, metalness: 0.1 });
      const wireMat2 = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.8, roughness: 0.2 });
      
      // Main pole (tapered wooden pole)
      const mainPole = new THREE.Mesh(
        new THREE.CylinderGeometry(0.2, 0.35, 18, 8),
        woodPoleMat
      );
      mainPole.position.y = 9;
      mainPole.castShadow = true;
      poleGroup.add(mainPole);
      
      // Top crossarm
      const crossarm1 = new THREE.Mesh(
        new THREE.BoxGeometry(5, 0.25, 0.2),
        woodPoleMat
      );
      crossarm1.position.y = 16;
      poleGroup.add(crossarm1);
      
      // Second crossarm (lower)
      const crossarm2 = new THREE.Mesh(
        new THREE.BoxGeometry(4, 0.22, 0.18),
        woodPoleMat
      );
      crossarm2.position.y = 14;
      poleGroup.add(crossarm2);
      
      // Third crossarm (lowest)
      const crossarm3 = new THREE.Mesh(
        new THREE.BoxGeometry(3, 0.2, 0.15),
        woodPoleMat
      );
      crossarm3.position.y = 12;
      poleGroup.add(crossarm3);
      
      // Insulators on top crossarm (3 phase)
      [-2, 0, 2].forEach(x => {
        const insulator = new THREE.Mesh(
          new THREE.CylinderGeometry(0.12, 0.15, 0.3, 8),
          ceramicMat
        );
        insulator.position.set(x, 16.2, 0);
        poleGroup.add(insulator);
        
        // Pin on top of insulator
        const pin = new THREE.Mesh(
          new THREE.CylinderGeometry(0.03, 0.03, 0.15, 6),
          steelMat
        );
        pin.position.set(x, 16.4, 0);
        poleGroup.add(pin);
      });
      
      // Insulators on second crossarm
      [-1.5, 1.5].forEach(x => {
        const insulator2 = new THREE.Mesh(
          new THREE.CylinderGeometry(0.1, 0.13, 0.25, 8),
          ceramicMat
        );
        insulator2.position.set(x, 14.18, 0);
        poleGroup.add(insulator2);
      });
      
      // Insulators on third crossarm
      [-1, 1].forEach(x => {
        const insulator3 = new THREE.Mesh(
          new THREE.CylinderGeometry(0.08, 0.1, 0.2, 8),
          ceramicMat
        );
        insulator3.position.set(x, 12.15, 0);
        poleGroup.add(insulator3);
      });
      
      // Transformer can on pole
      const transformer = new THREE.Mesh(
        new THREE.CylinderGeometry(0.5, 0.5, 1.5, 12),
        new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.6, roughness: 0.4 })
      );
      transformer.position.set(0.8, 10, 0);
      poleGroup.add(transformer);
      
      // Transformer mounting bracket
      const bracket = new THREE.Mesh(
        new THREE.BoxGeometry(0.8, 0.1, 0.3),
        steelMat
      );
      bracket.position.set(0.4, 10.8, 0);
      poleGroup.add(bracket);
      
      // Power lines extending outward
      [-2, 0, 2].forEach((x, i) => {
        const wireLine = new THREE.Mesh(
          new THREE.CylinderGeometry(0.02, 0.02, 60, 4),
          wireMat2
        );
        wireLine.rotation.x = Math.PI / 2;
        wireLine.position.set(x, 16.35 - i * 0.02, -30);
        poleGroup.add(wireLine);
      });
      
      // Pole number tag
      const tag = new THREE.Mesh(
        new THREE.BoxGeometry(0.4, 0.25, 0.05),
        new THREE.MeshStandardMaterial({ color: 0xffff00 })
      );
      tag.position.set(0, 4, 0.2);
      poleGroup.add(tag);
      
      poleGroup.position.set(20, 0, -5);
      substation.add(poleGroup);
      
      substation.position.set(0, 0, 0);
      scene.add(substation);
      
      // === DEMO TRACKER DISPLAY MODEL ===
      // Professional museum-style tracker exhibit
      const demoTracker = new THREE.Group();
      
      // === DISPLAY PLATFORM ===
      const demoPad = new THREE.Mesh(
        new THREE.BoxGeometry(16, 0.4, 14),
        new THREE.MeshStandardMaterial({ color: 0x2a3a4a, roughness: 0.6, metalness: 0.3 })
      );
      demoPad.position.y = 0.2;
      demoTracker.add(demoPad);
      
      // Platform edge trim (accent color)
      const edgeTrim = new THREE.Mesh(
        new THREE.BoxGeometry(16.2, 0.15, 14.2),
        new THREE.MeshStandardMaterial({ color: 0xff1493, metalness: 0.6 })
      );
      edgeTrim.position.y = 0.42;
      demoTracker.add(edgeTrim);
      
      // === INFO BOARD (positioned to the left) ===
      const boardGroup = new THREE.Group();
      
      // Board backing (facing forward)
      const boardBack = new THREE.Mesh(
        new THREE.BoxGeometry(5, 6, 0.15),
        new THREE.MeshStandardMaterial({ color: 0x1a2a3a, metalness: 0.2 })
      );
      boardGroup.add(boardBack);
      
      // Board frame
      const trackerFrameMat = new THREE.MeshStandardMaterial({ color: 0x38bdf8, metalness: 0.6 });
      const frameTop = new THREE.Mesh(new THREE.BoxGeometry(5.1, 0.15, 0.2), trackerFrameMat);
      frameTop.position.y = 3;
      boardGroup.add(frameTop);
      const frameBottom = new THREE.Mesh(new THREE.BoxGeometry(5.1, 0.15, 0.2), trackerFrameMat);
      frameBottom.position.y = -3;
      boardGroup.add(frameBottom);
      
      // Info board content
      const infoBoardCanvas = document.createElement('canvas');
      infoBoardCanvas.width = 512;
      infoBoardCanvas.height = 600;
      const ibCtx = infoBoardCanvas.getContext('2d');
      
      ibCtx.fillStyle = '#0f1a24';
      ibCtx.fillRect(0, 0, 512, 600);
      
      ibCtx.fillStyle = '#ff1493';
      ibCtx.font = 'bold 36px Arial';
      ibCtx.textAlign = 'center';
      ibCtx.fillText('TRACKER SYSTEM', 256, 50);
      
      ibCtx.fillStyle = '#38bdf8';
      ibCtx.font = '18px Arial';
      ibCtx.fillText('Single-Axis Solar Tracking', 256, 80);
      
      ibCtx.strokeStyle = '#38bdf8';
      ibCtx.lineWidth = 2;
      ibCtx.beginPath();
      ibCtx.moveTo(40, 100);
      ibCtx.lineTo(472, 100);
      ibCtx.stroke();
      
      // Left - Nextracker
      ibCtx.fillStyle = '#ff6600';
      ibCtx.font = 'bold 20px Arial';
      ibCtx.textAlign = 'left';
      ibCtx.fillText('◀ NEXTRACKER', 50, 140);
      ibCtx.fillStyle = '#94a3b8';
      ibCtx.font = '14px Arial';
      ibCtx.fillText('• Compact bearing design', 50, 165);
      ibCtx.fillText('• Orange X logo badge', 50, 185);
      ibCtx.fillText('• TrueCapture™ tech', 50, 205);
      
      // Right - Array
      ibCtx.fillStyle = '#38bdf8';
      ibCtx.font = 'bold 20px Arial';
      ibCtx.fillText('ARRAY TECH ▶', 280, 140);
      ibCtx.fillStyle = '#94a3b8';
      ibCtx.font = '14px Arial';
      ibCtx.fillText('• Shield plate design', 280, 165);
      ibCtx.fillText('• Flame-shaped cutouts', 280, 185);
      ibCtx.fillText('• DuraTrack HZ v3', 280, 205);
      
      // Components
      ibCtx.fillStyle = '#38bdf8';
      ibCtx.font = 'bold 18px Arial';
      ibCtx.textAlign = 'center';
      ibCtx.fillText('KEY COMPONENTS', 256, 260);
      
      ibCtx.font = '14px Arial';
      ibCtx.textAlign = 'left';
      ibCtx.fillStyle = '#64748b';
      ibCtx.fillText('Torque Tube', 50, 295);
      ibCtx.fillStyle = '#94a3b8';
      ibCtx.fillText('Steel tube connecting panels', 170, 295);
      
      ibCtx.fillStyle = '#64748b';
      ibCtx.fillText('Bearing', 50, 325);
      ibCtx.fillStyle = '#94a3b8';
      ibCtx.fillText('Rotation mechanism', 170, 325);
      
      ibCtx.fillStyle = '#64748b';
      ibCtx.fillText('W-Beam Post', 50, 355);
      ibCtx.fillStyle = '#94a3b8';
      ibCtx.fillText('Driven pile foundation', 170, 355);
      
      // Stats boxes
      ibCtx.fillStyle = '#1e293b';
      ibCtx.fillRect(40, 400, 200, 70);
      ibCtx.fillRect(270, 400, 200, 70);
      
      ibCtx.fillStyle = '#ff1493';
      ibCtx.font = 'bold 28px Arial';
      ibCtx.textAlign = 'center';
      ibCtx.fillText('+25%', 140, 445);
      ibCtx.fillText('±60°', 370, 445);
      
      ibCtx.fillStyle = '#64748b';
      ibCtx.font = '12px Arial';
      ibCtx.fillText('MORE ENERGY', 140, 465);
      ibCtx.fillText('ROTATION', 370, 465);
      
      ibCtx.fillStyle = '#475569';
      ibCtx.font = '12px Arial';
      ibCtx.fillText('Panels follow sun east to west daily', 256, 520);
      
      const infoBoardTexture = new THREE.CanvasTexture(infoBoardCanvas);
      const infoBoardMesh = new THREE.Mesh(
        new THREE.PlaneGeometry(4.8, 5.7),
        new THREE.MeshBasicMaterial({ map: infoBoardTexture })
      );
      // Face forward (toward camera)
      infoBoardMesh.position.z = 0.1;
      boardGroup.add(infoBoardMesh);
      
      // Position board to the far left, facing forward
      boardGroup.position.set(-10, 3.5, 6);
      boardGroup.rotation.y = 0; // Face forward
      demoTracker.add(boardGroup);
      
      // === TRACKER COMPONENTS ===
      const demoPostMat = new THREE.MeshStandardMaterial({ color: 0x666666, metalness: 0.5, roughness: 0.4 });
      const demoPostHeight = 5;
      
      // === BEARING LABELS ===
      // Nextracker label (below left bearing) - BIG AND VISIBLE
      const nexLabel = document.createElement('canvas');
      nexLabel.width = 512;
      nexLabel.height = 128;
      const nexCtx = nexLabel.getContext('2d');
      // Dark background for contrast
      nexCtx.fillStyle = '#0a1520';
      nexCtx.fillRect(0, 0, 512, 128);
      // Orange border
      nexCtx.strokeStyle = '#ff6600';
      nexCtx.lineWidth = 6;
      nexCtx.strokeRect(3, 3, 506, 122);
      // Orange text
      nexCtx.fillStyle = '#ff6600';
      nexCtx.font = 'bold 56px Arial';
      nexCtx.textAlign = 'center';
      nexCtx.fillText('NEXTRACKER', 256, 82);
      const nexLabelTexture = new THREE.CanvasTexture(nexLabel);
      const nexLabelMesh = new THREE.Mesh(
        new THREE.PlaneGeometry(4, 1),
        new THREE.MeshBasicMaterial({ map: nexLabelTexture, transparent: false })
      );
      nexLabelMesh.position.set(-2, 1, 3);
      demoTracker.add(nexLabelMesh);
      
      // Array Technologies label (below right bearing) - BIG AND VISIBLE
      const arrLabel = document.createElement('canvas');
      arrLabel.width = 512;
      arrLabel.height = 128;
      const arrCtx = arrLabel.getContext('2d');
      // Dark background for contrast
      arrCtx.fillStyle = '#0a1520';
      arrCtx.fillRect(0, 0, 512, 128);
      // Blue border
      arrCtx.strokeStyle = '#38bdf8';
      arrCtx.lineWidth = 6;
      arrCtx.strokeRect(3, 3, 506, 122);
      // Blue text
      arrCtx.fillStyle = '#38bdf8';
      arrCtx.font = 'bold 36px Arial';
      arrCtx.textAlign = 'center';
      arrCtx.fillText('ARRAY TECHNOLOGIES', 256, 78);
      const arrLabelTexture = new THREE.CanvasTexture(arrLabel);
      const arrLabelMesh = new THREE.Mesh(
        new THREE.PlaneGeometry(4, 1),
        new THREE.MeshBasicMaterial({ map: arrLabelTexture, transparent: false })
      );
      arrLabelMesh.position.set(3, 1, 3);
      demoTracker.add(arrLabelMesh);
      
      const demoPostWeb = new THREE.Mesh(
        new THREE.BoxGeometry(0.25, demoPostHeight, 0.6),
        demoPostMat
      );
      demoPostWeb.position.set(0, demoPostHeight / 2, 0);
      demoPostWeb.castShadow = true;
      demoTracker.add(demoPostWeb);
      
      const demoFlange1 = new THREE.Mesh(
        new THREE.BoxGeometry(0.6, demoPostHeight, 0.1),
        demoPostMat
      );
      demoFlange1.position.set(0, demoPostHeight / 2, 0.28);
      demoTracker.add(demoFlange1);
      
      const demoFlange2 = new THREE.Mesh(
        new THREE.BoxGeometry(0.6, demoPostHeight, 0.1),
        demoPostMat
      );
      demoFlange2.position.set(0, demoPostHeight / 2, -0.28);
      demoTracker.add(demoFlange2);
      
      const demoTubeMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.6, roughness: 0.3 });
      const demoTube = new THREE.Mesh(
        new THREE.CylinderGeometry(0.35, 0.35, 10, 16),
        demoTubeMat
      );
      demoTube.rotation.z = Math.PI / 2;
      demoTube.position.y = demoPostHeight;
      demoTracker.add(demoTube);
      
      // === NEXTRACKER BEARING (left) ===
      const nexClampMat = new THREE.MeshStandardMaterial({ color: 0x505050, metalness: 0.75, roughness: 0.25 });
      
      const nexBearingBox = new THREE.Mesh(
        new THREE.BoxGeometry(0.6, 0.9, 0.8),
        nexClampMat
      );
      nexBearingBox.position.set(-2, demoPostHeight, 0);
      demoTracker.add(nexBearingBox);
      
      const nexEar1 = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.2, 0.2), nexClampMat);
      nexEar1.position.set(-2, demoPostHeight + 0.4, 0.45);
      demoTracker.add(nexEar1);
      
      const nexEar2 = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.2, 0.2), nexClampMat);
      nexEar2.position.set(-2, demoPostHeight + 0.4, -0.45);
      demoTracker.add(nexEar2);
      
      const orangeMat = new THREE.MeshStandardMaterial({ color: 0xff6600, emissive: 0xff4400, emissiveIntensity: 0.15 });
      const nexBadge = new THREE.Mesh(
        new THREE.CylinderGeometry(0.35, 0.35, 0.1, 24),
        orangeMat
      );
      nexBadge.rotation.x = Math.PI / 2;
      nexBadge.position.set(-2, demoPostHeight - 0.2, 0.5);
      demoTracker.add(nexBadge);
      
      const whiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
      const xBar1 = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.4, 0.03), whiteMat);
      xBar1.rotation.z = Math.PI / 4;
      xBar1.rotation.x = Math.PI / 2;
      xBar1.position.set(-2, demoPostHeight - 0.2, 0.56);
      demoTracker.add(xBar1);
      
      const xBar2 = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.4, 0.03), whiteMat);
      xBar2.rotation.z = -Math.PI / 4;
      xBar2.rotation.x = Math.PI / 2;
      xBar2.position.set(-2, demoPostHeight - 0.2, 0.56);
      demoTracker.add(xBar2);
      
      // === ARRAY TECHNOLOGIES STYLE BEARING (right side) ===
      // Half-circle plate - FLAT EDGE VERTICAL, curve bulges to side
      const darkGalvMat = new THREE.MeshStandardMaterial({ color: 0x808080, metalness: 0.6, roughness: 0.3 });
      const boltMat = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, metalness: 0.9 });
      
      const fanRadius = 2.5;
      const fanThickness = 0.1;
      
      // Create half-circle with FLAT EDGE VERTICAL, curve bulging sideways
      const halfCircleShape = new THREE.Shape();
      halfCircleShape.moveTo(0, -fanRadius); // Bottom of vertical flat edge
      halfCircleShape.lineTo(0, fanRadius);   // Top of vertical flat edge
      halfCircleShape.absarc(0, 0, fanRadius, Math.PI/2, -Math.PI/2, true); // Curve bulges to +X
      
      const extrudeSettings = { depth: fanThickness, bevelEnabled: false };
      const halfCircleGeo = new THREE.ExtrudeGeometry(halfCircleShape, extrudeSettings);
      
      // Create canvas texture with "ARRAY" text
      const arrayFanCanvas = document.createElement('canvas');
      arrayFanCanvas.width = 512;
      arrayFanCanvas.height = 512;
      const afCtx = arrayFanCanvas.getContext('2d');
      
      // Gray metallic background
      afCtx.fillStyle = '#b8b8b8';
      afCtx.fillRect(0, 0, 512, 512);
      
      // Add subtle texture
      afCtx.fillStyle = '#a8a8a8';
      for (let i = 0; i < 150; i++) {
        afCtx.fillRect(Math.random() * 512, Math.random() * 512, 2, 2);
      }
      
      // Draw "ARRAY" vertically
      afCtx.fillStyle = '#505050';
      afCtx.font = 'bold 72px Arial';
      afCtx.textAlign = 'center';
      ['A', 'R', 'R', 'A', 'Y'].forEach((letter, idx) => {
        afCtx.fillText(letter, 256, 100 + idx * 75);
      });
      
      // Perforations along curve
      afCtx.fillStyle = '#303030';
      for (let i = 0; i < 14; i++) {
        const angle = -Math.PI/2 + (i / 13) * Math.PI;
        const cx = 256 + Math.cos(angle) * 200;
        const cy = 256 + Math.sin(angle) * 200;
        afCtx.beginPath();
        afCtx.arc(cx, cy, 10, 0, Math.PI * 2);
        afCtx.fill();
      }
      
      const arrayFanTexture = new THREE.CanvasTexture(arrayFanCanvas);
      
      const plateMat = new THREE.MeshStandardMaterial({ 
        map: arrayFanTexture,
        metalness: 0.55, 
        roughness: 0.35,
        side: THREE.DoubleSide
      });
      
      const halfCirclePlate = new THREE.Mesh(halfCircleGeo, plateMat);
      // Position so torque tube goes through center, curve bulges outward (+Z)
      halfCirclePlate.rotation.y = Math.PI / 2;
      halfCirclePlate.position.set(2, demoPostHeight, 0);
      demoTracker.add(halfCirclePlate);
      
      // Center tube clamp/bearing housing
      const clampHousing = new THREE.Mesh(
        new THREE.CylinderGeometry(0.5, 0.5, 0.6, 24),
        darkGalvMat
      );
      clampHousing.rotation.z = Math.PI / 2;
      clampHousing.position.set(2.0, demoPostHeight, 0);
      demoTracker.add(clampHousing);
      
      // Central pivot bolt
      const pivotBolt = new THREE.Mesh(
        new THREE.CylinderGeometry(0.15, 0.15, 0.7, 12),
        boltMat
      );
      pivotBolt.rotation.z = Math.PI / 2;
      pivotBolt.position.set(2, demoPostHeight, 0);
      demoTracker.add(pivotBolt);
      
      // Mounting bolts on plate
      const plateBoltPositions = [
        { y: 0.6, z: 0.5 }, { y: 0.6, z: -0.5 },
        { y: -0.6, z: 0.5 }, { y: -0.6, z: -0.5 },
        { y: 1.2, z: 0.3 }, { y: 1.2, z: -0.3 },
        { y: -1.2, z: 0.3 }, { y: -1.2, z: -0.3 },
        { y: 1.8, z: 0 }, { y: -1.8, z: 0 }
      ];
      plateBoltPositions.forEach(bp => {
        const bolt = new THREE.Mesh(
          new THREE.CylinderGeometry(0.05, 0.05, 0.16, 6),
          boltMat
        );
        bolt.rotation.z = Math.PI / 2;
        bolt.position.set(2 + 0.08, demoPostHeight + bp.y, bp.z);
        demoTracker.add(bolt);
      });
      
      // Small demo panels on the torque tube
      const demoPanelMat = new THREE.MeshStandardMaterial({ color: 0x1a3a5c, metalness: 0.4, roughness: 0.3 });
      for (let dp = -2; dp <= 2; dp++) {
        const demoPanel = new THREE.Mesh(
          new THREE.BoxGeometry(1.8, 0.08, 1),
          demoPanelMat
        );
        demoPanel.position.set(dp * 2, demoPostHeight + 0.4, 0);
        demoTracker.add(demoPanel);
      }
      
      // Position the demo tracker
      demoTracker.position.set(0, 0, 50);
      demoTracker.visible = false; // Hidden by default - shown via detail view
      // Don't add to scene yet - will be added when user clicks to view
      demoTrackerGroup = demoTracker; // Save reference for later
      
      // === DEMO COMBINER BOX DISPLAY MODEL ===
      // Professional museum-style combiner exhibit
      const demoCombiner = new THREE.Group();
      
      // === DISPLAY PLATFORM ===
      const combinerPad = new THREE.Mesh(
        new THREE.BoxGeometry(14, 0.4, 12),
        new THREE.MeshStandardMaterial({ color: 0x2a3a4a, roughness: 0.6, metalness: 0.3 })
      );
      combinerPad.position.y = 0.2;
      demoCombiner.add(combinerPad);
      
      // Platform edge trim (accent color - green for combiner)
      const combinerEdgeTrim = new THREE.Mesh(
        new THREE.BoxGeometry(14.2, 0.15, 12.2),
        new THREE.MeshStandardMaterial({ color: 0x10b981, metalness: 0.6 })
      );
      combinerEdgeTrim.position.y = 0.42;
      demoCombiner.add(combinerEdgeTrim);
      
      // === INFO BOARD (positioned to the left side) ===
      const combinerBoardGroup = new THREE.Group();
      
      // Board backing (facing forward)
      const combinerBoardBack = new THREE.Mesh(
        new THREE.BoxGeometry(5, 6, 0.15),
        new THREE.MeshStandardMaterial({ color: 0x1a2a3a, metalness: 0.2 })
      );
      combinerBoardGroup.add(combinerBoardBack);
      
      // Board frame
      const combinerFrameMat = new THREE.MeshStandardMaterial({ color: 0x10b981, metalness: 0.6 });
      const cFrameTop = new THREE.Mesh(new THREE.BoxGeometry(5.1, 0.15, 0.2), combinerFrameMat);
      cFrameTop.position.y = 3;
      combinerBoardGroup.add(cFrameTop);
      const cFrameBottom = new THREE.Mesh(new THREE.BoxGeometry(5.1, 0.15, 0.2), combinerFrameMat);
      cFrameBottom.position.y = -3;
      combinerBoardGroup.add(cFrameBottom);
      
      // Combiner info board content
      const combinerInfoCanvas = document.createElement('canvas');
      combinerInfoCanvas.width = 512;
      combinerInfoCanvas.height = 600;
      const ciCtx = combinerInfoCanvas.getContext('2d');
      
      ciCtx.fillStyle = '#0f1a24';
      ciCtx.fillRect(0, 0, 512, 600);
      
      ciCtx.fillStyle = '#10b981';
      ciCtx.font = 'bold 32px Arial';
      ciCtx.textAlign = 'center';
      ciCtx.fillText('DC COMBINER BOX', 256, 50);
      
      ciCtx.fillStyle = '#38bdf8';
      ciCtx.font = '16px Arial';
      ciCtx.fillText('Electrical Distribution Panel', 256, 78);
      
      ciCtx.strokeStyle = '#10b981';
      ciCtx.lineWidth = 2;
      ciCtx.beginPath();
      ciCtx.moveTo(40, 100);
      ciCtx.lineTo(472, 100);
      ciCtx.stroke();
      
      // Component Guide
      ciCtx.fillStyle = '#fff';
      ciCtx.font = 'bold 16px Arial';
      ciCtx.textAlign = 'left';
      ciCtx.fillText('COMPONENT GUIDE', 50, 130);
      
      ciCtx.font = '14px Arial';
      
      // Red
      ciCtx.fillStyle = '#f66';
      ciCtx.fillRect(50, 150, 16, 16);
      ciCtx.fillStyle = '#94a3b8';
      ciCtx.fillText('DC+ String Inputs (Red)', 75, 163);
      
      // Blue for DC-
      ciCtx.fillStyle = '#36c';
      ciCtx.fillRect(50, 180, 16, 16);
      ciCtx.fillStyle = '#94a3b8';
      ciCtx.fillText('DC- Terminals (Blue)', 75, 193);
      
      // Yellow
      ciCtx.fillStyle = '#fc0';
      ciCtx.fillRect(50, 210, 16, 16);
      ciCtx.fillStyle = '#94a3b8';
      ciCtx.fillText('Fuses - 15A (Yellow)', 75, 223);
      
      // Light Blue for SPD
      ciCtx.fillStyle = '#08f';
      ciCtx.fillRect(50, 240, 16, 16);
      ciCtx.fillStyle = '#94a3b8';
      ciCtx.fillText('Surge Protection (Lt Blue)', 75, 253);
      
      // Copper
      ciCtx.fillStyle = '#b87333';
      ciCtx.fillRect(50, 270, 16, 16);
      ciCtx.fillStyle = '#94a3b8';
      ciCtx.fillText('Bus Bars (Copper)', 75, 283);
      
      // Green light
      ciCtx.fillStyle = '#0f0';
      ciCtx.beginPath();
      ciCtx.arc(58, 308, 8, 0, Math.PI * 2);
      ciCtx.fill();
      ciCtx.fillStyle = '#94a3b8';
      ciCtx.fillText('SPD Status OK (Green)', 75, 313);
      
      // Key Functions
      ciCtx.fillStyle = '#fff';
      ciCtx.font = 'bold 16px Arial';
      ciCtx.fillText('KEY FUNCTIONS', 50, 360);
      
      ciCtx.font = '13px Arial';
      ciCtx.fillStyle = '#64748b';
      ciCtx.fillText('1.', 50, 385);
      ciCtx.fillStyle = '#94a3b8';
      ciCtx.fillText('Aggregates multiple strings', 70, 385);
      
      ciCtx.fillStyle = '#64748b';
      ciCtx.fillText('2.', 50, 408);
      ciCtx.fillStyle = '#94a3b8';
      ciCtx.fillText('Overcurrent protection (fuses)', 70, 408);
      
      ciCtx.fillStyle = '#64748b';
      ciCtx.fillText('3.', 50, 431);
      ciCtx.fillStyle = '#94a3b8';
      ciCtx.fillText('Surge protection (SPD)', 70, 431);
      
      ciCtx.fillStyle = '#64748b';
      ciCtx.fillText('4.', 50, 454);
      ciCtx.fillStyle = '#94a3b8';
      ciCtx.fillText('Output to inverter', 70, 454);
      
      // Stats
      ciCtx.fillStyle = '#1e293b';
      ciCtx.fillRect(40, 485, 200, 60);
      ciCtx.fillRect(270, 485, 200, 60);
      
      ciCtx.fillStyle = '#10b981';
      ciCtx.font = 'bold 24px Arial';
      ciCtx.textAlign = 'center';
      ciCtx.fillText('8 STRINGS', 140, 522);
      ciCtx.fillText('1500V DC', 370, 522);
      
      ciCtx.fillStyle = '#64748b';
      ciCtx.font = '11px Arial';
      ciCtx.fillText('INPUT CAPACITY', 140, 540);
      ciCtx.fillText('MAX VOLTAGE', 370, 540);
      
      const combinerInfoTexture = new THREE.CanvasTexture(combinerInfoCanvas);
      const combinerInfoMesh = new THREE.Mesh(
        new THREE.PlaneGeometry(4.8, 5.7),
        new THREE.MeshBasicMaterial({ map: combinerInfoTexture })
      );
      // Face forward (toward camera)
      combinerInfoMesh.position.z = 0.1;
      combinerBoardGroup.add(combinerInfoMesh);
      
      // Position board to the right side, facing forward
      combinerBoardGroup.position.set(6, 3.5, 4);
      combinerBoardGroup.rotation.y = 0;
      demoCombiner.add(combinerBoardGroup);
      
      // === COMBINER BOX COMPONENTS ===
      // Mounting post
      const combinerPostMat = new THREE.MeshStandardMaterial({ color: 0x666666, metalness: 0.5, roughness: 0.4 });
      const combinerPost = new THREE.Mesh(
        new THREE.BoxGeometry(0.3, 4, 0.3),
        combinerPostMat
      );
      combinerPost.position.set(-1.5, 2, 0);
      combinerPost.castShadow = true;
      demoCombiner.add(combinerPost);
      
      // === MAIN ENCLOSURE (NEMA rated box) - OPEN DOOR VIEW ===
      const enclosureMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.4, roughness: 0.5 });
      const enclosureDarkMat = new THREE.MeshStandardMaterial({ color: 0x999999, metalness: 0.5, roughness: 0.4 });
      
      // Main box body (back, sides, top, bottom - no front)
      const boxWidth = 3.5;
      const boxHeight = 4.5;
      const boxDepth = 1.0;
      
      // Back panel
      const backPanel = new THREE.Mesh(
        new THREE.BoxGeometry(boxWidth, boxHeight, 0.1),
        enclosureMat
      );
      backPanel.position.set(0, 2.5, -boxDepth / 2);
      demoCombiner.add(backPanel);
      
      // Left side panel
      const leftPanel = new THREE.Mesh(
        new THREE.BoxGeometry(0.1, boxHeight, boxDepth),
        enclosureMat
      );
      leftPanel.position.set(-boxWidth / 2, 2.5, 0);
      demoCombiner.add(leftPanel);
      
      // Right side panel
      const rightPanel = new THREE.Mesh(
        new THREE.BoxGeometry(0.1, boxHeight, boxDepth),
        enclosureMat
      );
      rightPanel.position.set(boxWidth / 2, 2.5, 0);
      demoCombiner.add(rightPanel);
      
      // Top panel
      const topPanel = new THREE.Mesh(
        new THREE.BoxGeometry(boxWidth, 0.1, boxDepth),
        enclosureMat
      );
      topPanel.position.set(0, 2.5 + boxHeight / 2, 0);
      demoCombiner.add(topPanel);
      
      // Bottom panel
      const bottomPanel = new THREE.Mesh(
        new THREE.BoxGeometry(boxWidth, 0.1, boxDepth),
        enclosureMat
      );
      bottomPanel.position.set(0, 2.5 - boxHeight / 2, 0);
      demoCombiner.add(bottomPanel);
      
      // Front frame lip (around door opening)
      const doorFrameMat = new THREE.MeshStandardMaterial({ color: 0x3a4a5a, metalness: 0.5 });
      
      // Left frame lip
      const leftFrameLip = new THREE.Mesh(
        new THREE.BoxGeometry(0.15, boxHeight, 0.15),
        doorFrameMat
      );
      leftFrameLip.position.set(-boxWidth / 2 + 0.075, 2.5, boxDepth / 2);
      demoCombiner.add(leftFrameLip);
      
      // Top frame lip
      const topFrameLip = new THREE.Mesh(
        new THREE.BoxGeometry(boxWidth, 0.15, 0.15),
        doorFrameMat
      );
      topFrameLip.position.set(0, 2.5 + boxHeight / 2 - 0.075, boxDepth / 2);
      demoCombiner.add(topFrameLip);
      
      // Bottom frame lip
      const bottomFrameLip = new THREE.Mesh(
        new THREE.BoxGeometry(boxWidth, 0.15, 0.15),
        doorFrameMat
      );
      bottomFrameLip.position.set(0, 2.5 - boxHeight / 2 + 0.075, boxDepth / 2);
      demoCombiner.add(bottomFrameLip);
      
      // Latch receiver on left frame (where door latches)
      const latchReceiverMat = new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.7 });
      const latchReceiver = new THREE.Mesh(
        new THREE.BoxGeometry(0.1, 0.4, 0.2),
        latchReceiverMat
      );
      latchReceiver.position.set(-boxWidth / 2 + 0.15, 2.5, boxDepth / 2 + 0.05);
      demoCombiner.add(latchReceiver);
      
      // === DOOR WITH PROPER HINGE PIVOT ===
      // Door group pivot is at the hinge (RIGHT edge - door swings right/clockwise)
      const doorGroup = new THREE.Group();
      
      // Door panel - offset to left of pivot so it swings correctly
      const doorPanel = new THREE.Mesh(
        new THREE.BoxGeometry(boxWidth - 0.2, boxHeight - 0.2, 0.12),
        enclosureDarkMat
      );
      // Offset door panel so pivot is at right edge (hinge side)
      doorPanel.position.set(-(boxWidth - 0.2) / 2, 0, 0);
      doorGroup.add(doorPanel);
      
      // Rubber gasket around door edge (visible from inside)
      const gasketMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.9 });
      // Left gasket
      const gasketLeft = new THREE.Mesh(
        new THREE.BoxGeometry(0.08, boxHeight - 0.4, 0.08),
        gasketMat
      );
      gasketLeft.position.set(-(boxWidth - 0.3), 0, -0.04);
      doorGroup.add(gasketLeft);
      // Top gasket
      const gasketTop = new THREE.Mesh(
        new THREE.BoxGeometry(boxWidth - 0.4, 0.08, 0.08),
        gasketMat
      );
      gasketTop.position.set(-(boxWidth - 0.2) / 2, (boxHeight - 0.4) / 2, -0.04);
      doorGroup.add(gasketTop);
      // Bottom gasket
      const gasketBottom = new THREE.Mesh(
        new THREE.BoxGeometry(boxWidth - 0.4, 0.08, 0.08),
        gasketMat
      );
      gasketBottom.position.set(-(boxWidth - 0.2) / 2, -(boxHeight - 0.4) / 2, -0.04);
      doorGroup.add(gasketBottom);
      // Right gasket (near hinge)
      const gasketRight = new THREE.Mesh(
        new THREE.BoxGeometry(0.08, boxHeight - 0.4, 0.08),
        gasketMat
      );
      gasketRight.position.set(-0.1, 0, -0.04);
      doorGroup.add(gasketRight);
      
      // Door handle on outside of door (visible when closed)
      const handleMat = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.8 });
      const doorHandleOuter = new THREE.Mesh(
        new THREE.BoxGeometry(0.15, 0.6, 0.15),
        handleMat
      );
      doorHandleOuter.position.set(-(boxWidth - 0.5), 0, 0.12);
      doorGroup.add(doorHandleOuter);
      
      // Door handle on inside (visible when open)
      const doorHandleInner = new THREE.Mesh(
        new THREE.BoxGeometry(0.12, 0.5, 0.12),
        handleMat
      );
      doorHandleInner.position.set(-(boxWidth - 0.5), 0, -0.12);
      doorGroup.add(doorHandleInner);
      
      // Warning label on inside of door
      const warningCanvas = document.createElement('canvas');
      warningCanvas.width = 256;
      warningCanvas.height = 128;
      const warnCtx = warningCanvas.getContext('2d');
      warnCtx.fillStyle = '#ffcc00';
      warnCtx.fillRect(0, 0, 256, 128);
      warnCtx.fillStyle = '#000';
      warnCtx.font = 'bold 24px Arial';
      warnCtx.textAlign = 'center';
      warnCtx.fillText('⚡ DANGER', 128, 40);
      warnCtx.font = '16px Arial';
      warnCtx.fillText('HIGH VOLTAGE', 128, 70);
      warnCtx.fillText('1500V DC', 128, 95);
      const warnTexture = new THREE.CanvasTexture(warningCanvas);
      const warnLabel = new THREE.Mesh(
        new THREE.PlaneGeometry(1.2, 0.6),
        new THREE.MeshBasicMaterial({ map: warnTexture })
      );
      warnLabel.position.set(-(boxWidth - 0.2) / 2, 0.8, -0.08);
      warnLabel.rotation.y = Math.PI;
      doorGroup.add(warnLabel);
      
      // Exterior warning label (visible when closed)
      const extWarnCanvas = document.createElement('canvas');
      extWarnCanvas.width = 256;
      extWarnCanvas.height = 128;
      const extWarnCtx = extWarnCanvas.getContext('2d');
      extWarnCtx.fillStyle = '#ff3300';
      extWarnCtx.fillRect(0, 0, 256, 128);
      extWarnCtx.fillStyle = '#fff';
      extWarnCtx.font = 'bold 20px Arial';
      extWarnCtx.textAlign = 'center';
      extWarnCtx.fillText('⚡ DANGER ⚡', 128, 35);
      extWarnCtx.font = '14px Arial';
      extWarnCtx.fillText('HIGH VOLTAGE', 128, 60);
      extWarnCtx.fillText('DO NOT OPEN', 128, 80);
      extWarnCtx.fillText('WHEN ENERGIZED', 128, 100);
      const extWarnTexture = new THREE.CanvasTexture(extWarnCanvas);
      const extWarnLabel = new THREE.Mesh(
        new THREE.PlaneGeometry(1.0, 0.5),
        new THREE.MeshBasicMaterial({ map: extWarnTexture })
      );
      extWarnLabel.position.set(-(boxWidth - 0.2) / 2, 1.2, 0.07);
      doorGroup.add(extWarnLabel);
      
      // Manufacturer nameplate on door exterior
      const nameplateCanvas = document.createElement('canvas');
      nameplateCanvas.width = 256;
      nameplateCanvas.height = 64;
      const npCtx = nameplateCanvas.getContext('2d');
      npCtx.fillStyle = '#444';
      npCtx.fillRect(0, 0, 256, 64);
      npCtx.fillStyle = '#ccc';
      npCtx.font = 'bold 16px Arial';
      npCtx.textAlign = 'center';
      npCtx.fillText('COMBINER BOX', 128, 25);
      npCtx.font = '12px Arial';
      npCtx.fillText('NEMA 4X • 1500VDC • 8 STRING', 128, 45);
      const npTexture = new THREE.CanvasTexture(nameplateCanvas);
      const nameplate = new THREE.Mesh(
        new THREE.PlaneGeometry(1.2, 0.3),
        new THREE.MeshBasicMaterial({ map: npTexture })
      );
      nameplate.position.set(-(boxWidth - 0.2) / 2, -1.5, 0.07);
      doorGroup.add(nameplate);
      
      // Latch mechanism on door edge
      const latchMat = new THREE.MeshStandardMaterial({ color: 0x666666, metalness: 0.7 });
      const doorLatch = new THREE.Mesh(
        new THREE.BoxGeometry(0.08, 0.3, 0.2),
        latchMat
      );
      doorLatch.position.set(-(boxWidth - 0.15), 0, 0);
      doorGroup.add(doorLatch);
      
      // Position door group at hinge location (right edge of box, front face)
      doorGroup.position.set(boxWidth / 2 - 0.1, 2.5, boxDepth / 2 + 0.06);
      doorGroup.rotation.y = Math.PI * 0.55; // Start open (clockwise)
      demoCombiner.add(doorGroup);
      combinerDoorGroup = doorGroup; // Save reference for open/close functionality
      
      // Door hinges (visible hardware)
      const hingeMat = new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.8 });
      
      // Top hinge
      const hingeTopPlate = new THREE.Mesh(
        new THREE.BoxGeometry(0.15, 0.4, 0.25),
        hingeMat
      );
      hingeTopPlate.position.set(boxWidth / 2 - 0.05, 4.0, boxDepth / 2 + 0.06);
      demoCombiner.add(hingeTopPlate);
      
      const hingeTopPin = new THREE.Mesh(
        new THREE.CylinderGeometry(0.05, 0.05, 0.5, 8),
        hingeMat
      );
      hingeTopPin.position.set(boxWidth / 2 - 0.1, 4.0, boxDepth / 2 + 0.06);
      demoCombiner.add(hingeTopPin);
      
      // Bottom hinge
      const hingeBottomPlate = new THREE.Mesh(
        new THREE.BoxGeometry(0.15, 0.4, 0.25),
        hingeMat
      );
      hingeBottomPlate.position.set(boxWidth / 2 - 0.05, 1.0, boxDepth / 2 + 0.06);
      demoCombiner.add(hingeBottomPlate);
      
      const hingeBottomPin = new THREE.Mesh(
        new THREE.CylinderGeometry(0.05, 0.05, 0.5, 8),
        hingeMat
      );
      hingeBottomPin.position.set(boxWidth / 2 - 0.1, 1.0, boxDepth / 2 + 0.06);
      demoCombiner.add(hingeBottomPin);
      
      // === INTERNAL BACKPLATE (gray mounting plate) ===
      const backplateMat = new THREE.MeshStandardMaterial({ color: 0x666666, metalness: 0.3 });
      const backplate = new THREE.Mesh(
        new THREE.BoxGeometry(boxWidth - 0.3, boxHeight - 0.3, 0.08),
        backplateMat
      );
      backplate.position.set(0, 2.5, -boxDepth / 2 + 0.15);
      demoCombiner.add(backplate);
      
      // === DIN RAILS (for mounting components) ===
      const dinRailMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.6 });
      for (let r = 0; r < 3; r++) {
        const dinRail = new THREE.Mesh(
          new THREE.BoxGeometry(boxWidth - 0.5, 0.15, 0.12),
          dinRailMat
        );
        dinRail.position.set(0, 3.8 - r * 1.2, -boxDepth / 2 + 0.25);
        demoCombiner.add(dinRail);
      }
      
      // === DC INPUT TERMINALS (Red & Black - visible from front) ===
      const dcPlusMat = new THREE.MeshStandardMaterial({ color: 0xcc3333, emissive: 0x331111 });
      const dcMinusMat = new THREE.MeshStandardMaterial({ color: 0x3366cc, emissive: 0x112244 }); // Blue for visibility
      
      // String inputs - 8 pairs arranged in two rows
      for (let i = 0; i < 8; i++) {
        const row = Math.floor(i / 4);
        const col = i % 4;
        const xPos = -1.2 + col * 0.55;
        const yPos = 3.7 - row * 0.7;
        
        // DC+ terminal block (red)
        const dcPlusTerminal = new THREE.Mesh(
          new THREE.BoxGeometry(0.2, 0.25, 0.35),
          dcPlusMat
        );
        dcPlusTerminal.position.set(xPos, yPos, -boxDepth / 2 + 0.4);
        demoCombiner.add(dcPlusTerminal);
        
        // DC- terminal block (blue) next to it
        const dcMinusTerminal = new THREE.Mesh(
          new THREE.BoxGeometry(0.2, 0.25, 0.35),
          dcMinusMat
        );
        dcMinusTerminal.position.set(xPos + 0.25, yPos, -boxDepth / 2 + 0.4);
        demoCombiner.add(dcMinusTerminal);
        
        // Input cable coming in from top (red)
        const inputCable = new THREE.Mesh(
          new THREE.CylinderGeometry(0.04, 0.04, 0.8, 8),
          dcPlusMat
        );
        inputCable.position.set(xPos, yPos + 0.5, -boxDepth / 2 + 0.4);
        demoCombiner.add(inputCable);
        
        // String number label
        const strNum = i + 1;
        const strCanvas = document.createElement('canvas');
        strCanvas.width = 64;
        strCanvas.height = 64;
        const strCtx = strCanvas.getContext('2d');
        strCtx.fillStyle = '#fff';
        strCtx.font = 'bold 32px Arial';
        strCtx.textAlign = 'center';
        strCtx.fillText(strNum.toString(), 32, 42);
        const strTexture = new THREE.CanvasTexture(strCanvas);
        const strLabel = new THREE.Mesh(
          new THREE.PlaneGeometry(0.25, 0.25),
          new THREE.MeshBasicMaterial({ map: strTexture, transparent: true })
        );
        strLabel.position.set(xPos + 0.1, yPos - 0.25, -boxDepth / 2 + 0.58);
        demoCombiner.add(strLabel);
      }
      
      // === FUSE HOLDERS WITH YELLOW FUSES ===
      const fuseMat = new THREE.MeshStandardMaterial({ color: 0xffcc00, emissive: 0x665500, emissiveIntensity: 0.4 });
      const fuseHolderMat = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.6 });
      
      for (let i = 0; i < 8; i++) {
        const row = Math.floor(i / 4);
        const col = i % 4;
        const xPos = -1.1 + col * 0.55;
        const yPos = 2.4 - row * 0.6;
        
        // Fuse holder base (dark gray)
        const fuseHolder = new THREE.Mesh(
          new THREE.BoxGeometry(0.4, 0.35, 0.35),
          fuseHolderMat
        );
        fuseHolder.position.set(xPos, yPos, -boxDepth / 2 + 0.35);
        demoCombiner.add(fuseHolder);
        
        // Fuse (bright yellow cylinder - stands out)
        const fuse = new THREE.Mesh(
          new THREE.CylinderGeometry(0.08, 0.08, 0.5, 12),
          fuseMat
        );
        fuse.rotation.z = Math.PI / 2;
        fuse.position.set(xPos, yPos + 0.05, -boxDepth / 2 + 0.5);
        demoCombiner.add(fuse);
        
        // Fuse rating label
        if (col === 0) {
          const fuseRatingCanvas = document.createElement('canvas');
          fuseRatingCanvas.width = 128;
          fuseRatingCanvas.height = 32;
          const frCtx = fuseRatingCanvas.getContext('2d');
          frCtx.fillStyle = '#ffcc00';
          frCtx.font = 'bold 18px Arial';
          frCtx.fillText('15A FUSES', 5, 22);
          const frTexture = new THREE.CanvasTexture(fuseRatingCanvas);
          const frLabel = new THREE.Mesh(
            new THREE.PlaneGeometry(0.8, 0.2),
            new THREE.MeshBasicMaterial({ map: frTexture, transparent: true })
          );
          frLabel.position.set(xPos + 0.8, yPos + 0.35, -boxDepth / 2 + 0.6);
          demoCombiner.add(frLabel);
        }
      }
      
      // === SURGE PROTECTION DEVICE (SPD - Blue, prominent) ===
      const spdMat = new THREE.MeshStandardMaterial({ color: 0x0066cc, emissive: 0x003366, emissiveIntensity: 0.3 });
      
      // SPD housing (larger, more visible)
      const spd = new THREE.Mesh(
        new THREE.BoxGeometry(0.8, 1.4, 0.5),
        spdMat
      );
      spd.position.set(1.1, 2.2, -boxDepth / 2 + 0.45);
      demoCombiner.add(spd);
      
      // SPD indicator window
      const spdWindowMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
      const spdWindow = new THREE.Mesh(
        new THREE.BoxGeometry(0.4, 0.3, 0.1),
        spdWindowMat
      );
      spdWindow.position.set(1.1, 2.6, -boxDepth / 2 + 0.72);
      demoCombiner.add(spdWindow);
      
      // SPD indicator light (green = OK)
      const spdLightMat = new THREE.MeshStandardMaterial({ color: 0x00ff00, emissive: 0x00ff00, emissiveIntensity: 1.0 });
      const spdLight = new THREE.Mesh(
        new THREE.SphereGeometry(0.1, 16, 16),
        spdLightMat
      );
      spdLight.position.set(1.1, 2.6, -boxDepth / 2 + 0.78);
      demoCombiner.add(spdLight);
      
      // SPD label
      const spdLabelCanvas = document.createElement('canvas');
      spdLabelCanvas.width = 128;
      spdLabelCanvas.height = 64;
      const spdLCtx = spdLabelCanvas.getContext('2d');
      spdLCtx.fillStyle = '#fff';
      spdLCtx.font = 'bold 16px Arial';
      spdLCtx.textAlign = 'center';
      spdLCtx.fillText('SPD', 64, 25);
      spdLCtx.font = '12px Arial';
      spdLCtx.fillText('Type 2', 64, 45);
      const spdLTexture = new THREE.CanvasTexture(spdLabelCanvas);
      const spdLLabel = new THREE.Mesh(
        new THREE.PlaneGeometry(0.5, 0.3),
        new THREE.MeshBasicMaterial({ map: spdLTexture, transparent: true })
      );
      spdLLabel.position.set(1.1, 1.7, -boxDepth / 2 + 0.72);
      demoCombiner.add(spdLLabel);
      
      // === BUS BARS (Copper - positive and negative) ===
      const copperMat = new THREE.MeshStandardMaterial({ color: 0xb87333, metalness: 0.85, roughness: 0.15 });
      
      // Positive bus bar (copper colored)
      const posBusBar = new THREE.Mesh(
        new THREE.BoxGeometry(0.2, 3.5, 0.1),
        copperMat
      );
      posBusBar.position.set(0.5, 2.3, -boxDepth / 2 + 0.25);
      demoCombiner.add(posBusBar);
      
      // Bus bar label +
      const busLabelPlusCanvas = document.createElement('canvas');
      busLabelPlusCanvas.width = 64;
      busLabelPlusCanvas.height = 64;
      const bpCtx = busLabelPlusCanvas.getContext('2d');
      bpCtx.fillStyle = '#c73';
      bpCtx.font = 'bold 48px Arial';
      bpCtx.textAlign = 'center';
      bpCtx.fillText('+', 32, 48);
      const bpTexture = new THREE.CanvasTexture(busLabelPlusCanvas);
      const bpLabel = new THREE.Mesh(
        new THREE.PlaneGeometry(0.3, 0.3),
        new THREE.MeshBasicMaterial({ map: bpTexture, transparent: true })
      );
      bpLabel.position.set(0.5, 4.2, -boxDepth / 2 + 0.35);
      demoCombiner.add(bpLabel);
      
      // Negative bus bar (darker)
      const negBusBar = new THREE.Mesh(
        new THREE.BoxGeometry(0.2, 3.5, 0.1),
        new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.7, roughness: 0.3 })
      );
      negBusBar.position.set(0.8, 2.3, -boxDepth / 2 + 0.25);
      demoCombiner.add(negBusBar);
      
      // Bus bar label -
      const busLabelMinusCanvas = document.createElement('canvas');
      busLabelMinusCanvas.width = 64;
      busLabelMinusCanvas.height = 64;
      const bmCtx = busLabelMinusCanvas.getContext('2d');
      bmCtx.fillStyle = '#666';
      bmCtx.font = 'bold 48px Arial';
      bmCtx.textAlign = 'center';
      bmCtx.fillText('-', 32, 48);
      const bmTexture = new THREE.CanvasTexture(busLabelMinusCanvas);
      const bmLabel = new THREE.Mesh(
        new THREE.PlaneGeometry(0.3, 0.3),
        new THREE.MeshBasicMaterial({ map: bmTexture, transparent: true })
      );
      bmLabel.position.set(0.8, 4.2, -boxDepth / 2 + 0.35);
      demoCombiner.add(bmLabel);
      
      // === OUTPUT CABLES (to inverter - bottom) ===
      // Large output cable (DC+)
      const outputCablePlus = new THREE.Mesh(
        new THREE.CylinderGeometry(0.12, 0.12, 1.5, 12),
        dcPlusMat
      );
      outputCablePlus.position.set(0.5, 0.3, 0.5);
      outputCablePlus.rotation.x = Math.PI / 2;
      demoCombiner.add(outputCablePlus);
      
      // Large output cable (DC-)
      const outputCableMinus = new THREE.Mesh(
        new THREE.CylinderGeometry(0.12, 0.12, 1.5, 12),
        dcMinusMat
      );
      outputCableMinus.position.set(0.8, 0.3, 0.5);
      outputCableMinus.rotation.x = Math.PI / 2;
      demoCombiner.add(outputCableMinus);
      
      // Position the demo combiner
      demoCombiner.position.set(0, 0, 80);
      demoCombiner.visible = false; // Hidden by default - shown via detail view
      // Don't add to scene yet - will be added when user clicks to view
      demoCombinerGroup = demoCombiner; // Save reference for later
      
      // BARBED WIRE FENCE
      const fencePostMat = new THREE.MeshStandardMaterial({ color: 0x4a3520, metalness: 0.3, roughness: 0.7 }); // Wood posts
      const wireMat = new THREE.MeshStandardMaterial({ color: 0x3a3a3a, metalness: 0.8, roughness: 0.3 });
      
      const fenceH = 4;
      const postSpacing = 10;
      const fenceMinX = -280, fenceMaxX = 280, fenceMinZ = -140, fenceMaxZ = 200;
      const wireHeights = [0.5, 1.2, 2.0, 2.8, 3.6]; // 5 strands of barbed wire
      
      function createBarbedWireSide(startX, startZ, endX, endZ) {
        const dx = endX - startX;
        const dz = endZ - startZ;
        const length = Math.sqrt(dx * dx + dz * dz);
        const numPosts = Math.floor(length / postSpacing) + 1;
        const angle = Math.atan2(dz, dx);
        
        // Posts
        for (let i = 0; i <= numPosts; i++) {
          const t = i / numPosts;
          const x = startX + dx * t;
          const z = startZ + dz * t;
          
          // Wooden fence post (T-post or wood post style)
          const post = new THREE.Mesh(
            new THREE.BoxGeometry(0.15, fenceH, 0.15),
            fencePostMat
          );
          post.position.set(x, fenceH / 2, z);
          post.castShadow = true;
          scene.add(post);
          
          // Post top (pointed)
          const postTop = new THREE.Mesh(
            new THREE.ConeGeometry(0.12, 0.3, 4),
            fencePostMat
          );
          postTop.position.set(x, fenceH + 0.15, z);
          postTop.rotation.y = Math.PI / 4;
          scene.add(postTop);
        }
        
        // Barbed wire strands
        wireHeights.forEach(h => {
          const wire = new THREE.Mesh(
            new THREE.CylinderGeometry(0.02, 0.02, length, 6),
            wireMat
          );
          wire.position.set((startX + endX) / 2, h, (startZ + endZ) / 2);
          wire.rotation.z = Math.PI / 2;
          wire.rotation.y = -angle;
          scene.add(wire);
        });
      }
      
      // Create all four sides
      createBarbedWireSide(fenceMinX, fenceMinZ, fenceMaxX, fenceMinZ);
      createBarbedWireSide(fenceMaxX, fenceMinZ, fenceMaxX, fenceMaxZ);
      createBarbedWireSide(fenceMaxX, fenceMaxZ, fenceMinX, fenceMaxZ);
      createBarbedWireSide(fenceMinX, fenceMaxZ, fenceMinX, fenceMinZ);
    }
    
    // Function to create all tracker rows based on current panel style
    function createAllTrackerRows() {
      const mats = window.farmMats;
      if (!mats) return;
      
      // Panel configuration based on style
      let panelW, panelH, panelGap, panelsPerRow, numPanelsPerTable;
      
      if (currentPanelStyle === '2L') {
        // 2 Landscape panels (original) - panels laid flat horizontally
        panelW = 5.5;   // Width along torque tube
        panelH = 2.2;   // Height perpendicular to torque tube
        panelGap = 0.15;
        panelsPerRow = 40;
        numPanelsPerTable = 2;
      } else if (currentPanelStyle === '2P') {
        // 2 Portrait panels - rotated 90 degrees
        panelW = 2.2;   // Narrower along torque tube
        panelH = 5.5;   // Taller perpendicular to torque tube
        panelGap = 0.15;
        panelsPerRow = 100;
        numPanelsPerTable = 2;
      } else if (currentPanelStyle === '1P') {
        // 1 Portrait panel - single panel
        panelW = 2.2;
        panelH = 5.5;
        panelGap = 0.15;
        panelsPerRow = 100;
        numPanelsPerTable = 1;
      }
      
      const pileSpacing = 18;
      const pileHeight = 5;
      const tilt = 0.3;
      const torqueRadius = 0.6;
      const numRows = 14;
      const rowSpacing = 18;
      
      // Left block
      for (let row = 0; row < numRows; row++) {
        const zPos = row * rowSpacing - ((numRows - 1) * rowSpacing) / 2;
        if (Math.abs(zPos) < 12) continue;
        createTrackerRow(-140, zPos, panelW, panelH, panelGap, panelsPerRow, numPanelsPerTable, pileSpacing, pileHeight, tilt, torqueRadius, mats.panelMat, mats.frameMat, mats.torqueMat, mats.postMat, mats.inverterMat, mats.inverterGrayMat, mats.ventMat);
      }
      
      // Right block
      for (let row = 0; row < numRows; row++) {
        const zPos = row * rowSpacing - ((numRows - 1) * rowSpacing) / 2;
        if (Math.abs(zPos) < 12) continue;
        createTrackerRow(140, zPos, panelW, panelH, panelGap, panelsPerRow, numPanelsPerTable, pileSpacing, pileHeight, tilt, torqueRadius, mats.panelMat, mats.frameMat, mats.torqueMat, mats.postMat, mats.inverterMat, mats.inverterGrayMat, mats.ventMat);
      }
    }
    
    function createTrackerRow(xCenter, zPos, panelW, panelH, panelGap, panelsPerRow, numPanelsPerTable, pileSpacing, pileHeight, tilt, torqueRadius, panelMat, frameMat, torqueMat, postMat, inverterMat, inverterGrayMat, ventMat) {
      const tracker = new THREE.Group();
      const rowLength = panelsPerRow * (panelW + panelGap);
      
      // THICK TORQUE TUBE
      const torqueTube = new THREE.Mesh(
        new THREE.CylinderGeometry(torqueRadius, torqueRadius, rowLength + 3, 16),
        torqueMat
      );
      torqueTube.rotation.z = Math.PI / 2;
      torqueTube.position.y = pileHeight;
      torqueTube.castShadow = true;
      tracker.add(torqueTube);
      
      // POSTS with INVERTERS ON EVERY POST
      const numPiles = Math.floor(rowLength / pileSpacing) + 1;
      for (let i = 0; i <= numPiles; i++) {
        const px = -rowLength / 2 + i * pileSpacing;
        if (Math.abs(px) > rowLength / 2 + 2) continue;
        
        // W-beam post
        const pileWeb = new THREE.Mesh(
          new THREE.BoxGeometry(0.2, pileHeight + 0.4, 0.5),
          postMat
        );
        pileWeb.position.set(px, pileHeight / 2 - 0.2, 0);
        pileWeb.castShadow = true;
        tracker.add(pileWeb);
        
        // Flanges
        const flange1 = new THREE.Mesh(
          new THREE.BoxGeometry(0.5, pileHeight + 0.4, 0.08),
          postMat
        );
        flange1.position.set(px, pileHeight / 2 - 0.2, 0.22);
        tracker.add(flange1);
        
        const flange2 = new THREE.Mesh(
          new THREE.BoxGeometry(0.5, pileHeight + 0.4, 0.08),
          postMat
        );
        flange2.position.set(px, pileHeight / 2 - 0.2, -0.22);
        tracker.add(flange2);
        
        // === REALISTIC TRACKER BEARING ASSEMBLY ===
        // Alternates between Array Technologies and Nextracker styles
        const isArrayStyle = i % 2 === 0; // Alternate styles
        
        const galvanizedMat = new THREE.MeshStandardMaterial({ color: 0xa5a5a5, metalness: 0.65, roughness: 0.25 });
        const darkGalvMat = new THREE.MeshStandardMaterial({ color: 0x707070, metalness: 0.6, roughness: 0.3 });
        const boltMat = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, metalness: 0.9, roughness: 0.15 });
        
        if (isArrayStyle) {
          // === ARRAY TECHNOLOGIES STYLE ===
          // Half-circle plate - FLAT EDGE VERTICAL, curve bulges to side
          
          const clampMat = new THREE.MeshStandardMaterial({ color: 0x909090, metalness: 0.7, roughness: 0.25 });
          
          // Tube clamp housing
          const clampRadius = torqueRadius + 0.12;
          const tubeClamp = new THREE.Mesh(
            new THREE.CylinderGeometry(clampRadius + 0.08, clampRadius + 0.08, 0.4, 20),
            clampMat
          );
          tubeClamp.rotation.z = Math.PI / 2;
          tubeClamp.position.set(px, pileHeight, 0);
          tracker.add(tubeClamp);
          
          const fanRadius = 1.8;
          const fanThickness = 0.06;
          
          // Create half-circle with FLAT EDGE VERTICAL, curve bulging sideways
          const halfCircleShape = new THREE.Shape();
          halfCircleShape.moveTo(0, -fanRadius); // Bottom of vertical flat edge
          halfCircleShape.lineTo(0, fanRadius);   // Top of vertical flat edge
          halfCircleShape.absarc(0, 0, fanRadius, Math.PI/2, -Math.PI/2, true); // Curve bulges to +X
          
          const extrudeSettings = { depth: fanThickness, bevelEnabled: false };
          const halfCircleGeo = new THREE.ExtrudeGeometry(halfCircleShape, extrudeSettings);
          
          // Create canvas texture with "ARRAY" text
          const arrayCanvas = document.createElement('canvas');
          arrayCanvas.width = 256;
          arrayCanvas.height = 256;
          const actx = arrayCanvas.getContext('2d');
          
          // Gray metallic background
          actx.fillStyle = '#b0b0b0';
          actx.fillRect(0, 0, 256, 256);
          
          // Draw "ARRAY" vertically
          actx.fillStyle = '#606060';
          actx.font = 'bold 36px Arial';
          actx.textAlign = 'center';
          ['A', 'R', 'R', 'A', 'Y'].forEach((letter, idx) => {
            actx.fillText(letter, 128, 55 + idx * 38);
          });
          
          // Perforations along curve
          actx.fillStyle = '#404040';
          for (let i = 0; i < 10; i++) {
            const angle = -Math.PI/2 + (i / 9) * Math.PI;
            actx.beginPath();
            actx.arc(128 + Math.cos(angle) * 100, 128 + Math.sin(angle) * 100, 6, 0, Math.PI * 2);
            actx.fill();
          }
          
          const arrayTexture = new THREE.CanvasTexture(arrayCanvas);
          
          const plateMat = new THREE.MeshStandardMaterial({ 
            map: arrayTexture,
            metalness: 0.5, 
            roughness: 0.4,
            side: THREE.DoubleSide
          });
          
          const halfCirclePlate = new THREE.Mesh(halfCircleGeo, plateMat);
          // Position so torque tube goes through center, curve bulges outward
          halfCirclePlate.rotation.y = Math.PI / 2;
          halfCirclePlate.position.set(px, pileHeight, 0);
          tracker.add(halfCirclePlate);
          
          // Store reference for highlighting
          bearingPlates.push({ mesh: halfCirclePlate, rowZ: zPos, xCenter: xCenter, originalMat: plateMat, isHighlighted: false });
          
          // Center bearing bolt
          const pivotBolt = new THREE.Mesh(
            new THREE.CylinderGeometry(0.1, 0.1, 0.4, 12),
            boltMat
          );
          pivotBolt.rotation.z = Math.PI / 2;
          pivotBolt.position.set(px, pileHeight, 0);
          tracker.add(pivotBolt);
          
          // Mounting bolts
          const boltPositions = [
            { y: 0.5, z: 0.3 }, { y: 0.5, z: -0.3 },
            { y: -0.5, z: 0.3 }, { y: -0.5, z: -0.3 },
            { y: 1.0, z: 0 }, { y: -1.0, z: 0 }
          ];
          boltPositions.forEach(bp => {
            const bolt = new THREE.Mesh(
              new THREE.CylinderGeometry(0.035, 0.035, 0.12, 6),
              boltMat
            );
            bolt.rotation.z = Math.PI / 2;
            bolt.position.set(px + 0.05, pileHeight + bp.y, bp.z);
            tracker.add(bolt);
          });
          
        } else {
          // === NEXTRACKER STYLE ===
          // Compact bearing with prominent orange X badge (matches reference image)
          
          const housingRadius = torqueRadius + 0.25;
          const nexClampMat = new THREE.MeshStandardMaterial({ color: 0x505050, metalness: 0.75, roughness: 0.25 });
          
          // Bearing housing (rectangular box style like in reference)
          const bearingBox = new THREE.Mesh(
            new THREE.BoxGeometry(0.5, 0.7, 0.6),
            nexClampMat
          );
          bearingBox.position.set(px, pileHeight, 0);
          tracker.add(bearingBox);
          
          // Clamp ears extending to sides
          const earMat = new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.7, roughness: 0.3 });
          const leftEar = new THREE.Mesh(
            new THREE.BoxGeometry(0.35, 0.15, 0.15),
            earMat
          );
          leftEar.position.set(px, pileHeight + 0.3, 0.35);
          tracker.add(leftEar);
          
          const rightEar = new THREE.Mesh(
            new THREE.BoxGeometry(0.35, 0.15, 0.15),
            earMat
          );
          rightEar.position.set(px, pileHeight + 0.3, -0.35);
          tracker.add(rightEar);
          
          // Vertical support bracket below bearing
          const vBracket = new THREE.Mesh(
            new THREE.BoxGeometry(0.15, 0.6, 0.4),
            nexClampMat
          );
          vBracket.position.set(px, pileHeight - 0.55, 0);
          tracker.add(vBracket);
          
          // === ORANGE NEXTRACKER BADGE WITH X LOGO ===
          const orangeMat = new THREE.MeshStandardMaterial({ 
            color: 0xff6600, 
            emissive: 0xff4400, 
            emissiveIntensity: 0.1,
            metalness: 0.3,
            roughness: 0.5
          });
          
          // Orange circular badge (prominent like in reference)
          const badgeRadius = 0.22;
          const badge = new THREE.Mesh(
            new THREE.CylinderGeometry(badgeRadius, badgeRadius, 0.06, 24),
            orangeMat
          );
          badge.rotation.x = Math.PI / 2;
          badge.position.set(px, pileHeight - 0.15, 0.35);
          tracker.add(badge);
          
          // White X logo on badge
          const whiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 0.1, roughness: 0.7 });
          
          // X bar 1 (diagonal)
          const xBar1 = new THREE.Mesh(
            new THREE.BoxGeometry(0.05, 0.28, 0.02),
            whiteMat
          );
          xBar1.rotation.z = Math.PI / 4;
          xBar1.rotation.x = Math.PI / 2;
          xBar1.position.set(px, pileHeight - 0.15, 0.39);
          tracker.add(xBar1);
          
          // X bar 2 (diagonal other way)
          const xBar2 = new THREE.Mesh(
            new THREE.BoxGeometry(0.05, 0.28, 0.02),
            whiteMat
          );
          xBar2.rotation.z = -Math.PI / 4;
          xBar2.rotation.x = Math.PI / 2;
          xBar2.position.set(px, pileHeight - 0.15, 0.39);
          tracker.add(xBar2);
          
          // Small mounting bolts
          [-0.2, 0.2].forEach(zOff => {
            const topBolt = new THREE.Mesh(
              new THREE.CylinderGeometry(0.03, 0.03, 0.12, 6),
              boltMat
            );
            topBolt.position.set(px, pileHeight + 0.4, zOff);
            tracker.add(topBolt);
          });
        }
        
        // Post cap (top of W-beam) - both styles
        const capMat = new THREE.MeshStandardMaterial({ color: 0x777777, metalness: 0.6, roughness: 0.35 });
        const postCap = new THREE.Mesh(
          new THREE.BoxGeometry(0.55, 0.1, 0.6),
          capMat
        );
        postCap.position.set(px, pileHeight + 0.55, 0);
        tracker.add(postCap);
        
        // === STRING INVERTER ON EVERY POST - BIGGER ===
        const invY = pileHeight * 0.5;
        
        // Main inverter enclosure - BIGGER
        const inverterBody = new THREE.Mesh(
          new THREE.BoxGeometry(1.8, 1.3, 0.55),
          inverterMat
        );
        inverterBody.position.set(px, invY, 0.95);
        inverterBody.castShadow = true;
        tracker.add(inverterBody);
        
        // Store reference for highlighting
        inverterBoxes.push({ mesh: inverterBody, rowZ: zPos, xCenter: xCenter, px: px, originalMat: inverterMat, isHighlighted: false });
        
        // Front panel (lighter gray) - BIGGER
        const frontPanel = new THREE.Mesh(
          new THREE.BoxGeometry(1.5, 1.0, 0.03),
          inverterGrayMat
        );
        frontPanel.position.set(px, invY, 1.24);
        tracker.add(frontPanel);
        
        // Vent grilles (top) - BIGGER
        const ventTop = new THREE.Mesh(
          new THREE.BoxGeometry(1.3, 0.2, 0.56),
          ventMat
        );
        ventTop.position.set(px, invY + 0.58, 0.95);
        tracker.add(ventTop);
        
        // Vent grilles (bottom) - BIGGER
        const ventBottom = new THREE.Mesh(
          new THREE.BoxGeometry(1.3, 0.15, 0.56),
          ventMat
        );
        ventBottom.position.set(px, invY - 0.6, 0.95);
        tracker.add(ventBottom);
        
        // Display screen - BIGGER
        const screen = new THREE.Mesh(
          new THREE.BoxGeometry(0.65, 0.4, 0.03),
          new THREE.MeshStandardMaterial({ color: 0x1a4a1a, emissive: 0x0a3a0a, emissiveIntensity: 0.4 })
        );
        screen.position.set(px - 0.3, invY + 0.2, 1.26);
        tracker.add(screen);
        
        // LED indicators (3 LEDs) - BIGGER
        const ledColors = [0x00ff00, 0x00ff00, 0xffaa00];
        for (let l = 0; l < 3; l++) {
          const led = new THREE.Mesh(
            new THREE.SphereGeometry(0.06, 10, 10),
            new THREE.MeshStandardMaterial({ color: ledColors[l], emissive: ledColors[l], emissiveIntensity: 1.0 })
          );
          led.position.set(px + 0.45, invY + 0.32 - l * 0.16, 1.26);
          tracker.add(led);
        }
        
        // Brand label area - BIGGER
        const label = new THREE.Mesh(
          new THREE.BoxGeometry(0.8, 0.18, 0.015),
          new THREE.MeshStandardMaterial({ color: 0xffffff })
        );
        label.position.set(px, invY - 0.32, 1.26);
        tracker.add(label);
        
        // === WIRING HARNESS - BIGGER AND BRIGHTER ===
        const cableMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.8 });
        const redCableMat = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0x660000, emissiveIntensity: 0.5, roughness: 0.4 });
        const blueCableMat = new THREE.MeshStandardMaterial({ color: 0x0088ff, emissive: 0x003366, emissiveIntensity: 0.5, roughness: 0.4 });
        const greenCableMat = new THREE.MeshStandardMaterial({ color: 0x00ff00, emissive: 0x006600, emissiveIntensity: 0.5, roughness: 0.4 });
        const conduitMat = new THREE.MeshStandardMaterial({ color: 0x606060, metalness: 0.5, roughness: 0.4 });
        const cableTieMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.5 });
        
        // Main conduit coming down from panels to inverter - BIGGER
        const mainConduit = new THREE.Mesh(
          new THREE.CylinderGeometry(0.18, 0.18, 2.8, 12),
          conduitMat
        );
        mainConduit.position.set(px - 0.55, invY + 1.6, 0.7);
        tracker.add(mainConduit);
        
        // Conduit bend (horizontal section into inverter) - BIGGER
        const conduitBend = new THREE.Mesh(
          new THREE.CylinderGeometry(0.18, 0.18, 0.6, 12),
          conduitMat
        );
        conduitBend.rotation.x = Math.PI / 2;
        conduitBend.position.set(px - 0.55, invY + 0.35, 0.9);
        tracker.add(conduitBend);
        
        // DC input cables - MUCH THICKER AND BRIGHTER
        // Red DC+ cable running along side - MOVED OUT FOR VISIBILITY
        const dcCableRed = new THREE.Mesh(
          new THREE.CylinderGeometry(0.1, 0.1, 2.5, 10),
          redCableMat
        );
        dcCableRed.position.set(px - 0.85, invY + 1.5, 1.2);
        tracker.add(dcCableRed);
        
        // Red cable horizontal run to inverter
        const dcCableRedH = new THREE.Mesh(
          new THREE.CylinderGeometry(0.1, 0.1, 0.45, 10),
          redCableMat
        );
        dcCableRedH.rotation.z = Math.PI / 2;
        dcCableRedH.position.set(px - 0.65, invY + 0.3, 1.2);
        tracker.add(dcCableRedH);
        
        // Red cable into inverter
        const dcCableRedIn = new THREE.Mesh(
          new THREE.CylinderGeometry(0.1, 0.1, 0.3, 10),
          redCableMat
        );
        dcCableRedIn.rotation.x = Math.PI / 2;
        dcCableRedIn.position.set(px - 0.45, invY + 0.3, 1.05);
        tracker.add(dcCableRedIn);
        
        // Blue DC- cable running along side
        const dcCableBlue = new THREE.Mesh(
          new THREE.CylinderGeometry(0.1, 0.1, 2.5, 10),
          blueCableMat
        );
        dcCableBlue.position.set(px - 0.65, invY + 1.5, 1.2);
        tracker.add(dcCableBlue);
        
        // Blue cable horizontal run to inverter
        const dcCableBlueH = new THREE.Mesh(
          new THREE.CylinderGeometry(0.1, 0.1, 0.45, 10),
          blueCableMat
        );
        dcCableBlueH.rotation.z = Math.PI / 2;
        dcCableBlueH.position.set(px - 0.45, invY + 0.05, 1.2);
        tracker.add(dcCableBlueH);
        
        // Blue cable into inverter
        const dcCableBlueIn = new THREE.Mesh(
          new THREE.CylinderGeometry(0.1, 0.1, 0.3, 10),
          blueCableMat
        );
        dcCableBlueIn.rotation.x = Math.PI / 2;
        dcCableBlueIn.position.set(px - 0.25, invY + 0.05, 1.05);
        tracker.add(dcCableBlueIn);
        
        // DC disconnect box - BIGGER
        const dcDisconnect = new THREE.Mesh(
          new THREE.BoxGeometry(0.5, 0.55, 0.28),
          new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.5, roughness: 0.5 })
        );
        dcDisconnect.position.set(px - 0.75, invY - 0.1, 0.8);
        tracker.add(dcDisconnect);
        
        // Disconnect handle - BIGGER
        const dcHandle = new THREE.Mesh(
          new THREE.BoxGeometry(0.22, 0.12, 0.08),
          new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0x550000 })
        );
        dcHandle.position.set(px - 0.75, invY + 0.0, 0.95);
        tracker.add(dcHandle);
        
        // AC output conduit (going down post to ground) - BIGGER
        const acConduit = new THREE.Mesh(
          new THREE.CylinderGeometry(0.14, 0.14, invY - 0.1, 12),
          conduitMat
        );
        acConduit.position.set(px + 0.6, (invY - 0.1) / 2, 0.75);
        tracker.add(acConduit);
        
        // AC conduit elbow at inverter - BIGGER
        const acElbow = new THREE.Mesh(
          new THREE.CylinderGeometry(0.14, 0.14, 0.45, 12),
          conduitMat
        );
        acElbow.rotation.x = Math.PI / 2;
        acElbow.position.set(px + 0.6, invY - 0.35, 0.95);
        tracker.add(acElbow);
        
        // Ground wire (bright green) running down post - MUCH THICKER
        const groundWire = new THREE.Mesh(
          new THREE.CylinderGeometry(0.07, 0.07, pileHeight, 10),
          greenCableMat
        );
        groundWire.position.set(px + 0.3, pileHeight / 2, 0.48);
        tracker.add(groundWire);
        
        // Ground wire horizontal to inverter - BIGGER
        const groundWireH = new THREE.Mesh(
          new THREE.CylinderGeometry(0.07, 0.07, 0.6, 10),
          greenCableMat
        );
        groundWireH.rotation.x = Math.PI / 2;
        groundWireH.position.set(px + 0.3, invY - 0.4, 0.75);
        tracker.add(groundWireH);
        
        // Ground lug on post - BIGGER
        const groundLug = new THREE.Mesh(
          new THREE.BoxGeometry(0.2, 0.2, 0.12),
          new THREE.MeshStandardMaterial({ color: 0x00dd00, emissive: 0x004400, metalness: 0.6, roughness: 0.3 })
        );
        groundLug.position.set(px + 0.3, 0.35, 0.42);
        tracker.add(groundLug);
        
        // CABLE TIES / CLAMPS - MUCH LARGER AND VISIBLE
        // Cable ties on DC cables - in front where visible - BIGGER
        for (let ct = 0; ct < 4; ct++) {
          const cableTie = new THREE.Mesh(
            new THREE.TorusGeometry(0.2, 0.045, 10, 20),
            cableTieMat
          );
          cableTie.position.set(px - 0.75, invY + 0.5 + ct * 0.55, 1.2);
          cableTie.rotation.y = Math.PI / 2;
          tracker.add(cableTie);
        }
        
        // Cable clamps on conduit (metal) - BIGGER
        for (let cc = 0; cc < 3; cc++) {
          const clamp = new THREE.Mesh(
            new THREE.TorusGeometry(0.22, 0.05, 10, 20),
            new THREE.MeshStandardMaterial({ color: 0x999999, metalness: 0.7, roughness: 0.3 })
          );
          clamp.position.set(px - 0.55, invY + 0.85 + cc * 0.65, 0.7);
          clamp.rotation.y = Math.PI / 2;
          tracker.add(clamp);
          
          // Clamp screw - BIGGER
          const screw = new THREE.Mesh(
            new THREE.CylinderGeometry(0.035, 0.035, 0.14, 8),
            new THREE.MeshStandardMaterial({ color: 0x777777, metalness: 0.8 })
          );
          screw.rotation.x = Math.PI / 2;
          screw.position.set(px - 0.55, invY + 0.85 + cc * 0.65, 0.95);
          tracker.add(screw);
        }
        
        // Cable ties on ground wire - BIGGER
        for (let gt = 0; gt < 3; gt++) {
          const groundTie = new THREE.Mesh(
            new THREE.TorusGeometry(0.12, 0.035, 10, 16),
            greenCableMat
          );
          groundTie.position.set(px + 0.3, 0.9 + gt * 1.3, 0.48);
          groundTie.rotation.y = Math.PI / 2;
          tracker.add(groundTie);
        }
        
        // Mounting bracket - BIGGER
        const bracket = new THREE.Mesh(
          new THREE.BoxGeometry(0.18, 0.9, 0.65),
          postMat
        );
        bracket.position.set(px, invY, 0.55);
        tracker.add(bracket);
      }
      
      // PANEL TABLE
      const panelTable = new THREE.Group();
      panelTable.position.y = pileHeight;
      
      // Purlins - adjust positions based on panel configuration
      let purlinPositions;
      if (numPanelsPerTable === 2) {
        // 2L or 2P: purlins at outer edges and center (for 2 panels)
        // For 2 panels, total span is 2*panelH + gap, purlins at edges and center
        purlinPositions = [-panelH - 0.12, 0, panelH + 0.12];
      } else if (numPanelsPerTable === 1) {
        // 1P - single panel centered at z=0
        // For 1P with panelH=5.5, panel goes from z=-2.75 to z=+2.75
        // Purlins should be tight within the panel: top edge, center, bottom edge
        const halfPanel = panelH / 2;
        purlinPositions = [-(halfPanel - 1.0), 0, (halfPanel - 1.0)];
      } else {
        // Fallback
        purlinPositions = [-panelH - 0.12, 0, panelH + 0.12];
      }
      
      purlinPositions.forEach(pz => {
        const purlin = new THREE.Mesh(
          new THREE.BoxGeometry(rowLength + 2, 0.12, 0.08),
          postMat
        );
        purlin.position.set(0, torqueRadius + 0.08, pz);
        tracker.add(purlin);
      });
      
      // INDIVIDUAL PANELS
      for (let p = 0; p < panelsPerRow; p++) {
        const px = (p - (panelsPerRow - 1) / 2) * (panelW + panelGap);
        
        if (numPanelsPerTable === 2) {
          // 2L or 2P - Upper panel
          const panelUpper = new THREE.Mesh(
            new THREE.BoxGeometry(panelW, 0.06, panelH),
            panelMat
          );
          panelUpper.position.set(px, torqueRadius + 0.15, -panelH / 2 - 0.12);
          panelUpper.castShadow = true;
          panelUpper.receiveShadow = true;
          panelTable.add(panelUpper);
          
          // Lower panel
          const panelLower = new THREE.Mesh(
            new THREE.BoxGeometry(panelW, 0.06, panelH),
            panelMat
          );
          panelLower.position.set(px, torqueRadius + 0.15, panelH / 2 + 0.12);
          panelLower.castShadow = true;
          panelLower.receiveShadow = true;
          panelTable.add(panelLower);
        } else {
          // 1P - Single panel centered
          const singlePanel = new THREE.Mesh(
            new THREE.BoxGeometry(panelW, 0.06, panelH),
            panelMat
          );
          singlePanel.position.set(px, torqueRadius + 0.15, 0);
          singlePanel.castShadow = true;
          singlePanel.receiveShadow = true;
          panelTable.add(singlePanel);
        }
        
        // === BACK OF PANEL WIRING - LARGER AND BRIGHTER ===
        const backWireRed = new THREE.MeshStandardMaterial({ 
          color: 0xff2200, 
          roughness: 0.4, 
          metalness: 0.2,
          emissive: 0xff0000,
          emissiveIntensity: 0.6
        }); // Bright red DC+ cable - highly visible
        const backWireBlack = new THREE.MeshStandardMaterial({ 
          color: 0x2244aa, 
          roughness: 0.5, 
          metalness: 0.2,
          emissive: 0x1133aa,
          emissiveIntensity: 0.4
        }); // Blue DC- cable for visibility
        const mc4Mat = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.5, roughness: 0.4 });
        const junctionMat = new THREE.MeshStandardMaterial({ color: 0xffdd00, roughness: 0.3, emissive: 0xffaa00, emissiveIntensity: 0.5 });
        
        // Junction boxes
        if (numPanelsPerTable === 2) {
          // Junction box on back of upper panel - attached to panel back - BIGGER
          const jBoxUpper = new THREE.Mesh(
            new THREE.BoxGeometry(0.7, 0.18, 0.4),
            junctionMat
          );
          jBoxUpper.position.set(px, torqueRadius + 0.09, -panelH / 2 - 0.15);
          jBoxUpper.visible = false; // Hidden by default, shown on String step
          panelTable.add(jBoxUpper);
          junctionBoxes.push({ mesh: jBoxUpper, rowZ: zPos });
          
          // Junction box on back of lower panel - attached to panel back - BIGGER
          const jBoxLower = new THREE.Mesh(
            new THREE.BoxGeometry(0.7, 0.18, 0.4),
            junctionMat
          );
          jBoxLower.position.set(px, torqueRadius + 0.09, panelH / 2 + 0.15);
          jBoxLower.visible = false; // Hidden by default, shown on String step
          panelTable.add(jBoxLower);
          junctionBoxes.push({ mesh: jBoxLower, rowZ: zPos });
        } else {
          // 1P - Single junction box on center
          const jBoxSingle = new THREE.Mesh(
            new THREE.BoxGeometry(0.7, 0.18, 0.4),
            junctionMat
          );
          jBoxSingle.position.set(px, torqueRadius + 0.09, 0);
          jBoxSingle.visible = false;
          panelTable.add(jBoxSingle);
          junctionBoxes.push({ mesh: jBoxSingle, rowZ: zPos });
        }
        
        // RIGHT SIDE - WIRE HARNESS (panels on right half)
        if (px > 0) {
          // === MC4 INTERCONNECTION CABLES (panel-to-panel) ===
          // These are the short cables that connect one panel to the next
          if (p > 0) {
            // Red interconnection cable from this panel's - to previous panel's +
            const interConnectRed = new THREE.Mesh(
              new THREE.CylinderGeometry(0.1, 0.1, panelW - 0.3, 12),
              backWireRed
            );
            interConnectRed.rotation.z = Math.PI / 2;
            interConnectRed.position.set(px - panelW / 2, torqueRadius + 0.02, panelH / 2 + 0.22);
            interConnectRed.visible = false; // Hidden by default
            panelTable.add(interConnectRed);
            redCables.push({ mesh: interConnectRed, rowZ: zPos });
            
            // Black interconnection cable 
            const interConnectBlack = new THREE.Mesh(
              new THREE.CylinderGeometry(0.1, 0.1, panelW - 0.3, 12),
              backWireBlack
            );
            interConnectBlack.rotation.z = Math.PI / 2;
            interConnectBlack.position.set(px - panelW / 2, torqueRadius - 0.06, panelH / 2 + 0.22);
            interConnectBlack.visible = false; // Hidden by default
            panelTable.add(interConnectBlack);
            redCables.push({ mesh: interConnectBlack, rowZ: zPos });
            
            // MC4 connector pair (where two panels connect)
            const mc4Pair = new THREE.Mesh(
              new THREE.CylinderGeometry(0.08, 0.08, 0.2, 8),
              new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.6, roughness: 0.3 })
            );
            mc4Pair.rotation.z = Math.PI / 2;
            mc4Pair.position.set(px - panelW / 2, torqueRadius - 0.02, panelH / 2 + 0.22);
            mc4Pair.visible = false; // Hidden by default
            panelTable.add(mc4Pair);
            redCables.push({ mesh: mc4Pair, rowZ: zPos });
          }
          
          // Harness cable bundle running horizontally along mounting rail
          if (p % 4 === 0) {
            // Main harness trunk cable - RED - MUCH THICKER
            const harnessTrunkRed = new THREE.Mesh(
              new THREE.CylinderGeometry(0.15, 0.15, panelW * 4, 12),
              backWireRed
            );
            harnessTrunkRed.rotation.z = Math.PI / 2;
            harnessTrunkRed.position.set(px + panelW * 1.5, torqueRadius + 0.0, panelH / 2 + 0.18);
            harnessTrunkRed.visible = false; // Hidden by default
            panelTable.add(harnessTrunkRed);
            redCables.push({ mesh: harnessTrunkRed, rowZ: zPos });
            
            // Main harness trunk cable - BLACK - MUCH THICKER
            const harnessTrunkBlack = new THREE.Mesh(
              new THREE.CylinderGeometry(0.15, 0.15, panelW * 4, 12),
              backWireBlack
            );
            harnessTrunkBlack.rotation.z = Math.PI / 2;
            harnessTrunkBlack.position.set(px + panelW * 1.5, torqueRadius - 0.08, panelH / 2 + 0.18);
            harnessTrunkBlack.visible = false; // Hidden by default
            panelTable.add(harnessTrunkBlack);
            redCables.push({ mesh: harnessTrunkBlack, rowZ: zPos });
            
            // === CAB CLIP attached to purlin holding harness ===
            const cabMat = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0x880000, emissiveIntensity: 0.6, roughness: 0.3 });
            
            // CAB mounting bracket attached to purlin
            const cabBracket = new THREE.Mesh(
              new THREE.BoxGeometry(0.2, 0.15, 0.12),
              cabMat
            );
            cabBracket.position.set(px + panelW * 1.5, torqueRadius + 0.08, panelH / 2 + 0.12);
            cabBracket.visible = false; // Hidden by default
            panelTable.add(cabBracket);
            redCables.push({ mesh: cabBracket, rowZ: zPos });
            
            // CAB clip loop holding cables
            const cabLoop = new THREE.Mesh(
              new THREE.TorusGeometry(0.14, 0.04, 8, 16, Math.PI * 1.4),
              cabMat
            );
            cabLoop.position.set(px + panelW * 1.5, torqueRadius - 0.04, panelH / 2 + 0.18);
            cabLoop.rotation.y = Math.PI / 2;
            cabLoop.rotation.z = -Math.PI / 5;
            cabLoop.visible = false; // Hidden by default
            panelTable.add(cabLoop);
            redCables.push({ mesh: cabLoop, rowZ: zPos });
          }
          
          // Drop cables from junction box to harness - THICKER
          const dropRed = new THREE.Mesh(
            new THREE.CylinderGeometry(0.05, 0.05, 0.25, 12),
            backWireRed
          );
          dropRed.position.set(px + 0.15, torqueRadius - 0.02, panelH / 2 + 0.18);
          dropRed.visible = false; // Hidden by default
          panelTable.add(dropRed);
          redCables.push({ mesh: dropRed, rowZ: zPos });
          
          const dropBlack = new THREE.Mesh(
            new THREE.CylinderGeometry(0.05, 0.05, 0.25, 12),
            backWireBlack
          );
          dropBlack.position.set(px - 0.15, torqueRadius - 0.02, panelH / 2 + 0.18);
          dropBlack.visible = false; // Hidden by default
          panelTable.add(dropBlack);
          redCables.push({ mesh: dropBlack, rowZ: zPos });
          
          // MC4 connectors at junction box - BIGGER
          const mc4Red = new THREE.Mesh(
            new THREE.CylinderGeometry(0.06, 0.05, 0.18, 8),
            mc4Mat
          );
          mc4Red.position.set(px + 0.15, torqueRadius + 0.06, panelH / 2 + 0.2);
          mc4Red.visible = false; // Hidden by default
          panelTable.add(mc4Red);
          redCables.push({ mesh: mc4Red, rowZ: zPos });
          
          const mc4Black = new THREE.Mesh(
            new THREE.CylinderGeometry(0.06, 0.05, 0.18, 8),
            mc4Mat
          );
          mc4Black.position.set(px - 0.15, torqueRadius + 0.06, panelH / 2 + 0.2);
          mc4Black.visible = false; // Hidden by default
          panelTable.add(mc4Black);
          redCables.push({ mesh: mc4Black, rowZ: zPos });
        }
        
        // LEFT SIDE - STRING HOME RUNS (panels on left half)
        if (px < 0) {
          // === MC4 INTERCONNECTION CABLES (panel-to-panel) ===
          if (p > 0) {
            // Red interconnection cable between panels
            const interConnectRedL = new THREE.Mesh(
              new THREE.CylinderGeometry(0.1, 0.1, panelW - 0.3, 12),
              backWireRed
            );
            interConnectRedL.rotation.z = Math.PI / 2;
            interConnectRedL.position.set(px - panelW / 2, torqueRadius + 0.02, -panelH / 2 - 0.22);
            interConnectRedL.visible = false; // Hidden by default
            panelTable.add(interConnectRedL);
            redCables.push({ mesh: interConnectRedL, rowZ: zPos });
            
            // Black interconnection cable 
            const interConnectBlackL = new THREE.Mesh(
              new THREE.CylinderGeometry(0.1, 0.1, panelW - 0.3, 12),
              backWireBlack
            );
            interConnectBlackL.rotation.z = Math.PI / 2;
            interConnectBlackL.position.set(px - panelW / 2, torqueRadius - 0.06, -panelH / 2 - 0.22);
            interConnectBlackL.visible = false; // Hidden by default
            panelTable.add(interConnectBlackL);
            redCables.push({ mesh: interConnectBlackL, rowZ: zPos });
            
            // MC4 connector pair (where two panels connect)
            const mc4PairL = new THREE.Mesh(
              new THREE.CylinderGeometry(0.08, 0.08, 0.2, 8),
              new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.6, roughness: 0.3 })
            );
            mc4PairL.rotation.z = Math.PI / 2;
            mc4PairL.position.set(px - panelW / 2, torqueRadius - 0.02, -panelH / 2 - 0.22);
            mc4PairL.visible = false; // Hidden by default
            panelTable.add(mc4PairL);
            redCables.push({ mesh: mc4PairL, rowZ: zPos });
          }
          
          // Individual string home run cables running to end of row
          const stringIndex = Math.abs(Math.floor(px / (panelW * 3)));
          const cableOffset = (stringIndex % 4) * 0.08;
          
          // Home run RED cable running toward row end - attached under purlin
          const homeRunRed = new THREE.Mesh(
            new THREE.CylinderGeometry(0.12, 0.12, Math.abs(px) + panelW, 12),
            backWireRed
          );
          homeRunRed.rotation.z = Math.PI / 2;
          homeRunRed.position.set(px / 2 - panelW / 2, torqueRadius + 0.0 - cableOffset, -panelH / 2 - 0.18);
          homeRunRed.visible = false; // Hidden by default
          panelTable.add(homeRunRed);
          redCables.push({ mesh: homeRunRed, rowZ: zPos });
          
          // Home run BLACK cable - THICKER
          const homeRunBlack = new THREE.Mesh(
            new THREE.CylinderGeometry(0.12, 0.12, Math.abs(px) + panelW, 12),
            backWireBlack
          );
          homeRunBlack.rotation.z = Math.PI / 2;
          homeRunBlack.position.set(px / 2 - panelW / 2, torqueRadius - 0.1 - cableOffset, -panelH / 2 - 0.18);
          homeRunBlack.visible = false; // Hidden by default
          panelTable.add(homeRunBlack);
          redCables.push({ mesh: homeRunBlack, rowZ: zPos });
          
          // CAB clip only at every 4th panel to reduce clutter
          if (p % 4 === 0) {
            const cabMatHR = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0x880000, emissiveIntensity: 0.6, roughness: 0.3 });
            
            // CAB bracket attached to purlin
            const cabBracketHR = new THREE.Mesh(
              new THREE.BoxGeometry(0.18, 0.12, 0.1),
              cabMatHR
            );
            cabBracketHR.position.set(px, torqueRadius + 0.08, -panelH / 2 - 0.12);
            cabBracketHR.visible = false; // Hidden by default
            panelTable.add(cabBracketHR);
            redCables.push({ mesh: cabBracketHR, rowZ: zPos });
            
            // CAB loop holding cables
            const cabLoopHR = new THREE.Mesh(
              new THREE.TorusGeometry(0.12, 0.035, 8, 14, Math.PI * 1.4),
              cabMatHR
            );
            cabLoopHR.position.set(px, torqueRadius - 0.05 - cableOffset, -panelH / 2 - 0.18);
            cabLoopHR.rotation.y = Math.PI / 2;
            cabLoopHR.rotation.z = -Math.PI / 5;
            cabLoopHR.visible = false; // Hidden by default
            panelTable.add(cabLoopHR);
            redCables.push({ mesh: cabLoopHR, rowZ: zPos });
          }
          
          // Drop cable from panel to home run - THICKER
          const dropRedHR = new THREE.Mesh(
            new THREE.CylinderGeometry(0.05, 0.05, 0.2, 12),
            backWireRed
          );
          dropRedHR.position.set(px + 0.12, torqueRadius + 0.02, -panelH / 2 - 0.15);
          dropRedHR.visible = false; // Hidden by default
          panelTable.add(dropRedHR);
          redCables.push({ mesh: dropRedHR, rowZ: zPos });
          
          const dropBlackHR = new THREE.Mesh(
            new THREE.CylinderGeometry(0.05, 0.05, 0.2, 12),
            backWireBlack
          );
          dropBlackHR.position.set(px - 0.12, torqueRadius + 0.02, -panelH / 2 - 0.15);
          dropBlackHR.visible = false; // Hidden by default
          panelTable.add(dropBlackHR);
          redCables.push({ mesh: dropBlackHR, rowZ: zPos });
          
          // MC4 connectors - BIGGER
          const mc4RedHR = new THREE.Mesh(
            new THREE.CylinderGeometry(0.05, 0.04, 0.15, 8),
            mc4Mat
          );
          mc4RedHR.rotation.x = Math.PI / 2;
          mc4RedHR.position.set(px + 0.12, torqueRadius + 0.0, -panelH / 2 - 0.28);
          mc4RedHR.visible = false; // Hidden by default
          panelTable.add(mc4RedHR);
          redCables.push({ mesh: mc4RedHR, rowZ: zPos });
          
          const mc4BlackHR = new THREE.Mesh(
            new THREE.CylinderGeometry(0.05, 0.04, 0.15, 8),
            mc4Mat
          );
          mc4BlackHR.rotation.x = Math.PI / 2;
          mc4BlackHR.position.set(px - 0.12, torqueRadius - 0.08, -panelH / 2 - 0.28);
          mc4BlackHR.visible = false; // Hidden by default
          panelTable.add(mc4BlackHR);
          redCables.push({ mesh: mc4BlackHR, rowZ: zPos });
        }
        
        // Frames - adjust for panel configuration
        const frameThick = 0.1;
        
        if (numPanelsPerTable === 2) {
          // 2L or 2P: frames for 2 panels
          const fUT = new THREE.Mesh(new THREE.BoxGeometry(panelW + 0.08, frameThick, frameThick), frameMat);
          fUT.position.set(px, torqueRadius + 0.15, -panelH - 0.12);
          panelTable.add(fUT);
          
          const fUB = new THREE.Mesh(new THREE.BoxGeometry(panelW + 0.08, frameThick, frameThick), frameMat);
          fUB.position.set(px, torqueRadius + 0.15, -0.12);
          panelTable.add(fUB);
          
          const fLT = new THREE.Mesh(new THREE.BoxGeometry(panelW + 0.08, frameThick, frameThick), frameMat);
          fLT.position.set(px, torqueRadius + 0.15, 0.12);
          panelTable.add(fLT);
          
          const fLB = new THREE.Mesh(new THREE.BoxGeometry(panelW + 0.08, frameThick, frameThick), frameMat);
          fLB.position.set(px, torqueRadius + 0.15, panelH + 0.12);
          panelTable.add(fLB);
          
          const sideLen = panelH * 2 + 0.34;
          const fL = new THREE.Mesh(new THREE.BoxGeometry(frameThick, frameThick, sideLen), frameMat);
          fL.position.set(px - panelW / 2, torqueRadius + 0.15, 0);
          panelTable.add(fL);
          
          const fR = new THREE.Mesh(new THREE.BoxGeometry(frameThick, frameThick, sideLen), frameMat);
          fR.position.set(px + panelW / 2, torqueRadius + 0.15, 0);
          panelTable.add(fR);
        } else {
          // 1P: frames for single centered panel only
          const halfH = panelH / 2;
          
          // Top frame (at -halfH)
          const fTop = new THREE.Mesh(new THREE.BoxGeometry(panelW + 0.08, frameThick, frameThick), frameMat);
          fTop.position.set(px, torqueRadius + 0.15, -halfH);
          panelTable.add(fTop);
          
          // Bottom frame (at +halfH)
          const fBot = new THREE.Mesh(new THREE.BoxGeometry(panelW + 0.08, frameThick, frameThick), frameMat);
          fBot.position.set(px, torqueRadius + 0.15, halfH);
          panelTable.add(fBot);
          
          // Side frames - only span single panel height
          const sideLen = panelH + 0.1;
          const fL = new THREE.Mesh(new THREE.BoxGeometry(frameThick, frameThick, sideLen), frameMat);
          fL.position.set(px - panelW / 2, torqueRadius + 0.15, 0);
          panelTable.add(fL);
          
          const fR = new THREE.Mesh(new THREE.BoxGeometry(frameThick, frameThick, sideLen), frameMat);
          fR.position.set(px + panelW / 2, torqueRadius + 0.15, 0);
          panelTable.add(fR);
        }
      }
      
      panelTable.rotation.x = tilt;
      tracker.add(panelTable);
      
      // Store reference for sun tracking
      tracker.userData.panelTable = panelTable;
      tracker.userData.baseTilt = tilt;
      
      // === WIRE MANAGEMENT SYSTEM - attached to posts ===
      const cableTrayMat = new THREE.MeshStandardMaterial({ color: 0x505050, metalness: 0.5, roughness: 0.4 });
      const messengerMat = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.6, roughness: 0.4 });
      
      // Cable tray running along the row - positioned at post level
      const cableTray = new THREE.Mesh(
        new THREE.BoxGeometry(rowLength * 0.9, 0.1, 0.5),
        cableTrayMat
      );
      cableTray.position.set(0, pileHeight - 0.8, 1.5);
      tracker.add(cableTray);
      
      // Tray sides
      const traySide1 = new THREE.Mesh(
        new THREE.BoxGeometry(rowLength * 0.9, 0.2, 0.06),
        cableTrayMat
      );
      traySide1.position.set(0, pileHeight - 0.65, 1.73);
      tracker.add(traySide1);
      
      const traySide2 = new THREE.Mesh(
        new THREE.BoxGeometry(rowLength * 0.9, 0.2, 0.06),
        cableTrayMat
      );
      traySide2.position.set(0, pileHeight - 0.65, 1.27);
      tracker.add(traySide2);
      
      // Messenger wire (catenary support) - attached between posts
      const messengerWire = new THREE.Mesh(
        new THREE.CylinderGeometry(0.03, 0.03, rowLength, 12),
        messengerMat
      );
      messengerWire.rotation.z = Math.PI / 2;
      messengerWire.position.set(0, pileHeight + 0.2, 1.8);
      tracker.add(messengerWire);
      
      // Bundled home run cables in tray (visible RED and BLACK)
      const trayBundleRed = new THREE.Mesh(
        new THREE.CylinderGeometry(0.1, 0.1, rowLength * 0.85, 12),
        new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0x550000, emissiveIntensity: 0.4, roughness: 0.5 })
      );
      trayBundleRed.rotation.z = Math.PI / 2;
      trayBundleRed.position.set(0, pileHeight - 0.68, 1.58);
      tracker.add(trayBundleRed);
      
      const trayBundleBlack = new THREE.Mesh(
        new THREE.CylinderGeometry(0.1, 0.1, rowLength * 0.85, 12),
        new THREE.MeshStandardMaterial({ color: 0x222222, emissive: 0x111111, roughness: 0.5 })
      );
      trayBundleBlack.rotation.z = Math.PI / 2;
      trayBundleBlack.position.set(0, pileHeight - 0.68, 1.42);
      tracker.add(trayBundleBlack);
      
      // Tray support brackets at each post
      for (let i = 0; i <= numPiles; i++) {
        const bpx = -rowLength / 2 + i * pileSpacing;
        if (Math.abs(bpx) > rowLength / 2 + 2) continue;
        
        // Tray bracket attached to post
        const trayBracket = new THREE.Mesh(
          new THREE.BoxGeometry(0.12, 0.5, 0.6),
          cableTrayMat
        );
        trayBracket.position.set(bpx, pileHeight - 0.55, 1.5);
        tracker.add(trayBracket);
        
        // === CAB CLIP on cable tray - attached to bracket ===
        const cabTrayMat = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0x880000, emissiveIntensity: 0.6, roughness: 0.25 });
        
        // CAB clip holding main bundle - attached to tray bracket
        const cabTray1 = new THREE.Mesh(
          new THREE.TorusGeometry(0.15, 0.04, 10, 18, Math.PI * 1.3),
          cabTrayMat
        );
        cabTray1.position.set(bpx, pileHeight - 0.68, 1.5);
        cabTray1.rotation.z = Math.PI / 2;
        cabTray1.rotation.y = Math.PI / 6;
        tracker.add(cabTray1);
        
        // CAB mounting tab on bracket
        const cabTab = new THREE.Mesh(
          new THREE.BoxGeometry(0.08, 0.12, 0.2),
          cabTrayMat
        );
        cabTab.position.set(bpx, pileHeight - 0.5, 1.5);
        tracker.add(cabTab);
      }
      
      // === REALISTIC SLEW DRIVE MOTOR (End of row) ===
      const motorGroup = new THREE.Group();
      const motorMat = new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.6, roughness: 0.4 });
      const gearMat = new THREE.MeshStandardMaterial({ color: 0x666666, metalness: 0.7, roughness: 0.3 });
      
      // Motor housing (cylindrical)
      const motorHousing = new THREE.Mesh(
        new THREE.CylinderGeometry(0.4, 0.4, 0.8, 16),
        motorMat
      );
      motorHousing.rotation.z = Math.PI / 2;
      motorHousing.position.set(-0.6, 0, 0);
      motorGroup.add(motorHousing);
      
      // Motor end cap
      const motorCap = new THREE.Mesh(
        new THREE.CylinderGeometry(0.35, 0.4, 0.15, 16),
        motorMat
      );
      motorCap.rotation.z = Math.PI / 2;
      motorCap.position.set(-1.05, 0, 0);
      motorGroup.add(motorCap);
      
      // Gearbox (larger cylinder)
      const gearbox = new THREE.Mesh(
        new THREE.CylinderGeometry(0.5, 0.5, 0.6, 16),
        gearMat
      );
      gearbox.rotation.z = Math.PI / 2;
      gearbox.position.set(0, 0, 0);
      motorGroup.add(gearbox);
      
      // Gearbox housing ribs
      for (let rib = 0; rib < 8; rib++) {
        const ribAngle = (rib / 8) * Math.PI * 2;
        const ribMesh = new THREE.Mesh(
          new THREE.BoxGeometry(0.55, 0.05, 0.08),
          gearMat
        );
        ribMesh.position.set(0, Math.cos(ribAngle) * 0.45, Math.sin(ribAngle) * 0.45);
        ribMesh.rotation.x = ribAngle;
        motorGroup.add(ribMesh);
      }
      
      // Output flange (connects to torque tube)
      const outputFlange = new THREE.Mesh(
        new THREE.CylinderGeometry(0.3, 0.4, 0.3, 16),
        gearMat
      );
      outputFlange.rotation.z = Math.PI / 2;
      outputFlange.position.set(0.4, 0, 0);
      motorGroup.add(outputFlange);
      
      // Mounting bracket
      const mountBracket = new THREE.Mesh(
        new THREE.BoxGeometry(0.15, 1.2, 0.8),
        new THREE.MeshStandardMaterial({ color: 0x777777, metalness: 0.6, roughness: 0.35 })
      );
      mountBracket.position.set(0.1, -0.7, 0);
      motorGroup.add(mountBracket);
      
      // Controller box on motor
      const controlBox = new THREE.Mesh(
        new THREE.BoxGeometry(0.4, 0.25, 0.3),
        new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.5, roughness: 0.5 })
      );
      controlBox.position.set(-0.3, 0.5, 0);
      motorGroup.add(controlBox);
      
      // LED indicator
      const motorLED = new THREE.Mesh(
        new THREE.SphereGeometry(0.04, 8, 8),
        new THREE.MeshStandardMaterial({ color: 0x00ff00, emissive: 0x00ff00, emissiveIntensity: 0.5 })
      );
      motorLED.position.set(-0.15, 0.55, 0.15);
      motorGroup.add(motorLED);
      
      // Motor support post
      const motorPostMain = new THREE.Mesh(
        new THREE.BoxGeometry(0.2, pileHeight + 0.4, 0.5),
        postMat
      );
      motorPostMain.position.set(0, -pileHeight / 2 + 0.2, 0);
      motorGroup.add(motorPostMain);
      
      // Post flanges
      const motorFlange1 = new THREE.Mesh(
        new THREE.BoxGeometry(0.5, pileHeight + 0.4, 0.08),
        postMat
      );
      motorFlange1.position.set(0, -pileHeight / 2 + 0.2, 0.22);
      motorGroup.add(motorFlange1);
      
      const motorFlange2 = new THREE.Mesh(
        new THREE.BoxGeometry(0.5, pileHeight + 0.4, 0.08),
        postMat
      );
      motorFlange2.position.set(0, -pileHeight / 2 + 0.2, -0.22);
      motorGroup.add(motorFlange2);
      
      motorGroup.position.set(-rowLength / 2 - 1.5, pileHeight, 0);
      tracker.add(motorGroup);
      
      // === COMBINER BOXES - Multiple Locations ===
      const combinerBodyMat = new THREE.MeshStandardMaterial({ color: 0xe8e8e8, metalness: 0.3, roughness: 0.5 }); // Light gray/white box
      const combinerDoorMat = new THREE.MeshStandardMaterial({ color: 0xd0d0d0, metalness: 0.4, roughness: 0.4 });
      const strutMat = new THREE.MeshStandardMaterial({ color: 0x606060, metalness: 0.6, roughness: 0.4 });
      const warningMat = new THREE.MeshStandardMaterial({ color: 0xffcc00, emissive: 0x332200 }); // Yellow warning
      
      // === END OF ROW COMBINER BOX (Left end) ===
      const endCBX = new THREE.Group();
      
      // Mounting post/strut for end combiner
      const endPost = new THREE.Mesh(
        new THREE.BoxGeometry(0.15, 3.5, 0.15),
        strutMat
      );
      endPost.position.set(0, 1.75, 0);
      endCBX.add(endPost);
      
      // Cross strut
      const endCrossStrut = new THREE.Mesh(
        new THREE.BoxGeometry(0.8, 0.1, 0.1),
        strutMat
      );
      endCrossStrut.position.set(0.3, 2.8, 0);
      endCBX.add(endCrossStrut);
      
      // Main combiner enclosure - white/gray box
      const endCombinerBody = new THREE.Mesh(
        new THREE.BoxGeometry(1.0, 1.4, 0.5),
        combinerBodyMat
      );
      endCombinerBody.position.set(0.4, 2.8, 0);
      endCombinerBody.castShadow = true;
      endCBX.add(endCombinerBody);
      
      // Store reference for highlighting
      combinerBoxes.push({ mesh: endCombinerBody, rowZ: zPos, xCenter: xCenter, originalMat: combinerBodyMat, isHighlighted: false });
      
      // Door/front panel
      const endCombinerDoor = new THREE.Mesh(
        new THREE.BoxGeometry(0.9, 1.3, 0.03),
        combinerDoorMat
      );
      endCombinerDoor.position.set(0.4, 2.8, 0.27);
      endCBX.add(endCombinerDoor);
      
      // Warning label (yellow triangle)
      const endWarning = new THREE.Mesh(
        new THREE.BoxGeometry(0.25, 0.25, 0.02),
        warningMat
      );
      endWarning.position.set(0.4, 3.2, 0.29);
      endCBX.add(endWarning);
      
      // "PV COMBINER BOX" label area
      const endLabel = new THREE.Mesh(
        new THREE.BoxGeometry(0.6, 0.15, 0.02),
        new THREE.MeshStandardMaterial({ color: 0xffffff })
      );
      endLabel.position.set(0.4, 2.5, 0.29);
      endCBX.add(endLabel);
      
      // Door handle/latch
      const endHandle = new THREE.Mesh(
        new THREE.BoxGeometry(0.08, 0.2, 0.05),
        strutMat
      );
      endHandle.position.set(0.75, 2.8, 0.29);
      endCBX.add(endHandle);
      
      // Cable glands at bottom (where cables enter)
      for (let g = 0; g < 4; g++) {
        const gland = new THREE.Mesh(
          new THREE.CylinderGeometry(0.06, 0.06, 0.15, 8),
          new THREE.MeshStandardMaterial({ color: 0x333333 })
        );
        gland.position.set(0.15 + g * 0.18, 2.0, 0);
        endCBX.add(gland);
        
        // Cables going into glands
        const glandCable = new THREE.Mesh(
          new THREE.CylinderGeometry(0.04, 0.04, 0.8, 8),
          new THREE.MeshStandardMaterial({ color: g % 2 === 0 ? 0xff0000 : 0x111111, emissive: g % 2 === 0 ? 0x330000 : 0x000000 })
        );
        glandCable.position.set(0.15 + g * 0.18, 1.5, 0);
        endCBX.add(glandCable);
      }
      
      // Feeder cable coming out (larger, going to inverter/transformer)
      const feederConduit = new THREE.Mesh(
        new THREE.CylinderGeometry(0.1, 0.1, 1.5, 10),
        new THREE.MeshStandardMaterial({ color: 0x505050, metalness: 0.5 })
      );
      feederConduit.position.set(0.4, 1.3, 0);
      endCBX.add(feederConduit);
      
      // Position end combiner at left end of row
      endCBX.position.set(-rowLength / 2 - 3, 0, 0);
      tracker.add(endCBX);
      
      // Underground conduit run from end combiner (going to central collection)
      const undergroundRun = new THREE.Mesh(
        new THREE.CylinderGeometry(0.12, 0.12, 15, 10),
        new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.4 })
      );
      undergroundRun.rotation.x = Math.PI / 2;
      undergroundRun.position.set(-rowLength / 2 - 3, 0.15, 7.5);
      tracker.add(undergroundRun);
      
      // Conduit markers/risers along underground run
      for (let m = 0; m < 3; m++) {
        const marker = new THREE.Mesh(
          new THREE.CylinderGeometry(0.08, 0.08, 0.4, 8),
          new THREE.MeshStandardMaterial({ color: 0xff6600 }) // Orange marker
        );
        marker.position.set(-rowLength / 2 - 3, 0.35, 3 + m * 5);
        tracker.add(marker);
      }
      
      // === MIDDLE OF ROW COMBINER BOX ===
      const midCBX = new THREE.Group();
      
      // I-beam/strut rack mounting
      const iBeamWeb = new THREE.Mesh(
        new THREE.BoxGeometry(0.08, 2.0, 0.4),
        strutMat
      );
      iBeamWeb.position.set(0, 1.0, 0);
      midCBX.add(iBeamWeb);
      
      // I-beam flanges
      const iBeamFlange1 = new THREE.Mesh(
        new THREE.BoxGeometry(0.25, 2.0, 0.06),
        strutMat
      );
      iBeamFlange1.position.set(0, 1.0, 0.17);
      midCBX.add(iBeamFlange1);
      
      const iBeamFlange2 = new THREE.Mesh(
        new THREE.BoxGeometry(0.25, 2.0, 0.06),
        strutMat
      );
      iBeamFlange2.position.set(0, 1.0, -0.17);
      midCBX.add(iBeamFlange2);
      
      // Mounting bracket
      const midBracket = new THREE.Mesh(
        new THREE.BoxGeometry(0.6, 0.1, 0.5),
        strutMat
      );
      midBracket.position.set(0.25, 2.2, 0);
      midCBX.add(midBracket);
      
      // Main combiner box body
      const midCombinerBody = new THREE.Mesh(
        new THREE.BoxGeometry(0.9, 1.2, 0.45),
        combinerBodyMat
      );
      midCombinerBody.position.set(0.35, 2.8, 0);
      midCombinerBody.castShadow = true;
      midCBX.add(midCombinerBody);
      
      // Store reference for highlighting
      combinerBoxes.push({ mesh: midCombinerBody, rowZ: zPos, xCenter: xCenter, originalMat: combinerBodyMat, isHighlighted: false });
      
      // Door
      const midCombinerDoor = new THREE.Mesh(
        new THREE.BoxGeometry(0.8, 1.1, 0.03),
        combinerDoorMat
      );
      midCombinerDoor.position.set(0.35, 2.8, 0.25);
      midCBX.add(midCombinerDoor);
      
      // Warning sign
      const midWarning = new THREE.Mesh(
        new THREE.BoxGeometry(0.22, 0.22, 0.02),
        warningMat
      );
      midWarning.position.set(0.35, 3.15, 0.27);
      midCBX.add(midWarning);
      
      // Red disconnect handle
      const midDisconnect = new THREE.Mesh(
        new THREE.BoxGeometry(0.15, 0.08, 0.06),
        new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0x440000 })
      );
      midDisconnect.position.set(0.35, 2.45, 0.27);
      midCBX.add(midDisconnect);
      
      // Cable glands
      for (let g = 0; g < 3; g++) {
        const gland = new THREE.Mesh(
          new THREE.CylinderGeometry(0.055, 0.055, 0.12, 8),
          new THREE.MeshStandardMaterial({ color: 0x2a2a2a })
        );
        gland.position.set(0.1 + g * 0.2, 2.15, 0);
        midCBX.add(gland);
      }
      
      // Cables coming from panels (red/black pairs) - going UP to panel level
      for (let c = 0; c < 3; c++) {
        // Vertical cable section
        const cableRedV = new THREE.Mesh(
          new THREE.CylinderGeometry(0.04, 0.04, 1.5, 8),
          new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0x550000 })
        );
        cableRedV.position.set(0.0 + c * 0.25, 3.8, 0.1);
        midCBX.add(cableRedV);
        
        const cableBlackV = new THREE.Mesh(
          new THREE.CylinderGeometry(0.04, 0.04, 1.5, 8),
          new THREE.MeshStandardMaterial({ color: 0x111111 })
        );
        cableBlackV.position.set(0.1 + c * 0.25, 3.8, 0.1);
        midCBX.add(cableBlackV);
        
        // Horizontal section into combiner
        const cableRedH = new THREE.Mesh(
          new THREE.CylinderGeometry(0.04, 0.04, 0.4, 8),
          new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0x550000 })
        );
        cableRedH.rotation.z = Math.PI / 4;
        cableRedH.position.set(0.15 + c * 0.2, 3.1, 0.1);
        midCBX.add(cableRedH);
      }
      
      // Underground conduit stub
      const undergroundStub = new THREE.Mesh(
        new THREE.CylinderGeometry(0.12, 0.12, 0.6, 10),
        new THREE.MeshStandardMaterial({ color: 0x606060 })
      );
      undergroundStub.position.set(0.35, 0.3, 0);
      midCBX.add(undergroundStub);
      
      // Position middle combiner under panels (middle of row) - visible location
      midCBX.position.set(0, 0, 2.5);
      tracker.add(midCBX);
      
      // Add a second middle combiner on opposite side for visibility
      const midCBX2 = midCBX.clone();
      midCBX2.position.set(rowLength * 0.3, 0, 2.5);
      tracker.add(midCBX2);
      
      // === SECOND END OF ROW COMBINER (Right end) ===
      const endCBX2 = endCBX.clone();
      endCBX2.position.set(rowLength / 2 + 3, 0, 0);
      endCBX2.rotation.y = Math.PI; // Face opposite direction
      tracker.add(endCBX2);
      
      // === ABOVE GROUND TRANSITION BOX (standalone between rows) ===
      // Add transition boxes randomly to show variety
      if (Math.random() < 0.3) {
        const transitionBox = new THREE.Group();
        
        // Tall mounting post
        const transPost = new THREE.Mesh(
          new THREE.CylinderGeometry(0.12, 0.12, 5, 10),
          strutMat
        );
        transPost.position.set(0, 2.5, 0);
        transitionBox.add(transPost);
        
        // Support brace
        const transBrace = new THREE.Mesh(
          new THREE.CylinderGeometry(0.06, 0.06, 2, 8),
          strutMat
        );
        transBrace.position.set(0.5, 1.5, 0);
        transBrace.rotation.z = Math.PI / 4;
        transitionBox.add(transBrace);
        
        // Large combiner enclosure (like in photos)
        const transBody = new THREE.Mesh(
          new THREE.BoxGeometry(1.2, 1.6, 0.6),
          combinerBodyMat
        );
        transBody.position.set(0, 4.2, 0.3);
        transBody.castShadow = true;
        transitionBox.add(transBody);
        
        // Door
        const transDoor = new THREE.Mesh(
          new THREE.BoxGeometry(1.1, 1.5, 0.03),
          combinerDoorMat
        );
        transDoor.position.set(0, 4.2, 0.62);
        transitionBox.add(transDoor);
        
        // Warning label
        const transWarning = new THREE.Mesh(
          new THREE.BoxGeometry(0.3, 0.3, 0.02),
          warningMat
        );
        transWarning.position.set(0, 4.7, 0.64);
        transitionBox.add(transWarning);
        
        // Multiple cable entries at bottom
        for (let e = 0; e < 6; e++) {
          const entry = new THREE.Mesh(
            new THREE.CylinderGeometry(0.07, 0.07, 0.2, 8),
            new THREE.MeshStandardMaterial({ color: 0x333333 })
          );
          entry.position.set(-0.4 + e * 0.16, 3.3, 0.3);
          transitionBox.add(entry);
        }
        
        // Underground conduit
        const underConduit = new THREE.Mesh(
          new THREE.CylinderGeometry(0.15, 0.15, 1.0, 10),
          new THREE.MeshStandardMaterial({ color: 0x505050 })
        );
        underConduit.position.set(0, 0.5, 0);
        transitionBox.add(underConduit);
        
        // Position between rows
        transitionBox.position.set(rowLength / 2 + 8, 0, zPos + 9);
        scene.add(transitionBox);
      }
      
      tracker.position.set(xCenter, 0, zPos);
      scene.add(tracker);
      trackerRows.push(tracker); // Store reference for sun tracking
    }

    // === COMPONENT INFO DATA - DETAILED ===
    const componentInfo = {
      'solar-panel': {
        title: 'Photovoltaic Panel',
        category: 'Power Generation',
        desc: 'Photovoltaic modules convert sunlight directly into electricity using semiconductor cells. Each panel contains 60-72 monocrystalline silicon cells connected in series. When photons hit the cells, they knock electrons loose from atoms in the semiconductor material, creating an electrical current. Modern panels achieve efficiencies of 20-23%, meaning they convert that percentage of incoming sunlight into usable electricity.',
        specs: [
          { label: 'Power Output', value: '400-600W' },
          { label: 'Voltage (Vmp)', value: '30-50V DC' },
          { label: 'Current (Imp)', value: '10-14A' },
          { label: 'Efficiency', value: '20-23%' },
          { label: 'Cell Type', value: 'Monocrystalline' },
          { label: 'Dimensions', value: '2m x 1m x 40mm' },
          { label: 'Weight', value: '20-25 kg' },
          { label: 'Warranty', value: '25 years' }
        ],
        fact: 'A single solar panel can prevent approximately 1 ton of CO2 emissions per year compared to coal-generated electricity. Over its 25-30 year lifespan, one panel offsets 25-30 tons of carbon dioxide.',
        related: ['junction-box', 'mc4-connector', 'wire-harness']
      },
      'torque-tube': {
        title: 'Torque Tube',
        category: 'Structural System',
        desc: 'The main structural shaft running the length of each tracker row. It serves as the primary rotating element that tilts all panels simultaneously to follow the sun. Made from high-strength galvanized steel, the tube must withstand significant torsional loads. Systems from Nextracker and Array Technologies use proprietary bearing designs for smooth rotation.',
        specs: [
          { label: 'Material', value: 'Galvanized Steel' },
          { label: 'Diameter', value: '4-6 inches' },
          { label: 'Wall Thickness', value: '0.125-0.25"' },
          { label: 'Rotation Range', value: '±60°' },
          { label: 'Length', value: 'Up to 90m' },
          { label: 'Corrosion Protection', value: 'Hot-dip galvanized' }
        ],
        fact: 'Single-axis trackers can increase energy production by 25-35% compared to fixed-tilt systems. Nextracker\'s NX Horizon and Array\'s DuraTrack HZ are among the most deployed tracker systems worldwide.',
        related: ['driven-pile', 'tracker-motor', 'solar-panel']
      },
      'driven-pile': {
        title: 'Support Structure',
        category: 'Foundation System',
        desc: 'Steel posts driven directly into the ground to support the tracker structure. The W-beam shape provides an excellent strength-to-weight ratio and can be installed without concrete foundations in most soil conditions. This reduces installation time and cost while providing reliable long-term support for the solar array.',
        specs: [
          { label: 'Material', value: 'Galvanized W-beam' },
          { label: 'Embed Depth', value: '4-8 feet' },
          { label: 'Above Ground', value: '5-8 feet' },
          { label: 'Post Spacing', value: '15-20 feet' },
          { label: 'Load Capacity', value: '5,000+ lbs' },
          { label: 'Design Life', value: '30+ years' }
        ],
        fact: 'Driven pile foundations can be installed at a rate of 200-400 piles per day with specialized equipment, making them the fastest foundation method for utility-scale solar.',
        related: ['torque-tube', 'string-inverter']
      },
      'string-inverter': {
        title: 'String Inverter',
        category: 'Power Conversion',
        desc: 'String inverters convert DC electricity from solar panels into AC electricity compatible with the utility grid. They connect multiple panels in series (a "string") and include Maximum Power Point Tracking (MPPT) technology to continuously optimize energy harvest as conditions change throughout the day.',
        specs: [
          { label: 'DC Input', value: '600-1500V' },
          { label: 'AC Output', value: '480V 3-phase' },
          { label: 'Efficiency', value: '98-99%' },
          { label: 'MPPT Channels', value: '2-6' },
          { label: 'Power Rating', value: '50-125 kW' },
          { label: 'Protection', value: 'IP65 rated' },
          { label: 'Communication', value: 'WiFi/RS485' },
          { label: 'Cooling', value: 'Natural convection' }
        ],
        fact: 'Modern inverters are so efficient that less than 2% of the solar energy is lost during DC to AC conversion. They also provide grid support functions like reactive power control.',
        related: ['dc-cables', 'ac-conduit', 'combiner-box']
      },
      'combiner-box': {
        title: 'Combiner Box',
        category: 'Electrical Distribution',
        desc: 'An electrical enclosure that safely bundles multiple solar panel strings into a single, higher-current output for the inverter. Contains fuses for overcurrent protection, Surge Protection Devices (SPDs) for voltage spikes, and bus bars to aggregate DC power. Essential for large arrays where string counts exceed inverter input limits.',
        specs: [
          { label: 'Function', value: 'Aggregates strings' },
          { label: 'String Inputs', value: '8-32 strings' },
          { label: 'Protection', value: 'Fuses + SPD' },
          { label: 'Voltage Rating', value: '1500V DC' },
          { label: 'Enclosure', value: 'NEMA 4X rated' },
          { label: 'Monitoring', value: 'Optional per-string' }
        ],
        fact: 'Combiner boxes provide critical protection: fuses prevent overcurrent damage, SPDs protect against lightning and voltage spikes, and optional monitoring can detect underperforming strings within minutes.',
        related: ['home-run', 'dc-cables', 'string-inverter']
      },
      'wire-harness': {
        title: 'String Wiring System',
        category: 'Panel Interconnection',
        desc: 'The wiring that connects panels into strings starts at the junction box on the back of each panel. Pre-attached positive and negative DC cables extend from the junction box, ending in MC4 connectors. These MC4 connectors interconnect panels to form strings. Wiring runs along the mounting system (under panel rails) for protection, then routes to inverters or combiner boxes via UV-resistant conduit.',
        specs: [
          { label: 'Origin', value: 'Junction box (panel back)' },
          { label: 'Cable Type', value: 'Pre-attached DC wires' },
          { label: 'Connectors', value: 'MC4 (plug & play)' },
          { label: 'Routing', value: 'Along mounting rails' },
          { label: 'Protection', value: 'UV-resistant conduit' },
          { label: 'Destination', value: 'Inverter / Combiner' }
        ],
        fact: 'MC4 connectors are the industry standard for solar interconnections. The "MC" stands for Multi-Contact (the manufacturer) and "4" refers to the 4mm contact pin diameter.',
        related: ['junction-box', 'mc4-connector', 'string-inverter', 'combiner-box']
      },
      'home-run': {
        title: 'String Home Run',
        category: 'DC Collection',
        desc: 'After panels are interconnected via MC4 connectors, the main cables from each string are routed to the inverter or combiner box. These "home run" cables travel via UV-resistant conduit or along cable trays for protection. Proper routing meets safety codes and protects against environmental damage.',
        specs: [
          { label: 'From', value: 'End of string' },
          { label: 'To', value: 'Inverter / Combiner' },
          { label: 'Protection', value: 'UV conduit / armored' },
          { label: 'Wire Size', value: '10-12 AWG' },
          { label: 'Voltage Rating', value: '2000V DC' },
          { label: 'Color Code', value: 'Red +, Black -' }
        ],
        fact: 'Home run cables are often routed through UV-resistant conduit or armored cable to protect them from environmental damage and meet NEC safety codes.',
        related: ['combiner-box', 'string-inverter', 'wire-harness', 'mc4-connector']
      },
      'cab-clip': {
        title: 'CAB Clips',
        category: 'Cable Management',
        desc: 'Cable Attachment Brackets (CABs) are specialized clips that secure DC cables to the racking structure. They organize cable routing, prevent damage from wind-induced movement, and maintain proper cable bend radius. Essential for NEC-compliant installations and long-term reliability.',
        specs: [
          { label: 'Material', value: 'UV-stable polymer' },
          { label: 'Cable Capacity', value: '2-8 cables' },
          { label: 'Installation', value: 'Snap-on / bolt' },
          { label: 'Temperature', value: '-40°C to 85°C' },
          { label: 'UV Life', value: '25+ years' },
          { label: 'Reusable', value: 'Yes' }
        ],
        fact: 'Improperly secured cables are a leading cause of solar system failures. CABs prevent chafing, animal damage, and connector pull-out from cable movement.',
        related: ['wire-harness', 'home-run', 'dc-cables']
      },
      'mc4-connector': {
        title: 'MC4 Connector',
        category: 'Panel Interconnection',
        desc: 'MC4 (Multi-Contact 4mm) connectors are used to interconnect panels into strings. Pre-attached cables from each panel\'s junction box end in MC4 connectors - male on one cable, female on the other. Simply plug them together to connect panels in series. The weatherproof design allows connections to run along mounting rails.',
        specs: [
          { label: 'Purpose', value: 'Panel interconnection' },
          { label: 'Current Rating', value: '30-40A' },
          { label: 'Voltage Rating', value: '1500V DC' },
          { label: 'IP Rating', value: 'IP68 waterproof' },
          { label: 'Installation', value: 'Plug & play' },
          { label: 'Lifespan', value: '25+ years outdoor' }
        ],
        fact: 'MC4 connectors form the "links" that chain panels together into strings. The interconnection wiring runs along the mounting system under the panel rails for protection and neatness.',
        related: ['junction-box', 'solar-panel', 'wire-harness', 'combiner-box']
      },
      'junction-box': {
        title: 'Junction Box',
        category: 'Panel Component',
        desc: 'Mounted on the back of each solar panel, the junction box contains the positive (+) and negative (-) terminals where integrated wires originate. Most modern panels come with pre-attached DC cables that extend from the junction box and end in MC4 connectors. These cables are used to interconnect panels into strings.',
        specs: [
          { label: 'Location', value: 'Back of panel' },
          { label: 'Contains', value: '+/- terminals' },
          { label: 'Bypass Diodes', value: '3 per panel' },
          { label: 'Output', value: 'Pre-attached DC cables' },
          { label: 'Cable Ends', value: 'MC4 connectors' },
          { label: 'IP Rating', value: 'IP67 weatherproof' }
        ],
        fact: 'The junction box is the starting point for string wiring. Pre-attached cables with MC4 connectors make installation fast and reliable - just plug panels together!',
        related: ['solar-panel', 'mc4-connector', 'wire-harness']
      },
      'cable-tray': {
        title: 'Cable Tray',
        category: 'Cable Management',
        desc: 'Structural support systems for routing large cable bundles across the solar field. Trays protect cables from physical damage, organize the DC and AC collection systems, and provide clear access paths for maintenance. Various types include ladder tray, solid bottom, and wire basket.',
        specs: [
          { label: 'Types', value: 'Ladder/Solid/Basket' },
          { label: 'Material', value: 'Aluminum or Steel' },
          { label: 'Width', value: '6-24 inches' },
          { label: 'Support Spacing', value: '5-10 feet' },
          { label: 'Load Rating', value: '50-100 lbs/ft' },
          { label: 'Finish', value: 'Hot-dip galvanized' }
        ],
        fact: 'Properly designed cable tray systems allow for future expansion and make troubleshooting much easier by keeping cables organized and accessible.',
        related: ['dc-cables', 'ac-conduit', 'cab-clip']
      },
      'ground-wire': {
        title: 'Equipment Grounding',
        category: 'Safety System',
        desc: 'The equipment grounding system bonds all metal components to earth ground, providing a safe path for fault currents and protecting personnel from electric shock. Required by the National Electrical Code (NEC) for all PV systems. Includes ground rods, conductors, and bonding jumpers.',
        specs: [
          { label: 'Conductor Size', value: '6-10 AWG copper' },
          { label: 'Color', value: 'Green or bare' },
          { label: 'Ground Rods', value: '8ft min copper' },
          { label: 'Resistance', value: '<25 ohms' },
          { label: 'Connections', value: 'Listed lugs' },
          { label: 'Bonding', value: 'All metal parts' }
        ],
        fact: 'Lightning strikes on solar arrays are relatively common. A proper grounding system safely dissipates millions of volts to earth in microseconds.',
        related: ['driven-pile', 'string-inverter', 'combiner-box']
      },
      'dc-cables': {
        title: 'DC Cables',
        category: 'Power Transmission',
        desc: 'Specialized photovoltaic cables designed for the unique demands of solar installations. PV wire must withstand high DC voltages, UV exposure, extreme temperatures, and decades of outdoor service. Red indicates positive (+) and black indicates negative (-) polarity.',
        specs: [
          { label: 'Type', value: 'PV Wire / USE-2' },
          { label: 'Voltage', value: '2000V DC' },
          { label: 'Temperature', value: '90°C rated' },
          { label: 'UV Resistant', value: 'Yes' },
          { label: 'Sunlight Resistant', value: 'Yes' },
          { label: 'Direct Burial', value: 'Yes' }
        ],
        fact: 'DC arcs are more dangerous than AC arcs because they don\'t self-extinguish at zero-crossing. This is why proper DC-rated equipment and installation practices are critical.',
        related: ['string-inverter', 'combiner-box', 'mc4-connector']
      },
      'ac-conduit': {
        title: 'AC Conduit',
        category: 'Power Transmission',
        desc: 'Metal or PVC conduit protecting AC output cables from the inverter to the point of interconnection. Carries 3-phase AC power at 480V or higher to transformers and switchgear. Must be properly grounded, weatherproofed, and sized for the current load.',
        specs: [
          { label: 'Material', value: 'EMT / RMC / PVC' },
          { label: 'Size', value: '1-4 inches' },
          { label: 'Voltage', value: '480V 3-phase' },
          { label: 'Fill Ratio', value: '40% max' },
          { label: 'Supports', value: 'Every 10 feet' },
          { label: 'Fittings', value: 'Weatherproof' }
        ],
        fact: 'The AC collection system typically accounts for 10-15% of total project costs but is critical for efficiently moving power from distributed inverters to the substation.',
        related: ['string-inverter', 'cable-tray', 'ground-wire']
      },
      'tracker-motor': {
        title: 'Tracker Drive System',
        category: 'Motion Control',
        desc: 'The motor and gearbox assembly that rotates the torque tube to follow the sun. Uses sensors or astronomical algorithms to determine sun position, then motors slowly adjust panel angle throughout the day. By keeping panels perpendicular to sunlight, trackers boost energy production 15-40% vs fixed systems.',
        specs: [
          { label: 'Sensing', value: 'Sensors or algorithms' },
          { label: 'Movement', value: 'Slew drive motor' },
          { label: 'Rotation Range', value: '±60° (single-axis)' },
          { label: 'Speed', value: '0.5-1°/minute' },
          { label: 'Control', value: 'GPS + astronomical data' },
          { label: 'Power Boost', value: '+15-40% vs fixed' }
        ],
        fact: 'Trackers use "backtracking" algorithms in morning/evening to prevent row-to-row shading. Instead of pointing directly at the low sun, they angle slightly away to avoid shadows from neighboring rows - maximizing total farm output.',
        related: ['torque-tube', 'solar-panel', 'driven-pile']
      },
      'substation': {
        title: 'Substation',
        category: 'Grid Connection',
        desc: 'The central collection point where power from all inverters is combined and voltage is stepped up for transmission. Contains main power transformers, medium-voltage switchgear, protection relays, revenue metering, and SCADA communication equipment for remote monitoring and control.',
        specs: [
          { label: 'Transformer', value: '34.5kV step-up' },
          { label: 'Switchgear', value: 'Medium voltage' },
          { label: 'Protection', value: 'Digital relays' },
          { label: 'Metering', value: 'Revenue grade' },
          { label: 'Communication', value: 'SCADA/DNP3' },
          { label: 'Grounding', value: 'Ground grid' }
        ],
        fact: 'A typical 100MW solar farm substation handles enough power to supply approximately 20,000 homes during peak production.',
        related: ['string-inverter', 'ac-conduit']
      },
      'free-space': {
        title: 'Inter-Row Spacing',
        category: 'Site Design',
        desc: 'The spacing between tracker rows is carefully calculated to minimize shading while maximizing land use. This "pitch" distance depends on the site latitude, tracker height, and acceptable shading losses. Proper spacing ensures panels don\'t shade each other during morning and afternoon hours.',
        specs: [
          { label: 'Row Pitch', value: '18-25 feet' },
          { label: 'GCR', value: '30-45%' },
          { label: 'Shading Loss', value: '<2% target' },
          { label: 'Access Width', value: '12ft minimum' },
          { label: 'Mowing', value: 'Required clearance' },
          { label: 'Drainage', value: 'Grade consideration' }
        ],
        fact: 'Ground Coverage Ratio (GCR) is the percentage of land covered by panels. Higher GCR means more power per acre but increases row-to-row shading losses.',
        related: ['solar-panel', 'torque-tube', 'driven-pile']
      },
      'did-you-know': {
        title: 'Solar Farm Facts',
        category: 'Education',
        desc: 'Utility-scale solar farms are one of the fastest-growing sources of electricity generation worldwide. A typical 100MW solar farm covers about 500-700 acres and can power approximately 20,000 homes. Solar panels have no moving parts (except trackers) and require minimal maintenance over their 25-30 year lifespan.',
        specs: [
          { label: 'Land Use', value: '5-7 acres/MW' },
          { label: 'Homes Powered', value: '200 per MW' },
          { label: 'CO2 Avoided', value: '1,400 tons/MW/yr' },
          { label: 'Water Use', value: 'Minimal' },
          { label: 'Jobs Created', value: '5-7 per MW' },
          { label: 'Construction', value: '6-12 months' }
        ],
        fact: 'The cost of solar electricity has dropped 89% since 2010, making it now cheaper than coal and natural gas in most regions of the world.',
        related: ['solar-panel', 'string-inverter', 'substation']
      },
      'perimeter-fence': {
        title: 'Perimeter Fence',
        category: 'Site Security',
        desc: 'A security fence surrounds the entire solar farm to prevent unauthorized access, protect valuable equipment from theft and vandalism, and ensure public safety. The fence also keeps wildlife and livestock from damaging panels or electrical equipment.',
        specs: [
          { label: 'Height', value: '6-8 feet' },
          { label: 'Type', value: 'Chain-link/Barbed wire' },
          { label: 'Top Wire', value: '3-strand barbed' },
          { label: 'Gates', value: 'Locked access points' },
          { label: 'Signage', value: 'Warning signs' },
          { label: 'Grounding', value: 'Bonded to ground grid' }
        ],
        fact: 'Security fencing is required by electrical codes and insurance policies. Many solar farms also use camera surveillance and motion sensors for additional protection.',
        related: ['substation', 'ground-wire']
      }
    };

    // === MARKER SYSTEM VARIABLES ===
    let markers = [];
    let markerGroup = null;
    let raycaster = null;
    let mouse = null;
    let labelElements = [];
    
    function createMarkers() {
      markers = [];
      markerGroup = new THREE.Group();
      raycaster = new THREE.Raycaster();
      mouse = new THREE.Vector2();
      
      // Clear existing labels
      const labelsContainer = document.getElementById('labels-container');
      labelsContainer.innerHTML = '';
      labelElements = [];
      
      function createInfoMarker(x, y, z, componentKey, labelText, scale = 1) {
        // Invisible 3D marker for position tracking only
        const markerGeo = new THREE.SphereGeometry(0.15 * scale, 8, 8);
        const markerMat = new THREE.MeshBasicMaterial({ 
          transparent: true,
          opacity: 0
        });
        const marker = new THREE.Mesh(markerGeo, markerMat);
        marker.position.set(x, y, z);
        marker.userData.componentKey = componentKey;
        marker.userData.isMarker = true;
        marker.userData.labelText = labelText;
        
        // Create HTML label with connecting line
        const labelWrapper = document.createElement('div');
        labelWrapper.className = 'marker-label-wrapper';
        labelWrapper.style.cssText = `
          position: absolute;
          display: none;
          flex-direction: column;
          align-items: center;
          pointer-events: none;
          transform: translate(-50%, -100%);
        `;
        
        const label = document.createElement('div');
        label.className = 'marker-label';
        label.innerHTML = labelText;
        label.style.cssText = `
          color: #fff;
          font-size: 13px;
          font-weight: 700;
          text-transform: uppercase;
          letter-spacing: 1.5px;
          background: linear-gradient(135deg, rgba(20,80,100,0.95), rgba(10,50,70,0.95));
          padding: 10px 16px;
          border-radius: 6px;
          pointer-events: auto;
          cursor: pointer;
          white-space: nowrap;
          border-left: 4px solid #38bdf8;
          text-shadow: 0 2px 4px rgba(0,0,0,0.5);
          margin-bottom: 8px;
          box-shadow: 0 4px 15px rgba(0,0,0,0.4), 0 0 20px rgba(56,189,248,0.2);
          transition: all 0.2s ease;
        `;
        label.dataset.componentKey = componentKey;
        
        // Add hover effects
        label.addEventListener('mouseenter', () => {
          label.style.transform = 'scale(1.08)';
          label.style.background = 'linear-gradient(135deg, rgba(56,189,248,0.95), rgba(20,100,130,0.95))';
          label.style.boxShadow = '0 6px 25px rgba(0,0,0,0.5), 0 0 30px rgba(56,189,248,0.4)';
        });
        label.addEventListener('mouseleave', () => {
          label.style.transform = 'scale(1)';
          label.style.background = 'linear-gradient(135deg, rgba(20,80,100,0.95), rgba(10,50,70,0.95))';
          label.style.boxShadow = '0 4px 15px rgba(0,0,0,0.4), 0 0 20px rgba(56,189,248,0.2)';
        });
        
        label.addEventListener('click', (e) => {
          e.stopPropagation();
          showInfoBox(componentKey);
        });
        
        // Connecting line - more visible
        const line = document.createElement('div');
        line.style.cssText = `
          width: 2px;
          height: 35px;
          background: linear-gradient(to bottom, rgba(56,189,248,0.8), rgba(255,255,255,0.3));
          border-radius: 1px;
        `;
        
        // Dot at bottom of line - larger and glowing
        const dot = document.createElement('div');
        dot.style.cssText = `
          width: 12px;
          height: 12px;
          border-radius: 50%;
          background: radial-gradient(circle, #fff 30%, #38bdf8 100%);
          border: 2px solid #38bdf8;
          box-shadow: 0 0 10px rgba(56,189,248,0.6), 0 0 20px rgba(56,189,248,0.3);
          animation: pulse-dot 2s ease-in-out infinite;
        `;
        
        labelWrapper.appendChild(label);
        labelWrapper.appendChild(line);
        labelWrapper.appendChild(dot);
        labelsContainer.appendChild(labelWrapper);
        
        marker.userData.labelElement = labelWrapper;
        labelElements.push({ marker, label: labelWrapper });
        
        markers.push(marker);
        return marker;
      }
      
      // Add markers SPREAD OUT across the farm - NO OVERLAPPING
      // Right block at x=140, Left block at x=-140
      // Rows at z: 117, 99, 81, 63, 45, 27, -27, -45, -63, -81, -99, -117
      
      const rightX = 140;   // Right block center
      const leftX = -140;   // Left block center
      
      // === FAR RIGHT SIDE OF RIGHT BLOCK ===
      // PHOTOVOLTAIC PANEL - front right, on panel row
      markerGroup.add(createInfoMarker(rightX + 80, 7.5, 117, 'solar-panel', 'PHOTOVOLTAIC PANEL', 1.1));
      
      // === MID RIGHT SIDE ===
      // STRING INVERTER - visible on post, on panel row
      markerGroup.add(createInfoMarker(rightX + 60, 3.5, 63, 'string-inverter', 'STRING INVERTER', 1.0));
      
      // === CENTER OF RIGHT BLOCK ===
      // TORQUE TUBE - center of a row, on panel row
      markerGroup.add(createInfoMarker(rightX, 5.5, 45, 'torque-tube', 'TORQUE TUBE', 1.0));
      
      // === LEFT SIDE OF RIGHT BLOCK ===
      // SUPPORT POST - on panel row
      markerGroup.add(createInfoMarker(rightX - 50, 2.5, 99, 'driven-pile', 'SUPPORT POST', 1.0));
      
      // COMBINER BOX - at center of row (where midCBX is placed), on panel row
      markerGroup.add(createInfoMarker(rightX, 3, 27, 'combiner-box', 'COMBINER BOX', 1.0));
      
      // === FAR LEFT SIDE OF LEFT BLOCK ===
      // JUNCTION BOX - on panel row
      markerGroup.add(createInfoMarker(leftX - 70, 6.5, 99, 'junction-box', 'JUNCTION BOX', 1.0));
      
      // MC4 CONNECTORS - on panel row
      markerGroup.add(createInfoMarker(rightX + 20, 6, 63, 'mc4-connector', 'MC4 CONNECTORS', 1.0));
      
      // === MID LEFT BLOCK ===
      // STRING WIRING - on panel row
      markerGroup.add(createInfoMarker(rightX - 20, 5.5, 81, 'wire-harness', 'STRING WIRING', 1.0));
      
      // DC CABLES - on panel row
      markerGroup.add(createInfoMarker(rightX + 40, 4.5, 45, 'dc-cables', 'DC CABLES', 1.0));
      
      // === RIGHT SIDE OF LEFT BLOCK ===
      // CABLE TRAY - on panel row
      markerGroup.add(createInfoMarker(leftX + 70, 4.2, 99, 'cable-tray', 'CABLE TRAY', 1.0));
      
      // CAB CLIPS - on panel row
      markerGroup.add(createInfoMarker(leftX + 90, 5.8, 45, 'cab-clip', 'CAB CLIPS', 0.9));
      
      // === BACK ROWS (negative Z) ===
      // TRACKER MOTOR - back left, on panel row
      markerGroup.add(createInfoMarker(leftX - 80, 5, -45, 'tracker-motor', 'TRACKER MOTOR', 1.0));
      
      // HOME RUN - back right, on panel row
      markerGroup.add(createInfoMarker(rightX + 70, 4, -45, 'home-run', 'STRING HOME RUN', 1.0));
      
      // GROUNDING - back center-left, on panel row
      markerGroup.add(createInfoMarker(leftX + 40, 2, -63, 'ground-wire', 'GROUNDING', 1.0));
      
      // AC CONDUIT - back center-right, at ground level
      markerGroup.add(createInfoMarker(rightX, 1.5, -81, 'ac-conduit', 'AC CONDUIT', 1.0));
      
      // === CENTER AREA ===
      // ROW SPACING - between two adjacent rows to show the spacing
      markerGroup.add(createInfoMarker(140, 1, -36, 'free-space', 'ROW SPACING', 1.0));
      
      // SUBSTATION - center
      markerGroup.add(createInfoMarker(0, 10, 0, 'substation', 'SUBSTATION', 1.2));
      
      // DID YOU KNOW - front center, on panel row
      markerGroup.add(createInfoMarker(0, 6, 117, 'did-you-know', 'DID YOU KNOW?', 1.1));
      
      // PERIMETER FENCE - at the back center of the farm
      markerGroup.add(createInfoMarker(0, 3, -140, 'perimeter-fence', 'FENCE', 1.0));
      
      scene.add(markerGroup);
      
      // Add click listener for 3D markers
      renderer.domElement.addEventListener('click', onMarkerClick);
    }
    
    // Update label positions each frame
    function updateLabelPositions() {
      if (!labelElements.length) return;
      
      // If markers are hidden, make sure all labels are hidden
      if (!markersVisible) {
        labelElements.forEach(({ label }) => {
          label.style.display = 'none';
        });
        return;
      }
      
      labelElements.forEach(({ marker, label }) => {
        // Get screen position of marker
        const vector = marker.position.clone();
        vector.project(camera);
        
        const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
        const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
        
        // Check if marker is in front of camera and within reasonable distance
        const dist = camera.position.distanceTo(marker.position);
        // Hide labels that fall behind the header bar (top 75px); offset y for container top
        const labelY = y - 75;
        if (vector.z < 1 && dist < 400 && y > 80) {
          label.style.left = x + 'px';
          label.style.top = labelY + 'px';
          label.style.display = 'flex';
          // Fade based on distance
          const opacity = Math.max(0.4, Math.min(1, 1 - (dist - 80) / 320));
          label.style.opacity = opacity;
        } else {
          label.style.display = 'none';
        }
      });
    }
    
    function onMarkerClick(event) {
      if (!raycaster || !mouse || !markers.length) return;
      
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
      
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(markers, true);
      
      if (intersects.length > 0) {
        let clickedMarker = intersects[0].object;
        while (clickedMarker && !clickedMarker.userData.isMarker) {
          clickedMarker = clickedMarker.parent;
        }
        if (clickedMarker && clickedMarker.userData.componentKey) {
          showInfoBox(clickedMarker.userData.componentKey);
        }
      }
    }
    
    // === DETAIL PANEL FUNCTIONS ===
    function showInfoBox(componentKey) {
      const info = componentInfo[componentKey];
      if (!info) return;
      
      // Find the marker for this component and zoom to it
      const markerData = labelElements.find(el => el.marker.userData.componentKey === componentKey);
      if (markerData) {
        const pos = markerData.marker.position;
        // Calculate camera position - offset from marker
        const camOffset = 25; // Distance from component
        const camHeight = 12; // Height above component
        const targetX = pos.x;
        const targetY = pos.y;
        const targetZ = pos.z;
        
        // Animate camera to view the component
        animateCameraTo(
          pos.x + camOffset * 0.5, 
          pos.y + camHeight, 
          pos.z + camOffset,
          targetX, targetY, targetZ
        );
      }
      
      // Populate detail panel
      document.getElementById('detail-title').innerHTML = info.title;
      document.getElementById('detail-category').innerHTML = info.category;
      document.getElementById('detail-desc').innerHTML = info.desc;
      
      // Populate specs grid
      const specsContainer = document.getElementById('detail-specs');
      specsContainer.innerHTML = info.specs.map(spec => `
        <div style="background:rgba(255,255,255,0.05); padding:10px; border-radius:3px;">
          <div style="color:#888; font-size:0.75em; text-transform:uppercase; margin-bottom:4px;">${spec.label}</div>
          <div style="color:#fff; font-size:0.95em; font-weight:500;">${spec.value}</div>
        </div>
      `).join('');
      
      // Generate component diagram
      const imageContainer = document.getElementById('detail-image');
      imageContainer.innerHTML = getComponentDiagram(componentKey);
      
      // Populate gallery with detail diagrams
      const galleryContainer = document.getElementById('detail-gallery');
      galleryContainer.innerHTML = getComponentGallery(componentKey);
      
      // Populate fact
      document.getElementById('detail-fact-text').innerHTML = info.fact;
      
      // Populate related components
      const relatedContainer = document.getElementById('detail-related');
      relatedContainer.innerHTML = info.related.map(key => {
        const relatedInfo = componentInfo[key];
        if (!relatedInfo) return '';
        return `
          <button onclick="showInfoBox('${key}')" style="background:rgba(255,255,255,0.1); border:1px solid rgba(255,255,255,0.2); color:#fff; padding:8px 12px; border-radius:3px; cursor:pointer; font-size:0.8em;">
            ${relatedInfo.title}
          </button>
        `;
      }).join('');
      
      // Hide top-right buttons so they don't block the detail panel title
      document.getElementById('site-gen-wrapper').style.display = 'none';
      document.getElementById('toggle-markers').style.display = 'none';

      // Show panel with animation
      document.getElementById('detail-overlay').style.display = 'block';
      const panel = document.getElementById('detail-panel');
      panel.style.display = 'block';
      setTimeout(() => {
        panel.style.transform = 'translateX(0)';
      }, 10);

      // Scroll to top
      panel.scrollTop = 0;
    }
    
    // Generate SVG diagrams for each component
    function getComponentDiagram(key) {
      const diagrams = {
        'solar-panel': `
          <svg viewBox="0 0 200 120" style="width:100%;height:100%;">
            <defs>
              <linearGradient id="panelGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                <stop offset="0%" style="stop-color:#1a3a5c"/>
                <stop offset="100%" style="stop-color:#0d1f33"/>
              </linearGradient>
            </defs>
            <rect x="10" y="10" width="180" height="100" fill="url(#panelGrad)" stroke="#4aa" stroke-width="2" rx="2"/>
            <!-- Grid lines -->
            <g stroke="#2a4a6a" stroke-width="0.5">
              <line x1="10" y1="35" x2="190" y2="35"/>
              <line x1="10" y1="60" x2="190" y2="60"/>
              <line x1="10" y1="85" x2="190" y2="85"/>
              <line x1="40" y1="10" x2="40" y2="110"/>
              <line x1="70" y1="10" x2="70" y2="110"/>
              <line x1="100" y1="10" x2="100" y2="110"/>
              <line x1="130" y1="10" x2="130" y2="110"/>
              <line x1="160" y1="10" x2="160" y2="110"/>
            </g>
            <!-- Cells -->
            <g fill="#1e4060">
              ${[0,1,2,3,4,5].map(col => [0,1,2,3].map(row => 
                `<rect x="${15+col*30}" y="${15+row*25}" width="25" height="20" rx="1"/>`
              ).join('')).join('')}
            </g>
            <text x="100" y="70" text-anchor="middle" fill="#4aa" font-size="8">72 Monocrystalline Cells</text>
          </svg>`,
        'torque-tube': `
          <svg viewBox="0 0 200 120" style="width:100%;height:100%;">
            <!-- Title -->
            <text x="100" y="10" text-anchor="middle" fill="#4aa" font-size="7">SINGLE-AXIS TRACKER (East-West Rotation)</text>
            
            <defs>
              <linearGradient id="tubeGrad" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" style="stop-color:#999"/>
                <stop offset="50%" style="stop-color:#666"/>
                <stop offset="100%" style="stop-color:#999"/>
              </linearGradient>
            </defs>
            
            <!-- Torque Tube -->
            <rect x="15" y="50" width="170" height="16" fill="url(#tubeGrad)" rx="8"/>
            <text x="100" y="61" text-anchor="middle" fill="#333" font-size="5">TORQUE TUBE</text>
            
            <!-- Rotation arrows showing ±60° -->
            <path d="M 100 30 A 25 25 0 0 1 120 50" stroke="#0f8" stroke-width="2" fill="none"/>
            <polygon points="120,50 115,45 118,53" fill="#0f8"/>
            <path d="M 100 86 A 25 25 0 0 0 120 66" stroke="#0f8" stroke-width="2" fill="none"/>
            <polygon points="120,66 115,71 118,63" fill="#0f8"/>
            <text x="135" y="58" fill="#0f8" font-size="6">±60°</text>
            
            <!-- Array-style bearing (left) - large shield with flame cutouts -->
            <path d="M 22 32 L 58 32 Q 66 40 66 58 Q 66 76 58 84 L 22 84 Z" fill="#b0b0b0" stroke="#888"/>
            <!-- Flame-like cutouts (Array signature design) -->
            <path d="M 30 40 Q 35 36 40 40 Q 45 36 50 40" stroke="#87CEEB" stroke-width="3" fill="none"/>
            <path d="M 30 52 Q 35 48 40 52 Q 45 48 50 52" stroke="#87CEEB" stroke-width="3" fill="none"/>
            <path d="M 30 64 Q 35 60 40 64 Q 45 60 50 64" stroke="#87CEEB" stroke-width="3" fill="none"/>
            <!-- Horizontal U-channel arms -->
            <rect x="16" y="42" width="10" height="6" fill="#707070"/>
            <rect x="16" y="68" width="10" height="6" fill="#707070"/>
            <!-- Bolts -->
            <circle cx="20" cy="45" r="2" fill="#333"/>
            <circle cx="20" cy="71" r="2" fill="#333"/>
            <text x="44" y="97" text-anchor="middle" fill="#2255aa" font-size="5" font-weight="bold">ARRAY</text>
            
            <!-- Nextracker-style bearing (right) -->
            <circle cx="160" cy="58" r="16" fill="#666" stroke="#888" stroke-width="2"/>
            <circle cx="160" cy="58" r="10" fill="#555"/>
            <circle cx="160" cy="80" r="8" fill="#ff6600"/>
            <line x1="157" y1="77" x2="163" y2="83" stroke="#fff" stroke-width="2"/>
            <line x1="163" y1="77" x2="157" y2="83" stroke="#fff" stroke-width="2"/>
            <text x="160" y="97" text-anchor="middle" fill="#ff6600" font-size="5" font-weight="bold">NEXTRACKER</text>
            
            <text x="100" y="112" text-anchor="middle" fill="#888" font-size="6">Rotates all panels simultaneously to follow the sun</text>
          </svg>`,
        'driven-pile': `
          <svg viewBox="0 0 200 120" style="width:100%;height:100%;">
            <!-- Ground -->
            <rect x="0" y="85" width="200" height="35" fill="#3a5a40"/>
            <line x1="0" y1="85" x2="200" y2="85" stroke="#5a8a50" stroke-width="2"/>
            
            <!-- W-beam post -->
            <rect x="88" y="25" width="24" height="95" fill="#777"/>
            <rect x="82" y="25" width="36" height="6" fill="#888"/>
            <rect x="82" y="40" width="36" height="3" fill="#666"/>
            <rect x="82" y="55" width="36" height="3" fill="#666"/>
            
            <!-- Torque tube (top) -->
            <rect x="40" y="18" width="120" height="14" fill="#888" rx="7"/>
            
            <!-- Bearing assembly (Array style) -->
            <path d="M 110 15 L 145 15 Q 160 20 160 35 Q 160 50 145 55 L 110 55 Z" fill="#999" stroke="#777" stroke-width="1"/>
            <rect x="120" y="22" width="25" height="6" fill="#3a5a4a"/>
            <rect x="120" y="35" width="25" height="6" fill="#3a5a4a"/>
            <rect x="120" y="48" width="20" height="5" fill="#3a5a4a"/>
            
            <!-- Bolts -->
            <circle cx="115" cy="25" r="3" fill="#444"/>
            <circle cx="115" cy="45" r="3" fill="#444"/>
            
            <!-- Dimensions -->
            <line x1="55" y1="25" x2="55" y2="85" stroke="#4aa" stroke-width="1" stroke-dasharray="3"/>
            <text x="45" y="55" fill="#4aa" font-size="6" transform="rotate(-90 45 55)">5-8 ft</text>
            <line x1="145" y1="85" x2="145" y2="115" stroke="#4aa" stroke-width="1" stroke-dasharray="3"/>
            <text x="155" y="102" fill="#4aa" font-size="6">4-8 ft embed</text>
            
            <text x="100" y="10" text-anchor="middle" fill="#4aa" font-size="7">Bearing mounts tube to post</text>
          </svg>`,
        'string-inverter': `
          <svg viewBox="0 0 200 120" style="width:100%;height:100%;">
            <!-- Enclosure -->
            <rect x="40" y="15" width="120" height="90" fill="#444" stroke="#666" stroke-width="2" rx="3"/>
            <!-- Display -->
            <rect x="55" y="25" width="50" height="25" fill="#1a3a45" stroke="#4aa" stroke-width="1" rx="2"/>
            <text x="80" y="42" text-anchor="middle" fill="#4aa" font-size="8">480V AC</text>
            <!-- LEDs -->
            <circle cx="120" cy="32" r="4" fill="#0f0"/>
            <circle cx="135" cy="32" r="4" fill="#0f0"/>
            <!-- Vents -->
            <g fill="#333">
              <rect x="55" y="60" width="90" height="3"/>
              <rect x="55" y="67" width="90" height="3"/>
              <rect x="55" y="74" width="90" height="3"/>
            </g>
            <!-- Connections -->
            <rect x="55" y="85" width="15" height="10" fill="#a33" rx="1"/>
            <rect x="75" y="85" width="15" height="10" fill="#33a" rx="1"/>
            <rect x="95" y="85" width="15" height="10" fill="#3a3" rx="1"/>
            <text x="62" y="110" fill="#a66" font-size="6">DC+</text>
            <text x="82" y="110" fill="#66a" font-size="6">DC-</text>
            <text x="100" y="110" fill="#6a6" font-size="6">GND</text>
          </svg>`,
        'combiner-box': `
          <svg viewBox="0 0 200 120" style="width:100%;height:100%;">
            <!-- Title -->
            <text x="100" y="10" text-anchor="middle" fill="#4aa" font-size="7">COMBINER BOX INTERNALS</text>
            
            <!-- Box enclosure -->
            <rect x="25" y="15" width="150" height="95" fill="#ccc" stroke="#888" stroke-width="2" rx="3"/>
            
            <!-- String inputs (left side - red cables) -->
            <text x="15" y="35" fill="#a33" font-size="5" text-anchor="end">STR 1</text>
            <text x="15" y="50" fill="#a33" font-size="5" text-anchor="end">STR 2</text>
            <text x="15" y="65" fill="#a33" font-size="5" text-anchor="end">STR 3</text>
            <text x="15" y="80" fill="#a33" font-size="5" text-anchor="end">STR 4</text>
            <line x1="18" y1="32" x2="35" y2="32" stroke="#a33" stroke-width="3"/>
            <line x1="18" y1="47" x2="35" y2="47" stroke="#a33" stroke-width="3"/>
            <line x1="18" y1="62" x2="35" y2="62" stroke="#a33" stroke-width="3"/>
            <line x1="18" y1="77" x2="35" y2="77" stroke="#a33" stroke-width="3"/>
            
            <!-- DC input terminals -->
            <rect x="35" y="28" width="12" height="8" fill="#a33" stroke="#800"/>
            <rect x="35" y="43" width="12" height="8" fill="#a33" stroke="#800"/>
            <rect x="35" y="58" width="12" height="8" fill="#a33" stroke="#800"/>
            <rect x="35" y="73" width="12" height="8" fill="#a33" stroke="#800"/>
            
            <!-- Fuses (yellow) -->
            <rect x="55" y="25" width="25" height="12" fill="#ffcc00" stroke="#cc9900" rx="2"/>
            <rect x="55" y="40" width="25" height="12" fill="#ffcc00" stroke="#cc9900" rx="2"/>
            <rect x="55" y="55" width="25" height="12" fill="#ffcc00" stroke="#cc9900" rx="2"/>
            <rect x="55" y="70" width="25" height="12" fill="#ffcc00" stroke="#cc9900" rx="2"/>
            <text x="67" y="34" text-anchor="middle" fill="#333" font-size="4">15A</text>
            <text x="67" y="49" text-anchor="middle" fill="#333" font-size="4">15A</text>
            <text x="67" y="64" text-anchor="middle" fill="#333" font-size="4">15A</text>
            <text x="67" y="79" text-anchor="middle" fill="#333" font-size="4">15A</text>
            <text x="67" y="95" text-anchor="middle" fill="#cc9900" font-size="6">FUSES</text>
            
            <!-- Bus bars (copper) -->
            <rect x="90" y="25" width="8" height="60" fill="#b87333" stroke="#996633"/>
            <rect x="102" y="25" width="8" height="60" fill="#666" stroke="#444"/>
            <text x="99" y="95" text-anchor="middle" fill="#b87333" font-size="5">BUS BARS</text>
            
            <!-- SPD (blue) -->
            <rect x="120" y="30" width="25" height="45" fill="#0066cc" stroke="#004499" rx="2"/>
            <circle cx="132" cy="42" r="4" fill="#00ff00"/>
            <text x="132" y="58" text-anchor="middle" fill="#fff" font-size="4">SPD</text>
            <text x="132" y="68" text-anchor="middle" fill="#aaf" font-size="4">OK</text>
            <text x="132" y="95" text-anchor="middle" fill="#08f" font-size="5">SURGE PROT.</text>
            
            <!-- Output (right side) -->
            <line x1="150" y1="50" x2="180" y2="50" stroke="#0a8" stroke-width="4"/>
            <polygon points="180,45 195,50 180,55" fill="#0a8"/>
            <text x="185" y="65" fill="#0a8" font-size="5">TO</text>
            <text x="185" y="73" fill="#0a8" font-size="5">INVERTER</text>
            
            <!-- Warning label -->
            <rect x="145" y="85" width="28" height="18" fill="#ff0" stroke="#f90"/>
            <text x="159" y="95" text-anchor="middle" fill="#000" font-size="5">⚡1500V</text>
            <text x="159" y="102" text-anchor="middle" fill="#000" font-size="4">DC</text>
          </svg>`,
        'wire-harness': `
          <svg viewBox="0 0 200 120" style="width:100%;height:100%;">
            <!-- Title -->
            <text x="100" y="10" text-anchor="middle" fill="#4aa" font-size="7">STRING WIRING FLOW</text>
            
            <!-- Three panels in a row (top view showing backs) -->
            <rect x="10" y="18" width="50" height="35" fill="#333" stroke="#555"/>
            <rect x="75" y="18" width="50" height="35" fill="#333" stroke="#555"/>
            <rect x="140" y="18" width="50" height="35" fill="#333" stroke="#555"/>
            
            <!-- Junction boxes on each panel -->
            <rect x="25" y="28" width="20" height="15" fill="#444" stroke="#666" rx="2"/>
            <rect x="90" y="28" width="20" height="15" fill="#444" stroke="#666" rx="2"/>
            <rect x="155" y="28" width="20" height="15" fill="#444" stroke="#666" rx="2"/>
            <text x="35" y="38" text-anchor="middle" fill="#888" font-size="4">J-Box</text>
            <text x="100" y="38" text-anchor="middle" fill="#888" font-size="4">J-Box</text>
            <text x="165" y="38" text-anchor="middle" fill="#888" font-size="4">J-Box</text>
            
            <!-- Pre-attached cables from junction boxes -->
            <path d="M 45 36 L 55 36 L 55 60" stroke="#a33" stroke-width="2" fill="none"/>
            <path d="M 25 36 L 15 36 L 15 60" stroke="#33a" stroke-width="2" fill="none"/>
            <path d="M 110 36 L 120 36 L 120 60" stroke="#a33" stroke-width="2" fill="none"/>
            <path d="M 90 36 L 80 36 L 80 60" stroke="#33a" stroke-width="2" fill="none"/>
            <path d="M 175 36 L 185 36 L 185 60" stroke="#a33" stroke-width="2" fill="none"/>
            <path d="M 155 36 L 145 36 L 145 60" stroke="#33a" stroke-width="2" fill="none"/>
            
            <!-- MC4 connectors (circles where cables meet) -->
            <circle cx="55" cy="65" r="4" fill="#a33" stroke="#fff" stroke-width="1"/>
            <circle cx="80" cy="65" r="4" fill="#33a" stroke="#fff" stroke-width="1"/>
            <circle cx="120" cy="65" r="4" fill="#a33" stroke="#fff" stroke-width="1"/>
            <circle cx="145" cy="65" r="4" fill="#33a" stroke="#fff" stroke-width="1"/>
            
            <!-- MC4 interconnection lines -->
            <line x1="55" y1="65" x2="80" y2="65" stroke="#666" stroke-width="3"/>
            <line x1="120" y1="65" x2="145" y2="65" stroke="#666" stroke-width="3"/>
            
            <!-- Labels -->
            <text x="67" y="77" text-anchor="middle" fill="#4aa" font-size="5">MC4</text>
            <text x="132" y="77" text-anchor="middle" fill="#4aa" font-size="5">MC4</text>
            
            <!-- Mounting rail representation -->
            <rect x="5" y="58" width="190" height="4" fill="#666" opacity="0.5"/>
            <text x="100" y="90" text-anchor="middle" fill="#888" font-size="5">Wiring runs along mounting rails</text>
            
            <!-- Arrow to inverter/combiner -->
            <path d="M 185 65 L 195 65" stroke="#4aa" stroke-width="2"/>
            <polygon points="195,62 200,65 195,68" fill="#4aa"/>
            <text x="100" y="100" text-anchor="middle" fill="#888" font-size="5">Routes via conduit to Inverter/Combiner</text>
            
            <text x="100" y="115" text-anchor="middle" fill="#4aa" font-size="6">Junction Box → MC4 Connectors → Inverter</text>
          </svg>`,
        'home-run': `
          <svg viewBox="0 0 200 120" style="width:100%;height:100%;">
            <!-- Title -->
            <text x="100" y="10" text-anchor="middle" fill="#4aa" font-size="7">HOME RUN: String to Inverter</text>
            
            <!-- Panel string representation -->
            <rect x="140" y="20" width="55" height="35" fill="#1a3a5c" stroke="#4aa" rx="2"/>
            <text x="167" y="40" text-anchor="middle" fill="#4aa" font-size="5">Panel String</text>
            
            <!-- Conduit representation -->
            <rect x="60" y="55" width="80" height="12" fill="#666" rx="6"/>
            <text x="100" y="63" text-anchor="middle" fill="#aaa" font-size="5">UV Conduit</text>
            
            <!-- Inverter/Combiner box -->
            <rect x="5" y="45" width="45" height="35" fill="#ddd" stroke="#999" rx="2"/>
            <text x="27" y="65" text-anchor="middle" fill="#666" font-size="5">Inverter/</text>
            <text x="27" y="73" text-anchor="middle" fill="#666" font-size="5">Combiner</text>
            
            <!-- Cables from string to conduit to inverter -->
            <path d="M 140 40 L 140 57 L 60 57" stroke="#a33" stroke-width="3" fill="none"/>
            <path d="M 140 50 L 130 50 L 130 63 L 60 63" stroke="#33a" stroke-width="3" fill="none"/>
            <path d="M 60 57 L 50 57" stroke="#a33" stroke-width="3" fill="none"/>
            <path d="M 60 63 L 50 63" stroke="#33a" stroke-width="3" fill="none"/>
            
            <!-- Labels -->
            <text x="145" y="95" fill="#a66" font-size="6">DC+</text>
            <text x="145" y="105" fill="#66a" font-size="6">DC-</text>
            
            <text x="100" y="90" text-anchor="middle" fill="#888" font-size="5">Protected routing via conduit</text>
            <text x="100" y="115" text-anchor="middle" fill="#4aa" font-size="6">Meets NEC safety codes</text>
          </svg>`,
        'cab-clip': `
          <svg viewBox="0 0 200 120" style="width:100%;height:100%;">
            <!-- Structure beam -->
            <rect x="20" y="50" width="160" height="15" fill="#666"/>
            <!-- CAB clips -->
            <g fill="#c33">
              <path d="M 50 50 Q 50 30 60 30 L 70 30 Q 80 30 80 50 L 80 45 Q 80 35 70 35 L 60 35 Q 50 35 50 45 Z"/>
              <path d="M 110 50 Q 110 30 120 30 L 130 30 Q 140 30 140 50 L 140 45 Q 140 35 130 35 L 120 35 Q 110 35 110 45 Z"/>
            </g>
            <!-- Cables through clips -->
            <g fill="none" stroke-width="6">
              <path d="M 20 40 L 180 40" stroke="#a33"/>
              <path d="M 20 45 L 180 45" stroke="#33a"/>
            </g>
            <!-- Labels -->
            <text x="65" y="20" text-anchor="middle" fill="#c66" font-size="7">CAB Clip</text>
            <text x="125" y="20" text-anchor="middle" fill="#c66" font-size="7">CAB Clip</text>
            <text x="100" y="90" text-anchor="middle" fill="#4aa" font-size="8">Secures cables to structure</text>
          </svg>`,
        'mc4-connector': `
          <svg viewBox="0 0 200 120" style="width:100%;height:100%;">
            <!-- Title -->
            <text x="100" y="12" text-anchor="middle" fill="#4aa" font-size="7">MC4 PANEL INTERCONNECTION</text>
            
            <!-- Two panels -->
            <rect x="10" y="25" width="70" height="35" fill="#1a3a5c" stroke="#4aa"/>
            <rect x="120" y="25" width="70" height="35" fill="#1a3a5c" stroke="#4aa"/>
            <text x="45" y="45" text-anchor="middle" fill="#4aa" font-size="5">Panel 1</text>
            <text x="155" y="45" text-anchor="middle" fill="#4aa" font-size="5">Panel 2</text>
            
            <!-- Cables from panels -->
            <path d="M 65 60 L 65 75" stroke="#a33" stroke-width="3"/>
            <path d="M 135 60 L 135 75" stroke="#33a" stroke-width="3"/>
            
            <!-- Male connector (from Panel 1) -->
            <rect x="55" y="75" width="20" height="12" fill="#222" rx="2"/>
            <rect x="75" y="78" width="8" height="6" fill="#333"/>
            <circle cx="79" cy="81" r="2" fill="#b87333"/>
            
            <!-- Female connector (from Panel 2) -->
            <rect x="125" y="75" width="20" height="12" fill="#222" rx="2"/>
            <rect x="117" y="78" width="8" height="6" fill="#333"/>
            <circle cx="121" cy="81" r="3" fill="#333" stroke="#b87333" stroke-width="1"/>
            
            <!-- Connection in middle -->
            <line x1="83" y1="81" x2="117" y2="81" stroke="#4aa" stroke-width="2" stroke-dasharray="4"/>
            <text x="100" y="78" text-anchor="middle" fill="#4aa" font-size="5">Click!</text>
            
            <!-- Labels -->
            <text x="65" y="95" text-anchor="middle" fill="#a66" font-size="5">Male +</text>
            <text x="135" y="95" text-anchor="middle" fill="#66a" font-size="5">Female -</text>
            
            <text x="100" y="110" text-anchor="middle" fill="#888" font-size="6">Plug together to connect panels in series</text>
          </svg>`,
        'junction-box': `
          <svg viewBox="0 0 200 120" style="width:100%;height:100%;">
            <!-- Title -->
            <text x="100" y="10" text-anchor="middle" fill="#4aa" font-size="7">JUNCTION BOX (Back of Panel)</text>
            
            <!-- Panel back surface -->
            <rect x="30" y="18" width="140" height="50" fill="#333" stroke="#555"/>
            <text x="100" y="35" text-anchor="middle" fill="#666" font-size="6">Panel Back</text>
            
            <!-- Junction box -->
            <rect x="60" y="38" width="80" height="30" fill="#444" stroke="#666" stroke-width="2" rx="3"/>
            <text x="100" y="52" text-anchor="middle" fill="#aaa" font-size="6">JUNCTION BOX</text>
            
            <!-- + and - terminals inside -->
            <circle cx="80" cy="58" r="5" fill="#a33" stroke="#fff"/>
            <text x="80" y="61" text-anchor="middle" fill="#fff" font-size="6">+</text>
            <circle cx="120" cy="58" r="5" fill="#33a" stroke="#fff"/>
            <text x="120" y="61" text-anchor="middle" fill="#fff" font-size="6">-</text>
            
            <!-- Pre-attached DC cables coming out -->
            <path d="M 80 63 L 80 85" stroke="#a33" stroke-width="4" fill="none"/>
            <path d="M 120 63 L 120 85" stroke="#33a" stroke-width="4" fill="none"/>
            
            <!-- MC4 connectors at cable ends -->
            <rect x="73" y="85" width="14" height="12" fill="#222" stroke="#444" rx="2"/>
            <rect x="113" y="85" width="14" height="12" fill="#222" stroke="#444" rx="2"/>
            <text x="80" y="93" text-anchor="middle" fill="#888" font-size="4">MC4</text>
            <text x="120" y="93" text-anchor="middle" fill="#888" font-size="4">MC4</text>
            
            <!-- Labels -->
            <text x="55" y="78" fill="#a66" font-size="6">DC+</text>
            <text x="135" y="78" fill="#66a" font-size="6">DC-</text>
            
            <text x="100" y="110" text-anchor="middle" fill="#4aa" font-size="6">Pre-attached cables end in MC4 connectors</text>
          </svg>`,
        'cable-tray': `
          <svg viewBox="0 0 200 120" style="width:100%;height:100%;">
            <!-- Tray structure -->
            <path d="M 10 40 L 10 80 L 190 80 L 190 40" stroke="#888" stroke-width="3" fill="none"/>
            <g stroke="#666" stroke-width="2">
              <line x1="30" y1="40" x2="30" y2="80"/>
              <line x1="60" y1="40" x2="60" y2="80"/>
              <line x1="90" y1="40" x2="90" y2="80"/>
              <line x1="120" y1="40" x2="120" y2="80"/>
              <line x1="150" y1="40" x2="150" y2="80"/>
              <line x1="170" y1="40" x2="170" y2="80"/>
            </g>
            <!-- Cables in tray -->
            <ellipse cx="45" cy="65" rx="10" ry="8" fill="#a33"/>
            <ellipse cx="75" cy="65" rx="10" ry="8" fill="#33a"/>
            <ellipse cx="105" cy="65" rx="10" ry="8" fill="#a33"/>
            <ellipse cx="135" cy="65" rx="10" ry="8" fill="#33a"/>
            <!-- Support -->
            <rect x="95" y="80" width="10" height="30" fill="#555"/>
            <text x="100" y="25" text-anchor="middle" fill="#4aa" font-size="8">Ladder-type Cable Tray</text>
          </svg>`,
        'ground-wire': `
          <svg viewBox="0 0 200 120" style="width:100%;height:100%;">
            <!-- Ground symbol -->
            <g stroke="#3a3" stroke-width="3" fill="none">
              <line x1="100" y1="10" x2="100" y2="40"/>
              <line x1="70" y1="40" x2="130" y2="40"/>
              <line x1="80" y1="50" x2="120" y2="50"/>
              <line x1="90" y1="60" x2="110" y2="60"/>
            </g>
            <!-- Ground wire -->
            <path d="M 100 60 L 100 85 Q 100 100 80 100 L 20 100" stroke="#3a3" stroke-width="4" fill="none"/>
            <!-- Ground rod -->
            <rect x="15" y="90" width="10" height="25" fill="#b87333"/>
            <!-- Equipment -->
            <rect x="150" y="70" width="40" height="40" fill="#666" stroke="#888" stroke-width="1" rx="2"/>
            <path d="M 100 85 L 150 85" stroke="#3a3" stroke-width="4" fill="none"/>
            <text x="170" y="95" text-anchor="middle" fill="#888" font-size="6">Equipment</text>
            <text x="100" y="20" text-anchor="middle" fill="#3a3" font-size="8">Earth Ground</text>
          </svg>`,
        'dc-cables': `
          <svg viewBox="0 0 200 120" style="width:100%;height:100%;">
            <!-- Cable cross-section -->
            <circle cx="60" cy="60" r="30" fill="#a33" stroke="#822" stroke-width="2"/>
            <circle cx="60" cy="60" r="15" fill="#b87333"/>
            <text x="60" y="65" text-anchor="middle" fill="#fff" font-size="8">+</text>
            <text x="60" y="105" text-anchor="middle" fill="#a66" font-size="8">DC Positive</text>
            
            <circle cx="140" cy="60" r="30" fill="#33a" stroke="#228" stroke-width="2"/>
            <circle cx="140" cy="60" r="15" fill="#b87333"/>
            <text x="140" y="65" text-anchor="middle" fill="#fff" font-size="8">−</text>
            <text x="140" y="105" text-anchor="middle" fill="#66a" font-size="8">DC Negative</text>
            
            <text x="100" y="20" text-anchor="middle" fill="#4aa" font-size="8">PV Wire Cross-Section (10 AWG)</text>
          </svg>`,
        'ac-conduit': `
          <svg viewBox="0 0 200 120" style="width:100%;height:100%;">
            <!-- Conduit -->
            <rect x="20" y="40" width="160" height="40" fill="#888" rx="20"/>
            <rect x="20" y="50" width="160" height="20" fill="#666"/>
            <!-- Wires inside -->
            <circle cx="60" cy="60" r="6" fill="#a33"/>
            <circle cx="100" cy="60" r="6" fill="#33a"/>
            <circle cx="140" cy="60" r="6" fill="#3a3"/>
            <!-- Labels -->
            <text x="60" y="95" text-anchor="middle" fill="#a66" font-size="7">L1</text>
            <text x="100" y="95" text-anchor="middle" fill="#66a" font-size="7">L2</text>
            <text x="140" y="95" text-anchor="middle" fill="#6a6" font-size="7">L3</text>
            <text x="100" y="25" text-anchor="middle" fill="#4aa" font-size="8">EMT Conduit - 3-Phase 480V AC</text>
            <text x="100" y="110" text-anchor="middle" fill="#888" font-size="7">Galvanized Steel / PVC</text>
          </svg>`,
        'tracker-motor': `
          <svg viewBox="0 0 200 120" style="width:100%;height:100%;">
            <!-- Title -->
            <text x="100" y="10" text-anchor="middle" fill="#4aa" font-size="7">HOW THE TRACKER WORKS</text>
            
            <!-- Sun icon -->
            <circle cx="170" cy="25" r="12" fill="#ffcc00"/>
            <g stroke="#ffcc00" stroke-width="2">
              <line x1="170" y1="8" x2="170" y2="3"/>
              <line x1="170" y1="42" x2="170" y2="47"/>
              <line x1="153" y1="25" x2="148" y2="25"/>
              <line x1="187" y1="25" x2="192" y2="25"/>
              <line x1="158" y1="13" x2="154" y2="9"/>
              <line x1="182" y1="37" x2="186" y2="41"/>
            </g>
            
            <!-- Step 1: Sensor/Algorithm -->
            <rect x="10" y="20" width="55" height="25" fill="#335" stroke="#4aa" rx="3"/>
            <text x="37" y="30" text-anchor="middle" fill="#4aa" font-size="5">1. SENSING</text>
            <text x="37" y="40" text-anchor="middle" fill="#888" font-size="4">GPS + Algorithms</text>
            
            <!-- Arrow 1 -->
            <path d="M 65 32 L 78 32" stroke="#4aa" stroke-width="2"/>
            <polygon points="78,29 85,32 78,35" fill="#4aa"/>
            
            <!-- Step 2: Motor -->
            <ellipse cx="105" cy="32" rx="18" ry="12" fill="#555" stroke="#777"/>
            <text x="105" y="35" text-anchor="middle" fill="#aaa" font-size="5">2. MOTOR</text>
            
            <!-- Arrow 2 -->
            <path d="M 123 32 L 136 32" stroke="#4aa" stroke-width="2"/>
            <polygon points="136,29 143,32 136,35" fill="#4aa"/>
            
            <!-- Step 3: Rotation indicator -->
            <path d="M 155 20 A 15 15 0 0 1 155 44" stroke="#0f8" stroke-width="2" fill="none"/>
            <polygon points="155,44 152,38 158,38" fill="#0f8"/>
            <text x="155" y="35" text-anchor="middle" fill="#0f8" font-size="5">±60°</text>
            
            <!-- Panel representation showing tilt -->
            <rect x="25" y="60" width="70" height="8" fill="#1a3a5c" stroke="#4aa" transform="rotate(-15 60 64)"/>
            <rect x="25" y="75" width="70" height="8" fill="#1a3a5c" stroke="#4aa"/>
            <rect x="25" y="90" width="70" height="8" fill="#1a3a5c" stroke="#4aa" transform="rotate(15 60 94)"/>
            
            <!-- Labels for panel positions -->
            <text x="110" y="62" fill="#888" font-size="5">Morning (East)</text>
            <text x="110" y="79" fill="#0f8" font-size="5">Noon (Flat)</text>
            <text x="110" y="96" fill="#888" font-size="5">Evening (West)</text>
            
            <text x="100" y="112" text-anchor="middle" fill="#4aa" font-size="6">Panels rotate to stay perpendicular to sunlight</text>
          </svg>`,
        'substation': `
          <svg viewBox="0 0 200 120" style="width:100%;height:100%;">
            <!-- Building -->
            <rect x="20" y="50" width="80" height="60" fill="#ddd" stroke="#999" stroke-width="2"/>
            <rect x="50" y="80" width="20" height="30" fill="#666"/>
            <!-- Transformer -->
            <rect x="120" y="40" width="60" height="70" fill="#888" stroke="#666" stroke-width="2" rx="3"/>
            <ellipse cx="150" cy="55" rx="20" ry="10" fill="#777"/>
            <rect x="140" y="75" width="20" height="25" fill="#666"/>
            <!-- Power lines -->
            <line x1="100" y1="70" x2="120" y2="70" stroke="#333" stroke-width="3"/>
            <line x1="150" y1="20" x2="150" y2="40" stroke="#333" stroke-width="3"/>
            <line x1="130" y1="20" x2="170" y2="20" stroke="#333" stroke-width="2"/>
            <!-- Labels -->
            <text x="60" y="45" text-anchor="middle" fill="#666" font-size="7">Control Room</text>
            <text x="150" y="115" text-anchor="middle" fill="#666" font-size="7">Transformer</text>
            <text x="150" y="15" text-anchor="middle" fill="#4aa" font-size="7">To Grid</text>
          </svg>`,
        'free-space': `
          <svg viewBox="0 0 200 120" style="width:100%;height:100%;">
            <!-- Row 1 -->
            <rect x="10" y="10" width="180" height="15" fill="#1a3a5c" stroke="#4aa" stroke-width="1"/>
            <!-- Row 2 -->
            <rect x="10" y="95" width="180" height="15" fill="#1a3a5c" stroke="#4aa" stroke-width="1"/>
            <!-- Spacing indicator -->
            <line x1="100" y1="25" x2="100" y2="95" stroke="#4aa" stroke-width="1" stroke-dasharray="5"/>
            <path d="M 90 30 L 100 25 L 110 30" stroke="#4aa" stroke-width="2" fill="none"/>
            <path d="M 90 90 L 100 95 L 110 90" stroke="#4aa" stroke-width="2" fill="none"/>
            <text x="115" y="60" fill="#4aa" font-size="10">18-25 ft</text>
            <text x="100" y="75" text-anchor="middle" fill="#888" font-size="7">Row Pitch</text>
            <!-- Ground -->
            <rect x="0" y="50" width="200" height="3" fill="#5a8a50" opacity="0.5"/>
          </svg>`,
        'did-you-know': `
          <svg viewBox="0 0 200 120" style="width:100%;height:100%;">
            <!-- Sun -->
            <circle cx="100" cy="35" r="25" fill="#fd0"/>
            <g stroke="#fd0" stroke-width="3">
              <line x1="100" y1="0" x2="100" y2="5"/>
              <line x1="100" y1="65" x2="100" y2="70"/>
              <line x1="65" y1="35" x2="60" y2="35"/>
              <line x1="135" y1="35" x2="140" y2="35"/>
              <line x1="75" y1="10" x2="72" y2="7"/>
              <line x1="125" y1="10" x2="128" y2="7"/>
              <line x1="75" y1="60" x2="72" y2="63"/>
              <line x1="125" y1="60" x2="128" y2="63"/>
            </g>
            <!-- Solar panel -->
            <rect x="50" y="80" width="100" height="30" fill="#1a3a5c" stroke="#4aa" stroke-width="2" transform="rotate(-15 100 95)"/>
            <!-- Arrow from sun -->
            <path d="M 100 65 L 100 78" stroke="#fd0" stroke-width="2" marker-end="url(#arrow)"/>
            <text x="100" y="115" text-anchor="middle" fill="#4aa" font-size="8">Clean Energy from Sunlight</text>
          </svg>`
      };
      return diagrams[key] || `<div style="color:#4aa; font-size:0.9em; text-align:center; padding:40px;">Component Diagram</div>`;
    }
    
    // Generate gallery images for each component
    function getComponentGallery(key) {
      const galleries = {
        'solar-panel': `
          <div style="background:#1a3a45; height:100px; border-radius:3px; display:flex; align-items:center; justify-content:center; flex-direction:column; padding:10px;">
            <svg viewBox="0 0 80 50" style="width:70px;height:45px;">
              <rect x="5" y="5" width="70" height="40" fill="#1a3a5c" stroke="#4aa" stroke-width="1"/>
              <g stroke="#2a4a6a" stroke-width="0.5"><line x1="5" y1="18" x2="75" y2="18"/><line x1="5" y1="32" x2="75" y2="32"/><line x1="28" y1="5" x2="28" y2="45"/><line x1="52" y1="5" x2="52" y2="45"/></g>
            </svg>
            <span style="color:#4aa; font-size:0.7em; margin-top:5px;">Front View</span>
          </div>
          <div style="background:#1a3a45; height:100px; border-radius:3px; display:flex; align-items:center; justify-content:center; flex-direction:column; padding:10px;">
            <svg viewBox="0 0 80 50" style="width:70px;height:45px;">
              <rect x="5" y="5" width="70" height="40" fill="#333" stroke="#555" stroke-width="1"/>
              <rect x="30" y="15" width="20" height="15" fill="#444" stroke="#666"/>
              <line x1="35" y1="30" x2="35" y2="45" stroke="#a33" stroke-width="2"/>
              <line x1="45" y1="30" x2="45" y2="45" stroke="#33a" stroke-width="2"/>
            </svg>
            <span style="color:#4aa; font-size:0.7em; margin-top:5px;">Back (Junction Box)</span>
          </div>`,
        'string-inverter': `
          <div style="background:#1a3a45; height:100px; border-radius:3px; display:flex; align-items:center; justify-content:center; flex-direction:column; padding:10px;">
            <svg viewBox="0 0 80 50" style="width:70px;height:45px;">
              <rect x="10" y="5" width="60" height="40" fill="#444" stroke="#666" stroke-width="1" rx="2"/>
              <rect x="15" y="10" width="25" height="12" fill="#1a3a45" stroke="#4aa"/>
              <circle cx="55" cy="15" r="3" fill="#0f0"/>
            </svg>
            <span style="color:#4aa; font-size:0.7em; margin-top:5px;">Front Panel</span>
          </div>
          <div style="background:#1a3a45; height:100px; border-radius:3px; display:flex; align-items:center; justify-content:center; flex-direction:column; padding:10px;">
            <svg viewBox="0 0 80 50" style="width:70px;height:45px;">
              <rect x="10" y="5" width="60" height="40" fill="#333" stroke="#555" stroke-width="1" rx="2"/>
              <rect x="20" y="35" width="10" height="8" fill="#a33"/>
              <rect x="35" y="35" width="10" height="8" fill="#33a"/>
              <rect x="50" y="35" width="10" height="8" fill="#3a3"/>
            </svg>
            <span style="color:#4aa; font-size:0.7em; margin-top:5px;">Wiring Connections</span>
          </div>`
      };
      return galleries[key] || `
        <div style="background:#1a3a45; height:100px; border-radius:3px; display:flex; align-items:center; justify-content:center;">
          <span style="color:#4aa; font-size:0.8em;">Detail View 1</span>
        </div>
        <div style="background:#1a3a45; height:100px; border-radius:3px; display:flex; align-items:center; justify-content:center;">
          <span style="color:#4aa; font-size:0.8em;">Detail View 2</span>
        </div>`;
    }
    
    window.closeDetailPanel = function() {
      const panel = document.getElementById('detail-panel');
      panel.style.transform = 'translateX(100%)';
      setTimeout(() => {
        panel.style.display = 'none';
        document.getElementById('detail-overlay').style.display = 'none';
      }, 300);
      // Restore top-right buttons
      document.getElementById('site-gen-wrapper').style.display = '';
      document.getElementById('toggle-markers').style.display = '';
    };
    
    // Keep old function name for compatibility
    window.closeInfoBox = window.closeDetailPanel;
    
    // Toggle left education panel visibility
    let leftPanelVisible = true;
    window.toggleLeftPanel = function() {
      leftPanelVisible = !leftPanelVisible;
      const panel = document.getElementById('left-panel');
      const showBtn = document.getElementById('panelShowBtn');
      const hideIcon = document.getElementById('panelHideIcon');
      
      if (leftPanelVisible) {
        panel.classList.remove('hidden');
        showBtn.style.display = 'none';
        hideIcon.textContent = '◀';
      } else {
        panel.classList.add('hidden');
        showBtn.style.display = 'flex';
        hideIcon.textContent = '▶';
      }
    };
    
    // Toggle Learning Path panel visibility
    let learningPathVisible = true;
    window.toggleLearningPath = function() {
      learningPathVisible = !learningPathVisible;
      const panel = document.getElementById('learningPathPanel');
      const showBtn = document.getElementById('showLearningPathBtn');
      
      if (learningPathVisible) {
        panel.style.display = 'block';
        showBtn.style.display = 'none';
      } else {
        panel.style.display = 'none';
        showBtn.style.display = 'block';
      }
    };
    
    // Show Learning Path (used by close-up views)
    window.showLearningPath = function() {
      const panel = document.getElementById('learningPathPanel');
      const showBtn = document.getElementById('showLearningPathBtn');
      learningPathVisible = true;
      panel.style.display = 'block';
      showBtn.style.display = 'none';
    };
    
    // Toggle markers visibility - HIDDEN BY DEFAULT for cleaner learning experience
    let markersVisible = false;
    window.toggleMarkers = function() {
      markersVisible = !markersVisible;
      
      // Toggle HTML labels
      labelElements.forEach(({ label }) => {
        label.style.display = markersVisible ? 'flex' : 'none';
      });
      
      const btn = document.getElementById('toggle-markers');
      btn.innerHTML = markersVisible ? '🏷️ Hide Labels' : '🏷️ Show Labels';
      btn.style.background = markersVisible 
        ? 'linear-gradient(135deg, rgba(255,20,147,0.9), rgba(150,20,100,0.9))' 
        : 'linear-gradient(135deg, rgba(56,189,248,0.9), rgba(20,100,150,0.9))';
      btn.style.borderColor = markersVisible ? '#ff1493' : '#38bdf8';
      btn.style.boxShadow = markersVisible 
        ? '0 4px 15px rgba(0,0,0,0.4), 0 0 20px rgba(255,20,147,0.3)'
        : '0 4px 15px rgba(0,0,0,0.4), 0 0 20px rgba(56,189,248,0.3)';
    };
    
    // Animate markers (subtle effect)
    function animateMarkers() {
      if (!markers || !markers.length) return;
      // Update label positions to follow 3D markers
      updateLabelPositions();
    }

    function animate() {
      animationId = requestAnimationFrame(animate);
      animateMarkers();
      animateHighlights();
      updateDayCycle();
      updateElectricityFlow();
      updateCompass();
      if (renderer && scene && camera) {
        renderer.render(scene, camera);
      }
    }
    
    // Update compass based on camera direction
    function updateCompass() {
      if (!camera) return;
      
      // Calculate camera's horizontal angle relative to target
      const dx = camera.position.x - targetX;
      const dz = camera.position.z - targetZ;
      
      // Get angle in radians (atan2 gives angle from +Z axis)
      const theta = Math.atan2(dx, dz);
      
      // Convert to degrees and rotate compass ring
      // The compass should show which direction the camera is FACING
      // So we rotate opposite to camera's position angle
      const degrees = theta * (180 / Math.PI);
      
      const compassRing = document.getElementById('compass-ring');
      if (compassRing) {
        compassRing.style.transform = `rotate(${degrees}deg)`;
      }
    }
    
    // Day/Night cycle and sun tracking
    function updateDayCycle() {
      if (!isDayCycleActive) return;
      
      // Advance sun angle (complete cycle in ~10 seconds - FASTER)
      sunAngle += 0.002;
      if (sunAngle > 1) sunAngle = 0;
      
      // Calculate sun position (arc across sky)
      const sunRadius = 350;
      const sunX = Math.cos(sunAngle * Math.PI) * sunRadius;
      const sunY = Math.sin(sunAngle * Math.PI) * 250 + 50;
      const sunZ = 80;
      
      if (sunMesh) {
        sunMesh.position.set(sunX, Math.max(30, sunY), sunZ);
        // Rotate sun rays for visual effect
        sunMesh.rotation.z += 0.005;
      }
      if (sunLight) {
        sunLight.position.set(sunX, Math.max(50, sunY), sunZ);
        
        // Adjust light color and intensity based on time of day - STRONGER
        const noon = 0.5;
        const timeFromNoon = Math.abs(sunAngle - noon);
        
        if (sunAngle < 0.1 || sunAngle > 0.9) {
          // Dawn/dusk - orange light
          sunLight.color.setHex(0xff6622);
          sunLight.intensity = 0.6;
          if (sunMesh) sunMesh.material.color.setHex(0xff4400);
        } else if (sunAngle < 0.2 || sunAngle > 0.8) {
          // Early morning/late afternoon
          sunLight.color.setHex(0xffbb44);
          sunLight.intensity = 1.2;
          if (sunMesh) sunMesh.material.color.setHex(0xff8800);
        } else {
          // Midday - bright white/yellow - VERY BRIGHT
          sunLight.color.setHex(0xffffee);
          sunLight.intensity = 1.8;
          if (sunMesh) sunMesh.material.color.setHex(0xffff66);
        }
      }
      
      // Rotate trackers to follow sun - MORE DRAMATIC
      const trackerAngle = (sunAngle - 0.5) * Math.PI * 0.9; // ±80 degrees
      trackerRows.forEach(tracker => {
        if (tracker.userData.panelTable) {
          tracker.userData.panelTable.rotation.x = trackerAngle;
        }
      });
    }
    
    // Electricity flow particle system
    function createElectricityParticles() {
      // Clear existing particles
      electricityParticles.forEach(p => {
        scene.remove(p.mesh);
        if (p.glow) scene.remove(p.glow);
      });
      electricityParticles = [];
      
      // ========== REALISTIC POWER FLOW - SINGLE ROW ==========
      // Focus on ONE row (z=117) on right side at x=140
      // Shows clear path: Module → String → Combiner → Inverter → AC to Grid
      
      const rowZ = 117; // Single focus row
      const baseX = 140; // Right side block
      
      // ===== DC PARTICLE MATERIALS (Cyan - from panels) =====
      const dcMat = new THREE.MeshBasicMaterial({ 
        color: 0x00ffff, 
        transparent: true, 
        opacity: 1.0
      });
      const dcGlowMat = new THREE.MeshBasicMaterial({ 
        color: 0x00ffff, 
        transparent: true, 
        opacity: 0.3
      });
      
      // ===== AC PARTICLE MATERIALS (Orange - to grid) - BRIGHT =====
      const acMat = new THREE.MeshBasicMaterial({ 
        color: 0xff8800, 
        transparent: true, 
        opacity: 1.0
      });
      const acGlowMat = new THREE.MeshBasicMaterial({ 
        color: 0xff5500, 
        transparent: true, 
        opacity: 0.5
      });
      
      const smallGeo = new THREE.SphereGeometry(0.5, 10, 10);
      const medGeo = new THREE.SphereGeometry(0.7, 10, 10);
      const glowGeo = new THREE.SphereGeometry(1.5, 10, 10);
      
      // ===== STAGE 1: MODULE GENERATES DC =====
      // Small particles appearing at panel surfaces (simulating photon absorption)
      for (let i = 0; i < 20; i++) {
        const particle = new THREE.Mesh(smallGeo, dcMat.clone());
        const glow = new THREE.Mesh(glowGeo, dcGlowMat.clone());
        
        // Spread across the row length
        const xPos = baseX - 90 + (i * 9);
        particle.position.set(xPos, 9.2, rowZ);
        glow.position.copy(particle.position);
        
        scene.add(particle);
        scene.add(glow);
        
        electricityParticles.push({
          mesh: particle,
          glow: glow,
          stage: 'module-dc',
          baseX: xPos,
          baseY: 9.2,
          baseZ: rowZ,
          phase: (i / 20) * Math.PI * 2,
          type: 'dc'
        });
      }
      
      // ===== STAGE 2: STRING CONNECTS PANELS =====
      // DC flows along the back of panels toward string end
      for (let i = 0; i < 15; i++) {
        const particle = new THREE.Mesh(medGeo, dcMat.clone());
        const glow = new THREE.Mesh(glowGeo, dcGlowMat.clone());
        
        const startX = baseX - 90 + (i * 6);
        particle.position.set(startX, 8.5, rowZ + 2);
        glow.position.copy(particle.position);
        
        scene.add(particle);
        scene.add(glow);
        
        electricityParticles.push({
          mesh: particle,
          glow: glow,
          stage: 'string-flow',
          startX: baseX - 90,
          endX: baseX + 90,
          speed: 1.2 + Math.random() * 0.4,
          phase: (i / 15) * Math.PI * 2,
          baseY: 8.5,
          baseZ: rowZ + 2,
          type: 'dc'
        });
      }
      
      // ===== STAGE 3: STRING TO COMBINER (down the post) =====
      // Vertical flow down from tracker to combiner box
      for (let i = 0; i < 8; i++) {
        const particle = new THREE.Mesh(medGeo, dcMat.clone());
        const glow = new THREE.Mesh(glowGeo, dcGlowMat.clone());
        
        const startY = 8 - (i * 0.8);
        particle.position.set(baseX + 90, startY, rowZ);
        glow.position.copy(particle.position);
        
        scene.add(particle);
        scene.add(glow);
        
        electricityParticles.push({
          mesh: particle,
          glow: glow,
          stage: 'to-combiner',
          startY: 8.5,
          endY: 2.8,
          speed: 0.08 + Math.random() * 0.03,
          phase: (i / 8) * Math.PI * 2,
          baseX: baseX + 90,
          baseZ: rowZ,
          type: 'dc'
        });
      }
      
      // ===== STAGE 4: COMBINER TO INVERTER =====
      // Horizontal flow along cable tray to inverter
      for (let i = 0; i < 6; i++) {
        const particle = new THREE.Mesh(medGeo, dcMat.clone());
        const glow = new THREE.Mesh(glowGeo, dcGlowMat.clone());
        
        particle.position.set(baseX + 90 + (i * 2), 2.8, rowZ);
        glow.position.copy(particle.position);
        
        scene.add(particle);
        scene.add(glow);
        
        electricityParticles.push({
          mesh: particle,
          glow: glow,
          stage: 'to-inverter',
          startX: baseX + 90,
          endX: baseX + 105,
          speed: 0.4 + Math.random() * 0.15,
          phase: (i / 6) * Math.PI * 2,
          baseY: 2.8,
          baseZ: rowZ,
          type: 'dc'
        });
      }
      
      // ===== STAGE 5: INVERTER CONVERSION (DC → AC) =====
      // Pulsing conversion effect at inverter location
      for (let i = 0; i < 4; i++) {
        // DC going in (cyan)
        const dcIn = new THREE.Mesh(smallGeo, dcMat.clone());
        dcIn.position.set(baseX + 105, 3.5, rowZ);
        scene.add(dcIn);
        
        electricityParticles.push({
          mesh: dcIn,
          stage: 'inverter-in',
          baseX: baseX + 105,
          baseY: 3.5,
          baseZ: rowZ,
          phase: (i / 4) * Math.PI * 2,
          type: 'dc'
        });
        
        // AC coming out (orange)
        const acOut = new THREE.Mesh(medGeo, acMat.clone());
        const acGlow = new THREE.Mesh(glowGeo, acGlowMat.clone());
        acOut.position.set(baseX + 108, 3, rowZ);
        acGlow.position.copy(acOut.position);
        scene.add(acOut);
        scene.add(acGlow);
        
        electricityParticles.push({
          mesh: acOut,
          glow: acGlow,
          stage: 'inverter-out',
          baseX: baseX + 108,
          baseY: 3,
          baseZ: rowZ,
          phase: (i / 4) * Math.PI * 2 + Math.PI,
          type: 'ac'
        });
      }
      
      // ===== STAGE 5c: AC DOWN FROM INVERTER =====
      // AC flows down from inverter to underground conduit
      const acLargeGeo = new THREE.SphereGeometry(0.9, 12, 12);
      const acLargeGlowGeo = new THREE.SphereGeometry(2.2, 12, 12);
      
      for (let i = 0; i < 5; i++) {
        const particle = new THREE.Mesh(acLargeGeo, acMat.clone());
        const glow = new THREE.Mesh(acLargeGlowGeo, acGlowMat.clone());
        
        const startY = 3 - (i * 0.5);
        particle.position.set(baseX + 108, startY, rowZ);
        glow.position.copy(particle.position);
        
        scene.add(particle);
        scene.add(glow);
        
        electricityParticles.push({
          mesh: particle,
          glow: glow,
          stage: 'ac-down',
          startY: 3.2,
          endY: 1.5,
          speed: 0.08 + Math.random() * 0.03,
          phase: (i / 5) * Math.PI * 2,
          baseX: baseX + 108,
          baseZ: rowZ,
          type: 'ac'
        });
      }
      
      // ===== STAGE 6: AC TO SUBSTATION =====
      // AC flows through conduit toward substation (center) - MORE VISIBLE
      for (let i = 0; i < 18; i++) {
        const particle = new THREE.Mesh(acLargeGeo, acMat.clone());
        const glow = new THREE.Mesh(acLargeGlowGeo, acGlowMat.clone());
        
        const startX = baseX + 105 - (i * 7);
        particle.position.set(startX, 1.5, rowZ);
        glow.position.copy(particle.position);
        
        scene.add(particle);
        scene.add(glow);
        
        electricityParticles.push({
          mesh: particle,
          glow: glow,
          stage: 'ac-to-grid',
          startX: baseX + 105,
          endX: 0,
          speed: -(2.0 + Math.random() * 0.8),
          phase: (i / 18) * Math.PI * 2,
          baseY: 1.5,
          baseZ: rowZ,
          type: 'ac'
        });
      }
      
      // ===== CREATE VISUAL PATH GUIDES =====
      const pathMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.15 });
      const acPathMat = new THREE.MeshBasicMaterial({ color: 0xff6600, transparent: true, opacity: 0.25 });
      const conduitMat = new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.6, roughness: 0.4 });
      
      // DC path along panels
      const panelPath = new THREE.Mesh(new THREE.BoxGeometry(180, 0.2, 0.6), pathMat);
      panelPath.position.set(baseX, 8.5, rowZ + 2);
      scene.add(panelPath);
      electricityParticles.push({ mesh: panelPath, type: 'path' });
      
      // Vertical path down to combiner
      const vertPath = new THREE.Mesh(new THREE.BoxGeometry(0.4, 6, 0.4), pathMat);
      vertPath.position.set(baseX + 90, 5.5, rowZ);
      scene.add(vertPath);
      electricityParticles.push({ mesh: vertPath, type: 'path' });
      
      // Path to inverter
      const toInvPath = new THREE.Mesh(new THREE.BoxGeometry(15, 0.25, 0.4), pathMat);
      toInvPath.position.set(baseX + 97, 2.8, rowZ);
      scene.add(toInvPath);
      electricityParticles.push({ mesh: toInvPath, type: 'path' });
      
      // AC vertical conduit from inverter down
      const acVertConduit = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, 2.0, 8), conduitMat);
      acVertConduit.position.set(baseX + 108, 2.2, rowZ);
      scene.add(acVertConduit);
      electricityParticles.push({ mesh: acVertConduit, type: 'path' });
      
      // AC conduit glow (orange glow showing the path)
      const acConduitGlow = new THREE.Mesh(new THREE.BoxGeometry(120, 0.8, 1.5), acPathMat);
      acConduitGlow.position.set(baseX + 45, 1.5, rowZ);
      scene.add(acConduitGlow);
      electricityParticles.push({ mesh: acConduitGlow, type: 'path' });
      
      // Conduit body (gray metal look) - above ground conduit
      const conduitBody = new THREE.Mesh(new THREE.BoxGeometry(120, 0.6, 1.0), conduitMat);
      conduitBody.position.set(baseX + 45, 1.5, rowZ);
      scene.add(conduitBody);
      electricityParticles.push({ mesh: conduitBody, type: 'path' });
      
      console.log('Created realistic single-row power flow with', electricityParticles.length, 'elements');
    }
    
    function updateElectricityFlow() {
      if (!isElectricityFlowActive) return;
      
      const time = Date.now() * 0.001;
      
      electricityParticles.forEach(p => {
        // Skip path elements (they don't move)
        if (p.type === 'path') return;
        
        // ===== STAGE 1: MODULE GENERATES DC (pulsing at panel surface) =====
        if (p.stage === 'module-dc') {
          // Pulsing effect simulating photon absorption and electron generation
          const pulse = Math.sin(time * 8 + p.phase);
          p.mesh.position.y = p.baseY + pulse * 0.3;
          p.mesh.scale.setScalar(0.6 + pulse * 0.4);
          p.mesh.material.opacity = 0.5 + pulse * 0.5;
          if (p.glow) {
            p.glow.position.copy(p.mesh.position);
            p.glow.scale.setScalar(1 + pulse * 0.5);
            p.glow.material.opacity = 0.1 + pulse * 0.15;
          }
          return;
        }
        
        // ===== STAGE 2: STRING FLOW (horizontal along panels) =====
        if (p.stage === 'string-flow') {
          p.mesh.position.x += p.speed;
          p.mesh.position.y = p.baseY + Math.sin(time * 5 + p.phase) * 0.15;
          p.mesh.position.z = p.baseZ + Math.sin(time * 3 + p.phase) * 0.1;
          
          if (p.mesh.position.x > p.endX) {
            p.mesh.position.x = p.startX;
          }
        }
        
        // ===== STAGE 3: TO COMBINER (vertical down post) =====
        else if (p.stage === 'to-combiner') {
          p.mesh.position.y -= p.speed;
          p.mesh.position.x = p.baseX + Math.sin(time * 4 + p.phase) * 0.1;
          p.mesh.position.z = p.baseZ + Math.sin(time * 3 + p.phase) * 0.1;
          
          if (p.mesh.position.y < p.endY) {
            p.mesh.position.y = p.startY;
          }
        }
        
        // ===== STAGE 4: TO INVERTER (horizontal) =====
        else if (p.stage === 'to-inverter') {
          p.mesh.position.x += p.speed;
          p.mesh.position.y = p.baseY + Math.sin(time * 6 + p.phase) * 0.08;
          
          if (p.mesh.position.x > p.endX) {
            p.mesh.position.x = p.startX;
          }
        }
        
        // ===== STAGE 5a: INVERTER INPUT (DC entering) =====
        else if (p.stage === 'inverter-in') {
          const pulse = Math.sin(time * 10 + p.phase);
          p.mesh.position.x = p.baseX + Math.cos(time * 8 + p.phase) * 0.3;
          p.mesh.position.y = p.baseY + pulse * 0.2;
          p.mesh.scale.setScalar(0.5 + Math.abs(pulse) * 0.3);
          p.mesh.material.opacity = 0.6 + pulse * 0.4;
          return;
        }
        
        // ===== STAGE 5b: INVERTER OUTPUT (AC leaving) =====
        else if (p.stage === 'inverter-out') {
          const pulse = Math.sin(time * 10 + p.phase);
          p.mesh.position.x = p.baseX + Math.cos(time * 6 + p.phase + Math.PI) * 0.4;
          p.mesh.position.y = p.baseY + pulse * 0.25;
          p.mesh.scale.setScalar(0.8 + Math.abs(pulse) * 0.5);
          p.mesh.material.opacity = 0.7 + pulse * 0.3;
          if (p.glow) {
            p.glow.position.copy(p.mesh.position);
            p.glow.scale.setScalar(p.mesh.scale.x * 2);
            p.glow.material.opacity = 0.2 + pulse * 0.15;
          }
          return;
        }
        
        // ===== STAGE 5c: AC DOWN FROM INVERTER =====
        else if (p.stage === 'ac-down') {
          p.mesh.position.y -= p.speed;
          p.mesh.position.x = p.baseX + Math.sin(time * 5 + p.phase) * 0.08;
          p.mesh.position.z = p.baseZ + Math.sin(time * 4 + p.phase) * 0.08;
          
          // Make it brighter
          const pulse = Math.sin(time * 8 + p.phase);
          p.mesh.scale.setScalar(1.0 + pulse * 0.3);
          p.mesh.material.opacity = 0.8 + pulse * 0.2;
          if (p.glow) {
            p.glow.position.copy(p.mesh.position);
            p.glow.scale.setScalar(1.8 + pulse * 0.4);
            p.glow.material.opacity = 0.35 + pulse * 0.15;
          }
          
          // Reset when reaching bottom
          if (p.mesh.position.y < p.endY) {
            p.mesh.position.y = p.startY;
          }
        }
        
        // ===== STAGE 6: AC TO GRID (horizontal to substation) =====
        else if (p.stage === 'ac-to-grid') {
          p.mesh.position.x += p.speed;
          p.mesh.position.y = p.baseY + Math.sin(time * 4 + p.phase) * 0.1;
          p.mesh.position.z = p.baseZ + Math.sin(time * 3 + p.phase) * 0.12;
          
          // Bright pulsing effect
          const pulse = Math.sin(time * 6 + p.phase);
          p.mesh.scale.setScalar(1.1 + pulse * 0.3);
          p.mesh.material.opacity = 0.9 + pulse * 0.1;
          if (p.glow) {
            p.glow.position.copy(p.mesh.position);
            p.glow.scale.setScalar(2.0 + pulse * 0.5);
            p.glow.material.opacity = 0.4 + pulse * 0.2;
          }
          
          if (p.mesh.position.x < p.endX) {
            p.mesh.position.x = p.startX;
          }
        }
        
        // Update glow position for moving particles
        if (p.glow) {
          p.glow.position.copy(p.mesh.position);
        }
        
        // Skip general pulse effects for stages that have custom effects
        if (p.stage === 'ac-down' || p.stage === 'ac-to-grid' || p.stage === 'module-dc') {
          return;
        }
        
        // Pulse opacity and scale for DC moving particles only
        const pulse = Math.sin(time * 6 + p.phase);
        p.mesh.material.opacity = 0.7 + pulse * 0.3;
        if (p.glow) {
          p.glow.material.opacity = 0.15 + pulse * 0.1;
        }
        
        const scale = 0.85 + pulse * 0.15;
        p.mesh.scale.setScalar(scale);
        if (p.glow) {
          p.glow.scale.setScalar(scale * 1.8);
        }
      });
    }
    
    function toggleDayCycle() {
      isDayCycleActive = !isDayCycleActive;
      const btn = document.getElementById('dayCycleBtn');
      if (isDayCycleActive) {
        btn.classList.add('active');
        btn.innerHTML = '☀️ Sun Tracking: ON';
      } else {
        btn.classList.remove('active');
        btn.innerHTML = '🌅 Sun Tracking';
        // Reset to default position
        sunAngle = 0.25;
        if (sunMesh) sunMesh.position.set(100, 200, 80);
        if (sunLight) {
          sunLight.position.set(100, 200, 80);
          sunLight.color.setHex(0xffffff);
          sunLight.intensity = 1.0;
        }
        trackerRows.forEach(tracker => {
          if (tracker.userData.panelTable) {
            tracker.userData.panelTable.rotation.x = tracker.userData.baseTilt || 0.15;
          }
        });
      }
    }
    
    function toggleElectricityFlow() {
      isElectricityFlowActive = !isElectricityFlowActive;
      const btn = document.getElementById('electricFlowBtn');
      const legend = document.getElementById('powerFlowLegend');
      
      if (isElectricityFlowActive) {
        btn.classList.add('active');
        btn.innerHTML = '⚡ Power Flow: ON';
        createElectricityParticles();
        
        // Show legend
        if (legend) legend.style.display = 'block';
        
        // Move camera BEHIND the row, zoomed out to see everything
        // Looking from behind (higher z) down at the row at z=117
        animateCameraTo(70, 70, 320, 70, 5, 50);
        targetX = 70;
        targetY = 5;
        targetZ = 50;
      } else {
        btn.classList.remove('active');
        btn.innerHTML = '⚡ Power Flow';
        
        // Hide legend
        if (legend) legend.style.display = 'none';
        
        // Remove particles and glows
        electricityParticles.forEach(p => {
          scene.remove(p.mesh);
          if (p.glow) scene.remove(p.glow);
        });
        electricityParticles = [];
      }
    }
    
    // Tooltip control functions
    function closeSunTooltip() {
      document.getElementById('sunTooltip').classList.remove('show');
    }
    
    function closePowerTooltip() {
      document.getElementById('powerTooltip').classList.remove('show');
    }
    
    function startSunTracking() {
      closeSunTooltip();
      if (!isDayCycleActive) {
        toggleDayCycle();
      }
    }
    
    function startPowerFlow() {
      closePowerTooltip();
      if (!isElectricityFlowActive) {
        toggleElectricityFlow();
      }
    }
    
    // Panel Style functions
    function closePanelStyleTooltip() {
      document.getElementById('panelStyleTooltip').classList.remove('show');
    }
    
    function changePanelStyle(style) {
      if (currentPanelStyle === style) {
        closePanelStyleTooltip();
        return;
      }
      
      currentPanelStyle = style;
      
      // Update button states
      document.querySelectorAll('.panel-style-option').forEach(btn => {
        btn.classList.remove('active');
        if (btn.dataset.style === style) {
          btn.classList.add('active');
        }
      });
      
      // Show loading indicator
      const loadingDiv = document.createElement('div');
      loadingDiv.id = 'rebuildLoading';
      loadingDiv.style.cssText = 'position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); background:rgba(10,22,40,0.95); padding:20px 40px; border-radius:12px; border:2px solid #ff1493; z-index:10001; color:#fff; font-weight:600; font-size:16px;';
      loadingDiv.innerHTML = '🔄 Switching to ' + style + '...';
      document.body.appendChild(loadingDiv);
      
      closePanelStyleTooltip();
      
      // Rebuild after short delay
      setTimeout(() => {
        rebuildSolarFarm();
        document.body.removeChild(loadingDiv);
      }, 100);
    }
    
    function rebuildSolarFarm() {
      // Remove existing tracker rows from scene
      trackerRows.forEach(tracker => {
        scene.remove(tracker);
        // Dispose of geometries and materials
        tracker.traverse(child => {
          if (child.geometry) child.geometry.dispose();
        });
      });
      
      // Clear all tracking arrays
      trackerRows = [];
      junctionBoxes = [];
      redCables = [];
      bearingPlates = [];
      combinerBoxes = [];
      inverterBoxes = [];
      
      // Rebuild tracker rows with new panel style
      createAllTrackerRows();
      
      // Re-apply current step highlight
      highlightComponent(currentStep);
    }
    
    // Close tooltips when clicking elsewhere
    document.addEventListener('click', (e) => {
      if (!e.target.closest('#dayCycleBtn') && !e.target.closest('#sunTooltip')) {
        closeSunTooltip();
      }
      if (!e.target.closest('#electricFlowBtn') && !e.target.closest('#powerTooltip')) {
        closePowerTooltip();
      }
      if (!e.target.closest('#panelStyleBtn') && !e.target.closest('#panelStyleTooltip')) {
        closePanelStyleTooltip();
      }
    });

    function setupListeners() {
      document.querySelectorAll('.step').forEach(s => s.addEventListener('click', () => navigate(s.dataset.step)));
      
      document.getElementById('prev').addEventListener('click', () => {
        const steps = ['module', 'string', 'tracker', 'combiner', 'cabling', 'inverter'];
        const i = steps.indexOf(currentStep);
        if (i > 0) navigate(steps[i - 1]);
      });
      
      document.getElementById('next').addEventListener('click', () => {
        const steps = ['module', 'string', 'tracker', 'combiner', 'cabling', 'inverter'];
        const i = steps.indexOf(currentStep);
        if (i < steps.length - 1) navigate(steps[i + 1]);
      });
      
      document.getElementById('topview').addEventListener('click', () => {
        isTopView = !isTopView;
        const btn = document.getElementById('topview');
        if (isTopView) {
          btn.classList.add('active');
          btn.textContent = 'Exit Top View';
          animateCameraTo(topViewCam.x, topViewCam.y, topViewCam.z, 0, 0, 0);
          // Hide highlights in top view
          if (highlightGroup) highlightGroup.children.forEach(g => g.visible = false);
        } else {
          btn.classList.remove('active');
          btn.textContent = 'Top View';
          animateCameraTo(defaultCam.x, defaultCam.y, defaultCam.z, 0, 10, 0);
          // Restore highlight for current step
          highlightComponent(currentStep);
        }
      });
      
      document.getElementById('reset').addEventListener('click', () => {
        isTopView = false;
        document.getElementById('topview').classList.remove('active');
        document.getElementById('topview').textContent = 'Top View';
        targetX = 0; targetY = 10; targetZ = 0;
        animateCameraTo(defaultCam.x, defaultCam.y, defaultCam.z, 0, 10, 0);
        // Restore highlight for current step
        highlightComponent(currentStep);
      });
      
      // Day cycle / sun tracking button - show tooltip first
      document.getElementById('dayCycleBtn').addEventListener('click', () => {
        if (isDayCycleActive) {
          toggleDayCycle(); // If active, just toggle off
        } else {
          // Show tooltip
          document.getElementById('sunTooltip').classList.add('show');
          document.getElementById('powerTooltip').classList.remove('show');
          document.getElementById('panelStyleTooltip').classList.remove('show');
        }
      });
      
      // Electricity flow button - show tooltip first
      document.getElementById('electricFlowBtn').addEventListener('click', () => {
        if (isElectricityFlowActive) {
          toggleElectricityFlow(); // If active, just toggle off
        } else {
          // Show tooltip
          document.getElementById('powerTooltip').classList.add('show');
          document.getElementById('sunTooltip').classList.remove('show');
          document.getElementById('panelStyleTooltip').classList.remove('show');
        }
      });
      
      // Panel style button - show tooltip
      document.getElementById('panelStyleBtn').addEventListener('click', () => {
        document.getElementById('panelStyleTooltip').classList.add('show');
        document.getElementById('sunTooltip').classList.remove('show');
        document.getElementById('powerTooltip').classList.remove('show');
      });
      
      // FREE CAMERA CONTROLS - SHARP & RESPONSIVE
      let isDragging = false;
      let isRightDrag = false;
      let lastX = 0, lastY = 0;
      
      renderer.domElement.addEventListener('mousedown', e => {
        isDragging = true;
        isRightDrag = e.button === 2;
        lastX = e.clientX;
        lastY = e.clientY;
      });
      
      renderer.domElement.addEventListener('contextmenu', e => e.preventDefault());
      
      renderer.domElement.addEventListener('mousemove', e => {
        if (!isDragging) return;
        
        const dx = e.clientX - lastX;
        const dy = e.clientY - lastY;
        lastX = e.clientX;
        lastY = e.clientY;
        
        if (isRightDrag) {
          // PAN - move the target point
          const panSpeed = 0.5;
          const right = new THREE.Vector3();
          const up = new THREE.Vector3(0, 1, 0);
          camera.getWorldDirection(right);
          right.crossVectors(up, right).normalize();
          
          targetX -= right.x * dx * panSpeed;
          targetZ -= right.z * dx * panSpeed;
          targetY += dy * panSpeed * 0.5;
          targetY = Math.max(0, Math.min(50, targetY));
          
          camera.position.x -= right.x * dx * panSpeed;
          camera.position.z -= right.z * dx * panSpeed;
          camera.position.y += dy * panSpeed * 0.5;
          camera.position.y = Math.max(0.3, camera.position.y);
          
          camera.lookAt(targetX, targetY, targetZ);
        } else {
          // ORBIT - rotate around target
          const orbitSpeed = 0.01;
          
          const offset = new THREE.Vector3(
            camera.position.x - targetX,
            camera.position.y - targetY,
            camera.position.z - targetZ
          );
          const radius = offset.length();
          let theta = Math.atan2(offset.x, offset.z);
          let phi = Math.acos(Math.max(-1, Math.min(1, offset.y / radius)));
          
          theta -= dx * orbitSpeed;
          phi -= dy * orbitSpeed;
          phi = Math.max(0.05, Math.min(Math.PI * 0.85, phi));
          
          let newY = targetY + radius * Math.cos(phi);
          if (newY < 0.3) newY = 0.3;
          
          camera.position.x = targetX + radius * Math.sin(phi) * Math.sin(theta);
          camera.position.y = newY;
          camera.position.z = targetZ + radius * Math.sin(phi) * Math.cos(theta);
          
          camera.lookAt(targetX, targetY, targetZ);
        }
      });
      
      renderer.domElement.addEventListener('mouseup', () => { isDragging = false; isRightDrag = false; });
      renderer.domElement.addEventListener('mouseleave', () => { isDragging = false; isRightDrag = false; });
      
      // ZOOM - direct scroll zoom
      renderer.domElement.addEventListener('wheel', e => {
        e.preventDefault();
        
        const zoomSpeed = 0.12;
        const dir = e.deltaY > 0 ? 1 : -1;
        
        const offset = new THREE.Vector3(
          camera.position.x - targetX,
          camera.position.y - targetY,
          camera.position.z - targetZ
        );
        const currentDist = offset.length();
        const newDist = Math.max(0.5, Math.min(600, currentDist * (1 + dir * zoomSpeed)));
        
        offset.normalize().multiplyScalar(newDist);
        let newY = targetY + offset.y;
        if (newY < 0.3) newY = 0.3;
        
        camera.position.set(targetX + offset.x, newY, targetZ + offset.z);
        camera.lookAt(targetX, targetY, targetZ);
      }, { passive: false });
      
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    }

    function navigate(step) {
      if (isTopView) {
        isTopView = false;
        document.getElementById('topview').classList.remove('active');
        document.getElementById('topview').textContent = 'Top View';
      }
      
      // Show left panel if hidden
      if (!leftPanelVisible) {
        leftPanelVisible = true;
        document.getElementById('left-panel').classList.remove('hidden');
        document.getElementById('panelShowBtn').style.display = 'none';
        document.getElementById('panelHideIcon').textContent = '◀';
      }
      
      // ALWAYS hide labels when navigating through steps (cleaner learning view)
      // Labels can be distracting when learning about specific components
      markersVisible = false;
      labelElements.forEach(item => {
        item.label.style.display = 'none';
      });
      const toggleBtn = document.getElementById('toggle-markers');
      if (toggleBtn) {
        toggleBtn.innerHTML = '🏷️ Show Labels';
        toggleBtn.style.background = 'linear-gradient(135deg, rgba(56,189,248,0.9), rgba(20,100,150,0.9))';
        toggleBtn.style.borderColor = '#38bdf8';
        toggleBtn.style.boxShadow = '0 4px 15px rgba(0,0,0,0.4), 0 0 20px rgba(56,189,248,0.3)';
      }
      
      document.querySelectorAll('.step').forEach(s => s.classList.remove('active'));
      document.querySelector(`[data-step="${step}"]`).classList.add('active');
      currentStep = step;
      updateContent();
      
      // Hide demo objects when navigating (only show via close-up buttons)
      if (demoTrackerGroup) {
        demoTrackerGroup.visible = false;
      }
      if (demoCombinerGroup) {
        demoCombinerGroup.visible = false;
      }
      
      // Show junction boxes only on String step and only for that specific row
      const stringRowZ = -45; // The row shown in String step
      junctionBoxes.forEach(item => {
        if (step === 'string' && Math.abs(item.rowZ - stringRowZ) < 1) {
          item.mesh.visible = true;
        } else {
          item.mesh.visible = false;
        }
      });
      
      // Show red cables only on String step and only for that specific row
      redCables.forEach(item => {
        if (step === 'string' && Math.abs(item.rowZ - stringRowZ) < 1) {
          item.mesh.visible = true;
        } else {
          item.mesh.visible = false;
        }
      });
      
      // Highlight the component for this step
      highlightComponent(step);
      
      const data = contentData[step];
      const cam = data.cam;
      const look = data.lookAt;
      targetX = look.x; targetY = look.y; targetZ = look.z;
      animateCameraTo(cam.x, cam.y, cam.z, look.x, look.y, look.z);
    }

    function updateContent() {
      const data = contentData[currentStep];
      document.getElementById('title').textContent = data.title;
      document.getElementById('subtitle').textContent = data.subtitle;
      document.getElementById('content').innerHTML = data.content;
      document.getElementById('stats').innerHTML = data.stats;
      
      // Attach event listener for tracker close-up button if present
      const trackerBtn = document.getElementById('viewTrackerBtn');
      if (trackerBtn) {
        trackerBtn.addEventListener('click', () => {
          zoomToTrackerDemo();
        });
      }
      
      // Attach event listener for combiner close-up button if present
      const combinerBtn = document.getElementById('viewCombinerBtn');
      if (combinerBtn) {
        combinerBtn.addEventListener('click', () => {
          zoomToCombinerDemo();
        });
      }
      
      // Attach event listener for cables view button if present
      const cablesBtn = document.getElementById('viewCablesBtn');
      if (cablesBtn) {
        cablesBtn.addEventListener('click', () => {
          zoomToCablesView();
        });
      }
    }
    
    // Demo tracker position
    const demoTrackerPos = { x: 0, y: 5, z: 50 };
    let isViewingTrackerDemo = false;
    
    // Demo combiner position
    const demoCombinerPos = { x: 0, y: 2.5, z: 80 };
    let isViewingCombinerDemo = false;
    
    function zoomToTrackerDemo() {
      isViewingTrackerDemo = true;
      
      // Show Learning Path panel
      showLearningPath();
      
      // Show the demo tracker - add to scene if not already
      if (demoTrackerGroup) {
        if (!demoTrackerGroup.parent) scene.add(demoTrackerGroup);
        demoTrackerGroup.visible = true;
      }
      
      // Hide step highlights when viewing demo
      if (highlightGroup) highlightGroup.children.forEach(g => g.visible = false);
      
      // Animate camera to view both board and bearings from front
      animateCameraTo(
        demoTrackerPos.x - 4, demoTrackerPos.y + 5, demoTrackerPos.z + 22,
        demoTrackerPos.x - 3, demoTrackerPos.y + 2, demoTrackerPos.z + 3
      );
      
      // Update the stats area with return button
      document.getElementById('stats').innerHTML = `
        <div class="stat-card" style="background: linear-gradient(135deg, #ff6600, #ff8833);">
          <div class="stat-value" style="font-size: 14px;">🔍 TRACKER CLOSE-UP VIEW</div>
          <div class="stat-label">Viewing demo tracker with Nextracker & Array styles</div>
        </div>
        <button id="returnFromDemo" style="margin-top: 10px; background: #0a3a4a; color: #4aa; border: 2px solid #4aa; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-weight: bold;">
          ← RETURN TO LESSON
        </button>
      `;
      
      // Add return button listener
      document.getElementById('returnFromDemo').addEventListener('click', () => {
        isViewingTrackerDemo = false;
        if (demoTrackerGroup) {
          demoTrackerGroup.visible = false;
          if (demoTrackerGroup.parent) scene.remove(demoTrackerGroup); // Remove from scene
        }
        navigate('tracker');
      });
    }
    
    function zoomToCombinerDemo() {
      isViewingCombinerDemo = true;
      
      // Show Learning Path panel
      showLearningPath();
      
      // Show the demo combiner - add to scene if not already
      if (demoCombinerGroup) {
        if (!demoCombinerGroup.parent) scene.add(demoCombinerGroup);
        demoCombinerGroup.visible = true;
      }
      
      // Reset door to open state
      combinerDoorOpen = true;
      if (combinerDoorGroup) {
        combinerDoorGroup.rotation.y = Math.PI * 0.55; // Open (clockwise)
      }
      
      // Hide step highlights when viewing demo
      if (highlightGroup) highlightGroup.children.forEach(g => g.visible = false);
      
      // Animate camera to view combiner on left and board on right
      animateCameraTo(
        demoCombinerPos.x + 1, demoCombinerPos.y + 4, demoCombinerPos.z + 18,
        demoCombinerPos.x + 1, demoCombinerPos.y + 2, demoCombinerPos.z + 2
      );
      
      // Update the stats area with buttons
      document.getElementById('stats').innerHTML = `
        <div class="stat-card" style="background: linear-gradient(135deg, #00aa66, #00cc88);">
          <div class="stat-value" style="font-size: 14px;">🔍 COMBINER BOX - <span id="doorStateText">DOOR OPEN</span></div>
          <div class="stat-label">View internal components: String Inputs (Red/Blue), Fuses, SPD, Bus Bars</div>
        </div>
        <div style="display: flex; gap: 10px; margin-top: 10px; flex-wrap: wrap;">
          <button id="toggleDoorBtn" style="background: linear-gradient(135deg, #00aa66, #00cc88); color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-weight: bold;">
            🚪 CLOSE DOOR
          </button>
          <button id="returnFromCombiner" style="background: #0a3a4a; color: #4aa; border: 2px solid #4aa; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-weight: bold;">
            ← RETURN TO LESSON
          </button>
        </div>
      `;
      
      // Add toggle door button listener
      document.getElementById('toggleDoorBtn').addEventListener('click', toggleCombinerDoor);
      
      // Add return button listener
      document.getElementById('returnFromCombiner').addEventListener('click', () => {
        isViewingCombinerDemo = false;
        if (demoCombinerGroup) {
          demoCombinerGroup.visible = false;
          if (demoCombinerGroup.parent) scene.remove(demoCombinerGroup); // Remove from scene
        }
        navigate('combiner');
      });
    }
    
    function toggleCombinerDoor() {
      if (!combinerDoorGroup) return;
      
      combinerDoorOpen = !combinerDoorOpen;
      
      // Animate door - proper swing from hinge (clockwise)
      const targetRotation = combinerDoorOpen ? Math.PI * 0.55 : 0; // Open (swung right/clockwise) or closed
      const startRotation = combinerDoorGroup.rotation.y;
      const duration = 600; // ms - slightly longer for realism
      const startTime = Date.now();
      
      function animateDoor() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        // Ease in-out for realistic door swing
        const easeProgress = progress < 0.5 
          ? 2 * progress * progress 
          : 1 - Math.pow(-2 * progress + 2, 2) / 2;
        combinerDoorGroup.rotation.y = startRotation + (targetRotation - startRotation) * easeProgress;
        
        if (progress < 1) {
          requestAnimationFrame(animateDoor);
        }
      }
      animateDoor();
      
      // Update button text and status
      const btn = document.getElementById('toggleDoorBtn');
      const stateText = document.getElementById('doorStateText');
      if (btn) {
        btn.textContent = combinerDoorOpen ? '🚪 CLOSE DOOR' : '🚪 OPEN DOOR';
      }
      if (stateText) {
        stateText.textContent = combinerDoorOpen ? 'DOOR OPEN' : 'DOOR CLOSED';
      }
    }
    
    let isViewingCablesDemo = false;
    
    function zoomToCablesView() {
      isViewingCablesDemo = true;
      
      // Show Learning Path panel
      showLearningPath();
      
      // Make sure cables are visible for this row
      const stringRowZ = -45;
      junctionBoxes.forEach(item => {
        if (Math.abs(item.rowZ - stringRowZ) < 1) {
          item.mesh.visible = true;
        }
      });
      redCables.forEach(item => {
        if (Math.abs(item.rowZ - stringRowZ) < 1) {
          item.mesh.visible = true;
        }
      });
      
      // Hide step highlights when viewing cables
      if (highlightGroup) highlightGroup.children.forEach(g => g.visible = false);
      
      // Animate camera to view DC cables - close to row end, looking along at cable level
      animateCameraTo(
        195, 5, -43,    // Camera position - right end, at torque tube height, at row Z
        60, 5, -45      // Look at - left end, same height
      );
      
      // Update the stats area with return button
      document.getElementById('stats').innerHTML = `
        <div class="stat-card" style="background: linear-gradient(135deg, #cc3333, #ff5555);">
          <div class="stat-value" style="font-size: 14px;">🔌 DC CABLES - BACK OF PANEL</div>
          <div class="stat-label">View: Junction boxes (yellow), DC+ cables (red), DC- cables (blue)</div>
        </div>
        <button id="returnFromCables" style="margin-top: 10px; background: #0a3a4a; color: #4aa; border: 2px solid #4aa; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-weight: bold;">
          ← RETURN TO LESSON
        </button>
      `;
      
      // Add return button listener
      document.getElementById('returnFromCables').addEventListener('click', () => {
        isViewingCablesDemo = false;
        navigate('string');
      });
    }

    function animateCameraTo(tx, ty, tz, lookX, lookY, lookZ) {
      // Ensure target Y is above ground but allow close views
      ty = Math.max(0.3, ty);
      
      const start = { 
        x: camera.position.x, y: camera.position.y, z: camera.position.z,
        lx: targetX, ly: targetY, lz: targetZ
      };
      const duration = 1200, startTime = Date.now();
      
      function update() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        const eased = 1 - Math.pow(1 - progress, 3);
        
        camera.position.x = start.x + (tx - start.x) * eased;
        camera.position.y = Math.max(0.3, start.y + (ty - start.y) * eased);
        camera.position.z = start.z + (tz - start.z) * eased;
        
        targetX = start.lx + (lookX - start.lx) * eased;
        targetY = start.ly + (lookY - start.ly) * eased;
        targetZ = start.lz + (lookZ - start.lz) * eased;
        
        camera.lookAt(targetX, targetY, targetZ);
        
        if (progress < 1) requestAnimationFrame(update);
      }
      update();
    }

    // ===== QUIZ SYSTEM =====
    const quizQuestions = [
      {
        question: "What is the basic building block of a solar farm?",
        options: [
          "String Inverter",
          "Solar Panel Module",
          "Combiner Box",
          "Torque Tube"
        ],
        correct: 1,
        explanation: "The solar panel module (also called a photovoltaic module) is the basic building block. Multiple modules connect together to form strings and arrays."
      },
      {
        question: "What type of solar cells are typically used in utility-scale solar farms?",
        options: [
          "Thin-film cells",
          "Organic cells",
          "Monocrystalline silicon cells",
          "Dye-sensitized cells"
        ],
        correct: 2,
        explanation: "Monocrystalline silicon cells are preferred for utility-scale projects due to their high efficiency (20-22%) and long-term reliability."
      },
      {
        question: "What connector type is used to link solar panels together in a string?",
        options: [
          "USB-C connectors",
          "Anderson connectors",
          "MC4 connectors",
          "RJ45 connectors"
        ],
        correct: 2,
        explanation: "MC4 connectors are the industry standard for connecting solar panels. They provide weatherproof, secure connections that can handle high DC voltages."
      },
      {
        question: "What is the main purpose of a single-axis solar tracker?",
        options: [
          "To protect panels from wind",
          "To follow the sun's path and increase energy production",
          "To cool the panels down",
          "To store excess energy"
        ],
        correct: 1,
        explanation: "Single-axis trackers follow the sun from east to west throughout the day, increasing energy production by up to 25% compared to fixed-tilt systems."
      },
      {
        question: "Which company's tracker bearing features a distinctive half-circle (D-shaped) plate?",
        options: [
          "Nextracker",
          "SunPower",
          "Array Technologies",
          "First Solar"
        ],
        correct: 2,
        explanation: "Array Technologies' DuraTrack system features a distinctive semi-circular plate design with the company name embossed vertically."
      },
      {
        question: "What is the primary function of a combiner box in a solar farm?",
        options: [
          "Convert DC to AC power",
          "Store energy in batteries",
          "Combine multiple string outputs and provide protection",
          "Track the sun's position"
        ],
        correct: 2,
        explanation: "Combiner boxes bundle multiple solar panel strings into a single output while providing crucial protection through fuses and surge protection devices (SPDs)."
      },
      {
        question: "What color is typically used for DC positive cables in solar installations?",
        options: [
          "Blue",
          "Green",
          "Black",
          "Red"
        ],
        correct: 3,
        explanation: "Red is the standard color for DC positive (+) cables, while blue or black is used for DC negative (-) cables. Green/yellow is reserved for grounding."
      },
      {
        question: "What does a string inverter do?",
        options: [
          "Combines multiple strings together",
          "Converts DC power from panels to AC power for the grid",
          "Tracks the sun's movement",
          "Protects against lightning"
        ],
        correct: 1,
        explanation: "String inverters convert the DC (Direct Current) electricity generated by solar panels into AC (Alternating Current) electricity that can be fed into the power grid."
      },
      {
        question: "What type of foundation is commonly used for tracker posts in solar farms?",
        options: [
          "Concrete footings",
          "Helical piles",
          "Driven piles (W-beam posts)",
          "Floating foundations"
        ],
        correct: 2,
        explanation: "Driven pile foundations using W-beam (wide flange) steel posts are common in utility-scale solar farms. They're quick to install and work well in most soil conditions."
      },
      {
        question: "Approximately how much more energy can a tracking system produce compared to a fixed-tilt system?",
        options: [
          "5-10% more",
          "25% more",
          "50% more",
          "100% more"
        ],
        correct: 1,
        explanation: "Single-axis trackers typically produce about 25% more energy than fixed-tilt systems by keeping panels optimally oriented toward the sun throughout the day."
      }
    ];
    
    let currentQuestion = 0;
    let score = 0;
    let selectedAnswer = null;
    let answered = false;
    
    function initQuiz() {
      const quizBtn = document.getElementById('quizBtn');
      const quizModal = document.getElementById('quizModal');
      const quizClose = document.getElementById('quizClose');
      const quizNext = document.getElementById('quizNext');
      
      quizBtn.addEventListener('click', () => {
        currentQuestion = 0;
        score = 0;
        selectedAnswer = null;
        answered = false;
        quizModal.classList.add('active');
        showQuestion();
      });
      
      quizClose.addEventListener('click', () => {
        quizModal.classList.remove('active');
      });
      
      quizNext.addEventListener('click', () => {
        if (!answered) return;
        
        currentQuestion++;
        if (currentQuestion >= quizQuestions.length) {
          showResults();
        } else {
          selectedAnswer = null;
          answered = false;
          showQuestion();
        }
      });
    }
    
    function showQuestion() {
      const q = quizQuestions[currentQuestion];
      const content = document.getElementById('quizContent');
      const progressBar = document.getElementById('quizProgressBar');
      const scoreDisplay = document.getElementById('quizScore');
      const nextBtn = document.getElementById('quizNext');
      
      progressBar.style.width = ((currentQuestion + 1) / quizQuestions.length * 100) + '%';
      scoreDisplay.textContent = `Question ${currentQuestion + 1} of ${quizQuestions.length}`;
      nextBtn.disabled = true;
      nextBtn.textContent = 'Select an answer';
      
      const letters = ['A', 'B', 'C', 'D'];
      let optionsHTML = q.options.map((opt, i) => `
        <button class="quiz-option" data-index="${i}">
          <span class="option-letter">${letters[i]}</span>
          <span>${opt}</span>
        </button>
      `).join('');
      
      content.innerHTML = `
        <div class="quiz-question">
          <span>Question ${currentQuestion + 1}</span>
          ${q.question}
        </div>
        <div class="quiz-options">
          ${optionsHTML}
        </div>
        <div class="quiz-feedback" id="quizFeedback"></div>
      `;
      
      // Add click handlers to options
      document.querySelectorAll('.quiz-option').forEach(opt => {
        opt.addEventListener('click', () => selectAnswer(parseInt(opt.dataset.index)));
      });
    }
    
    function selectAnswer(index) {
      if (answered) return;
      
      selectedAnswer = index;
      answered = true;
      
      const q = quizQuestions[currentQuestion];
      const options = document.querySelectorAll('.quiz-option');
      const feedback = document.getElementById('quizFeedback');
      const nextBtn = document.getElementById('quizNext');
      
      options.forEach((opt, i) => {
        opt.style.pointerEvents = 'none';
        if (i === q.correct) {
          opt.classList.add('correct');
        } else if (i === index && i !== q.correct) {
          opt.classList.add('incorrect');
        }
      });
      
      if (index === q.correct) {
        score++;
        feedback.className = 'quiz-feedback correct';
        feedback.innerHTML = `✓ Correct! ${q.explanation}`;
      } else {
        feedback.className = 'quiz-feedback incorrect';
        feedback.innerHTML = `✗ Incorrect. ${q.explanation}`;
      }
      
      nextBtn.disabled = false;
      nextBtn.textContent = currentQuestion < quizQuestions.length - 1 ? 'Next Question →' : 'See Results →';
    }
    
    function showResults() {
      const content = document.getElementById('quizContent');
      const progressBar = document.getElementById('quizProgressBar');
      const scoreDisplay = document.getElementById('quizScore');
      const nextBtn = document.getElementById('quizNext');
      
      progressBar.style.width = '100%';
      scoreDisplay.textContent = 'Quiz Complete!';
      
      const percentage = Math.round((score / quizQuestions.length) * 100);
      let grade, gradeClass, message;
      
      if (percentage >= 90) {
        grade = '🏆 Excellent!';
        gradeClass = 'excellent';
        message = "Outstanding! You're a solar farm expert!";
      } else if (percentage >= 70) {
        grade = '⭐ Good Job!';
        gradeClass = 'good';
        message = "Great work! You have a solid understanding.";
      } else if (percentage >= 50) {
        grade = '📚 Keep Learning';
        gradeClass = 'okay';
        message = "You're getting there! Review the material and try again.";
      } else {
        grade = '🔄 Try Again';
        gradeClass = 'needs-work';
        message = "Don't give up! Go through the lessons and retake the quiz.";
      }
      
      content.innerHTML = `
        <div class="quiz-results">
          <div class="grade ${gradeClass}">${grade}</div>
          <div class="score-big">${score}/${quizQuestions.length}</div>
          <div class="score-text">${percentage}% - ${message}</div>
          <p style="color: #64748b; margin-top: 20px;">
            You answered ${score} out of ${quizQuestions.length} questions correctly.
          </p>
        </div>
      `;
      
      nextBtn.textContent = '🔄 Retake Quiz';
      nextBtn.disabled = false;
      nextBtn.onclick = () => {
        currentQuestion = 0;
        score = 0;
        selectedAnswer = null;
        answered = false;
        nextBtn.onclick = null;
        document.getElementById('quizNext').addEventListener('click', () => {
          if (!answered) return;
          currentQuestion++;
          if (currentQuestion >= quizQuestions.length) {
            showResults();
          } else {
            selectedAnswer = null;
            answered = false;
            showQuestion();
          }
        });
        showQuestion();
      };
    }
    
    // ===== SITE BUILDER LOGIC =====
    // ===== SITE BUILDER STATE =====
    const validSites = [
      // ═══ BIFACIAL 600W — 8 Valid Configurations (28 mods/string) ═══
      { module:"bifacial-600", inverter:"distributed", dcCollection:"string-homeruns", dcCombo:"none" },           // Bifacial 1
      { module:"bifacial-600", inverter:"centralized-cluster", dcCollection:"string-homeruns", dcCombo:"combiner-boxes" }, // Bifacial 2
      { module:"bifacial-600", inverter:"central", dcCollection:"string-homeruns", dcCombo:"combiner-boxes" },     // Bifacial 3
      { module:"bifacial-600", inverter:"distributed", dcCollection:"harnesses", dcCombo:"none" },                 // Bifacial 4
      { module:"bifacial-600", inverter:"centralized-cluster", dcCollection:"harnesses", dcCombo:"combiner-boxes" },       // Bifacial 5
      { module:"bifacial-600", inverter:"central", dcCollection:"harnesses", dcCombo:"combiner-boxes" },           // Bifacial 6
      { module:"bifacial-600", inverter:"centralized-cluster", dcCollection:"trunk-bus", dcCombo:"lbds" },         // Bifacial 7
      { module:"bifacial-600", inverter:"central", dcCollection:"trunk-bus", dcCombo:"lbds" },                     // Bifacial 8
      // ═══ FIRST SOLAR 525W — 5 Valid Configurations (6 mods/string) ═══
      { module:"first-solar-525", inverter:"distributed", dcCollection:"harnesses", dcCombo:"none" },              // First Solar 1
      { module:"first-solar-525", inverter:"centralized-cluster", dcCollection:"harnesses", dcCombo:"combiner-boxes" },    // First Solar 2
      { module:"first-solar-525", inverter:"central", dcCollection:"harnesses", dcCombo:"combiner-boxes" },        // First Solar 3
      { module:"first-solar-525", inverter:"centralized-cluster", dcCollection:"trunk-bus", dcCombo:"lbds" },      // First Solar 4
      { module:"first-solar-525", inverter:"central", dcCollection:"trunk-bus", dcCombo:"lbds" }                   // First Solar 5
    ];

    const sbState = { module:null, inverter:null, dcCollection:null, dcCombo:null };

    const siteLabels = {
      'bifacial-600':{title:'Bifacial 600W',sub:'28 mods/string'},
      'first-solar-525':{title:'First Solar 525W',sub:'6 mods/string'},
      'distributed':{title:'Distributed String Inverters',sub:'Inverters located at the array'},
      'centralized-cluster':{title:'Centralized String Inverter Clusters',sub:'Inverters grouped in clusters'},
      'central':{title:'Central Inverters',sub:'Central inverter stations'},
      'string-homeruns':{title:'String Homeruns',sub:'Individual string wiring'},
      'harnesses':{title:'Harnesses',sub:'Pre-assembled harness cabling'},
      'trunk-bus':{title:'Trunk Bus',sub:'Trunk cable with drop lines'},
      'combiner-boxes':{title:'Combiner Boxes',sub:'Combine string outputs'},
      'lbds':{title:"LBD's",sub:'Load break disconnects'},
      'none':{title:'None',sub:'No DC combination gear'}
    };

    function openSiteBuilder() { resetSiteBuilder(); document.getElementById('siteBuilderModal').classList.add('active'); }

    // Site Generator dropdown menu
    function toggleSiteGenMenu() {
      const menu = document.getElementById('site-gen-menu');
      menu.style.display = menu.style.display === 'none' ? 'block' : 'none';
    }
    document.addEventListener('click', function(e) {
      const wrapper = document.getElementById('site-gen-wrapper');
      if (wrapper && !wrapper.contains(e.target)) {
        document.getElementById('site-gen-menu').style.display = 'none';
      }
    });

    function closeSiteBuilder() { document.getElementById('siteBuilderModal').classList.remove('active'); }

    function resetSiteBuilder() {
      sbState.module=null; sbState.inverter=null; sbState.dcCollection=null; sbState.dcCombo=null;
      document.querySelectorAll('.sb-opt').forEach(b => { b.classList.remove('sb-selected'); });
      document.getElementById('sbViewBtn').classList.remove('visible');
      sbUpdateUI();
    }

    function sbSelect(field, value, btn) {
      if (btn.classList.contains('sb-disabled')) return;
      if (sbState[field] === value) {
        sbState[field] = null;
      } else {
        sbState[field] = value;
      }
      sbUpdateUI();
    }

    function sbUpdateUI() {
      const fields = ['module','inverter','dcCollection','dcCombo'];
      // Helper: does a config field match? Handles "*" wildcard for module
      function fm(siteVal, stateVal) { return !stateVal || siteVal === '*' || siteVal === stateVal; }

      fields.forEach(field => {
        const container = document.querySelector('.sb-opts[data-field="'+field+'"]');
        if (!container) return;
        container.querySelectorAll('.sb-opt').forEach(btn => {
          const val = btn.dataset.value;
          const testState = { ...sbState };
          testState[field] = val;
          const isValid = validSites.some(site =>
            fm(site.module, testState.module) &&
            fm(site.inverter, testState.inverter) &&
            fm(site.dcCollection, testState.dcCollection) &&
            fm(site.dcCombo, testState.dcCombo)
          );
          btn.classList.toggle('sb-disabled', !isValid);
          btn.classList.toggle('sb-selected', sbState[field] === val);
        });
      });

      const count = fields.filter(f => sbState[f] !== null).length;
      const allSelected = count === 4;
      const isValidConfig = allSelected && validSites.some(s =>
        fm(s.module, sbState.module) && s.inverter===sbState.inverter &&
        s.dcCollection===sbState.dcCollection && s.dcCombo===sbState.dcCombo
      );

      document.getElementById('sbViewBtn').classList.toggle('visible', isValidConfig);
      const info = document.getElementById('sbFooterInfo');
      if (isValidConfig) {
        const moduleMax = sbState.module === 'bifacial-600' ? 8 : 5;
        info.textContent = '✅ Valid configuration — Site ' + getConfigNumber() + ' of ' + moduleMax;
        info.style.color = '#34d399';
      } else if (allSelected) {
        info.textContent = '❌ Invalid combination — adjust your selections';
        info.style.color = '#f87171';
      } else {
        info.textContent = count + ' of 4 selected';
        info.style.color = '#94a3b8';
      }

      // === Update Flow Bar ===
      const flowMap = {
        module:       { node:'sbFlowModule',   val:'sbFlowModuleVal' },
        inverter:     { node:'sbFlowInverter', val:'sbFlowInverterVal' },
        dcCollection: { node:'sbFlowDC',       val:'sbFlowDCVal' },
        dcCombo:      { node:'sbFlowCombo',    val:'sbFlowComboVal' }
      };
      const arrows = ['sbFlowArrow1','sbFlowArrow2','sbFlowArrow3'];
      let prevFilled = true;
      fields.forEach((field, i) => {
        const el = document.getElementById(flowMap[field].node);
        const valEl = document.getElementById(flowMap[field].val);
        if (!el || !valEl) return;
        const isFilled = sbState[field] !== null;
        el.classList.toggle('filled', isFilled);
        el.classList.toggle('active-node', !isFilled && prevFilled);
        valEl.textContent = isFilled ? (siteLabels[sbState[field]]?.title || sbState[field]) : '—';
        if (i > 0) {
          const arrow = document.getElementById(arrows[i - 1]);
          if (arrow) arrow.classList.toggle('lit', isFilled);
        }
        prevFilled = isFilled;
      });
    }

    function getConfigNumber() {
      // Get configs for the selected module only
      const moduleConfigs = validSites.filter(s => s.module === sbState.module);
      const idx = moduleConfigs.findIndex(s =>
        s.inverter===sbState.inverter &&
        s.dcCollection===sbState.dcCollection &&
        s.dcCombo===sbState.dcCombo
      );
      return idx >= 0 ? idx + 1 : '?';
    }

    // ===== FULLSCREEN 3D SITE VIEWER =====
    let svScene, svCam, svRenderer, svAnimId;
    const svOrbit = {th:-0.5,ph:1.0,r:200,tTh:-0.5,tPh:1.0,tR:200,tgt:null,tTgt:null,drag:false,pan:false,lx:0,ly:0,dmp:0.06,autoRotate:false};
    const svKeys = {};
    window.addEventListener('keydown',e=>{svKeys[e.key]=true});
    window.addEventListener('keyup',e=>{svKeys[e.key]=false});

    function closeSiteViewer() {
      if (svAnimId) cancelAnimationFrame(svAnimId); svAnimId = null;
      if (svRenderer) { svRenderer.dispose(); svRenderer = null; }
      if (svScene) { svScene.traverse(o=>{if(o.geometry)o.geometry.dispose();if(o.material){if(Array.isArray(o.material))o.material.forEach(m=>m.dispose());else o.material.dispose()}}); }
      svScene = null; svCam = null;
      const fs = document.getElementById('siteViewerFS');
      const oldCv = fs.querySelector('canvas');
      if (oldCv) oldCv.remove();
      fs.classList.remove('active');
    }

    function svResetView(){svOrbit.tTh=-0.45;svOrbit.tPh=1.2;svOrbit.tR=140;if(svOrbit.tTgt)svOrbit.tTgt.set(0,3,0);}
    function svTopView(){svOrbit.tTh=0;svOrbit.tPh=0.06;svOrbit.tR=200;if(svOrbit.tTgt)svOrbit.tTgt.set(0,0,0);}
    function svToggleAuto(){svOrbit.autoRotate=!svOrbit.autoRotate;document.getElementById('svAutoBtn').classList.toggle('active');}

    function openSiteViewer() {
      closeSiteViewer();
      const fs = document.getElementById('siteViewerFS');
      const configNum = getConfigNumber();
      const lab = {
        module: siteLabels[sbState.module],
        inverter: siteLabels[sbState.inverter],
        dc: siteLabels[sbState.dcCollection],
        comb: siteLabels[sbState.dcCombo]
      };

      const badgeMax = sbState.module === 'bifacial-600' ? 8 : 5;
      document.getElementById('svBadge').textContent = 'Config ' + configNum + ' of ' + badgeMax;
      document.getElementById('svCfgPanel').innerHTML =
        '<div class="sv-cfg-title">SITE CONFIGURATION</div>' +
        '<div class="sv-cfg-row"><span class="sv-cfg-label">Module</span><span class="sv-cfg-val">' + lab.module.title + '</span></div>' +
        '<div class="sv-cfg-row"><span class="sv-cfg-label">Inverter</span><span class="sv-cfg-val">' + lab.inverter.title + '</span></div>' +
        '<div class="sv-cfg-row"><span class="sv-cfg-label">DC Collection</span><span class="sv-cfg-val">' + lab.dc.title + '</span></div>' +
        '<div class="sv-cfg-row"><span class="sv-cfg-label">DC Combination</span><span class="sv-cfg-val">' + lab.comb.title + '</span></div>';

      fs.classList.add('active');
      const cv = document.createElement('canvas');
      cv.id = 'svCanvas';
      fs.insertBefore(cv, fs.firstChild);

      const W = window.innerWidth, H = window.innerHeight;
      const isBi = sbState.module === 'bifacial-600';

      // ═══ SCENE ═══
      svScene = new THREE.Scene();
      svScene.background = new THREE.Color(0x8DBBD8);
      svScene.fog = new THREE.FogExp2(0x8DBBD8, 0.0009);

      svCam = new THREE.PerspectiveCamera(50, W/H, 0.5, 2500);
      svRenderer = new THREE.WebGLRenderer({canvas:cv, antialias:true, stencil:false});
      svRenderer.setSize(W,H);
      svRenderer.setPixelRatio(Math.min(devicePixelRatio,2));
      svRenderer.shadowMap.enabled = true;
      svRenderer.shadowMap.type = THREE.PCFSoftShadowMap;
      svRenderer.toneMapping = THREE.ACESFilmicToneMapping;
      svRenderer.toneMappingExposure = 1.15;
      svRenderer.outputEncoding = THREE.sRGBEncoding;

      // ═══ LIGHTS ═══
      svScene.add(new THREE.AmbientLight(0xd8e8f8, 0.4));
      svScene.add(new THREE.HemisphereLight(0x8DBBD8, 0x6B8040, 0.5));
      const sun = new THREE.DirectionalLight(0xfff3dc, 1.5);
      sun.position.set(90,140,70); sun.castShadow = true;
      sun.shadow.mapSize.set(4096,4096);
      const sc = sun.shadow.camera;
      sc.left=-260;sc.right=260;sc.top=260;sc.bottom=-260;sc.near=1;sc.far=600;
      sun.shadow.bias=-0.0002;sun.shadow.normalBias=0.02;
      svScene.add(sun);
      svScene.add(new THREE.DirectionalLight(0xb0c4de,0.2).translateX(-70).translateY(50).translateZ(-50));

      // ═══ SKY DOME ═══
      const skyG=new THREE.SphereGeometry(900,32,20);
      const skyC=[];const sP=skyG.attributes.position;
      for(let i=0;i<sP.count;i++){const y=sP.getY(i)/900;
        if(y>0.4)skyC.push(0.42,0.62,0.85);
        else if(y>0.1){const t=(y-0.1)/0.3;skyC.push(0.48+0.06*(1-t),0.68+0.04*(1-t),0.84+0.03*(1-t));}
        else if(y>-0.05)skyC.push(0.58,0.74,0.83);
        else skyC.push(0.55,0.7,0.78);}
      skyG.setAttribute('color',new THREE.Float32BufferAttribute(skyC,3));
      svScene.add(new THREE.Mesh(skyG,new THREE.MeshBasicMaterial({vertexColors:true,side:THREE.BackSide})));

      // ═══ CLOUDS ═══
      const clM=new THREE.MeshBasicMaterial({color:0xffffff,transparent:true,opacity:0.3,side:THREE.DoubleSide});
      for(let i=0;i<10;i++){const cl=new THREE.Mesh(new THREE.PlaneGeometry(40+Math.random()*60,8+Math.random()*12),clM);cl.position.set(-250+Math.random()*550,120+Math.random()*40,-250+Math.random()*500);cl.rotation.x=-Math.PI/2;cl.rotation.z=Math.random()*Math.PI;svScene.add(cl);}

      // Build the solar site
      svBuildSite(svScene, sbState.inverter, sbState.dcCollection, sbState.dcCombo, isBi);

      // ═══ CAMERA CONTROLS ═══
      svOrbit.th=-0.45;svOrbit.ph=1.2;svOrbit.r=140;svOrbit.tTh=-0.45;svOrbit.tPh=1.2;svOrbit.tR=140;
      svOrbit.tgt=new THREE.Vector3(0,3,0);svOrbit.tTgt=new THREE.Vector3(0,3,0);
      svOrbit.drag=false;svOrbit.pan=false;svOrbit.autoRotate=false;
      document.getElementById('svAutoBtn').classList.remove('active');

      cv.addEventListener('mousedown',e=>{if(e.button===0)svOrbit.drag=true;if(e.button===2)svOrbit.pan=true;svOrbit.lx=e.clientX;svOrbit.ly=e.clientY});
      cv.addEventListener('mousemove',e=>{const dx=e.clientX-svOrbit.lx,dy=e.clientY-svOrbit.ly;
        if(svOrbit.drag){svOrbit.tTh-=dx*0.004;svOrbit.tPh=Math.max(0.06,Math.min(Math.PI/2.05,svOrbit.tPh-dy*0.004));}
        if(svOrbit.pan){const s=svOrbit.r*0.001;const right=new THREE.Vector3();right.crossVectors(svCam.getWorldDirection(new THREE.Vector3()),new THREE.Vector3(0,1,0)).normalize();svOrbit.tTgt.addScaledVector(right,dx*s);svOrbit.tTgt.y=Math.max(-2,svOrbit.tTgt.y-dy*s*0.4);}
        svOrbit.lx=e.clientX;svOrbit.ly=e.clientY});
      cv.addEventListener('mouseup',()=>{svOrbit.drag=false;svOrbit.pan=false});
      cv.addEventListener('mouseleave',()=>{svOrbit.drag=false;svOrbit.pan=false});
      cv.addEventListener('wheel',e=>{svOrbit.tR=Math.max(10,Math.min(700,svOrbit.tR*(1+e.deltaY*0.0006)));e.preventDefault()},{passive:false});
      cv.addEventListener('contextmenu',e=>e.preventDefault());
      // Touch
      let ltd=0;
      cv.addEventListener('touchstart',e=>{if(e.touches.length===1){svOrbit.drag=true;svOrbit.lx=e.touches[0].clientX;svOrbit.ly=e.touches[0].clientY}else if(e.touches.length===2){svOrbit.drag=false;ltd=Math.hypot(e.touches[0].clientX-e.touches[1].clientX,e.touches[0].clientY-e.touches[1].clientY)}});
      cv.addEventListener('touchmove',e=>{e.preventDefault();if(e.touches.length===1&&svOrbit.drag){const dx=e.touches[0].clientX-svOrbit.lx,dy=e.touches[0].clientY-svOrbit.ly;svOrbit.tTh-=dx*0.003;svOrbit.tPh=Math.max(0.06,Math.min(Math.PI/2.05,svOrbit.tPh-dy*0.003));svOrbit.lx=e.touches[0].clientX;svOrbit.ly=e.touches[0].clientY}else if(e.touches.length===2){const d=Math.hypot(e.touches[0].clientX-e.touches[1].clientX,e.touches[0].clientY-e.touches[1].clientY);svOrbit.tR=Math.max(10,Math.min(700,svOrbit.tR*(1-(d-ltd)*0.004)));ltd=d}},{passive:false});
      cv.addEventListener('touchend',()=>{svOrbit.drag=false});

      window.addEventListener('resize',()=>{if(!svRenderer||!svCam)return;svCam.aspect=innerWidth/innerHeight;svCam.updateProjectionMatrix();svRenderer.setSize(innerWidth,innerHeight)});

      // Hint
      const hint = document.getElementById('svHint');
      if(hint){hint.style.opacity='1';setTimeout(()=>{hint.style.opacity='0';},5000);}

      // ═══ RENDER LOOP — ultra smooth exponential damped camera ═══
      let lastT=performance.now();
      (function tick(){svAnimId=requestAnimationFrame(tick);
        const now=performance.now(),dt=Math.min((now-lastT)/16.67,3);lastT=now;
        const spd=0.5*dt;
        if(svKeys.w||svKeys.ArrowUp)svOrbit.tTgt.z-=spd;
        if(svKeys.s||svKeys.ArrowDown)svOrbit.tTgt.z+=spd;
        if(svKeys.a||svKeys.ArrowLeft)svOrbit.tTgt.x-=spd;
        if(svKeys.d||svKeys.ArrowRight)svOrbit.tTgt.x+=spd;
        if(svOrbit.autoRotate&&!svOrbit.drag)svOrbit.tTh+=0.0015*dt;
        const d=1-Math.exp(-8*dt/60);
        svOrbit.th+=(svOrbit.tTh-svOrbit.th)*d;
        svOrbit.ph+=(svOrbit.tPh-svOrbit.ph)*d;
        svOrbit.r+=(svOrbit.tR-svOrbit.r)*d;
        svOrbit.tgt.lerp(svOrbit.tTgt,d);
        svCam.position.set(
          svOrbit.tgt.x+svOrbit.r*Math.sin(svOrbit.ph)*Math.sin(svOrbit.th),
          svOrbit.tgt.y+svOrbit.r*Math.cos(svOrbit.ph),
          svOrbit.tgt.z+svOrbit.r*Math.sin(svOrbit.ph)*Math.cos(svOrbit.th));
        svCam.lookAt(svOrbit.tgt);
        svRenderer.render(svScene,svCam);
      })();
    }

    // ═══════════════════════════════════════════════════════════════
    //  TEXTURE GENERATORS
    // ═══════════════════════════════════════════════════════════════
    function mkPanelTex(bif){
      // Portrait panel texture (taller than wide to match 1P orientation)
      const W=512,H=1024;
      const c=document.createElement('canvas');c.width=W;c.height=H;const x=c.getContext('2d');
      const fr=10; // frame border width

      if(bif){
        // ═══ BIFACIAL MONO-PERC — blue cells, silver busbars, silver frame ═══
        // Silver aluminum frame
        x.fillStyle='#b8b8b8';x.fillRect(0,0,W,H);
        // Backsheet (dark between cells)
        x.fillStyle='#0a0e1a';x.fillRect(fr,fr,W-fr*2,H-fr*2);

        // Cell grid: 6 columns × 10 rows (standard 120 half-cut cell layout)
        const cols=6,rows=10;
        const cellGap=2.5; // gap between cells
        const aw=W-fr*2,ah=H-fr*2;
        const cw=(aw-(cols+1)*cellGap)/cols;
        const ch=(ah-(rows+1)*cellGap)/rows;

        for(let r=0;r<rows;r++){
          for(let cc=0;cc<cols;cc++){
            const cx=fr+cellGap+(cw+cellGap)*cc;
            const cy=fr+cellGap+(ch+cellGap)*r;

            // Base cell color — deep blue with slight variation per cell
            const hue=218+Math.random()*8;
            const sat=65+Math.random()*15;
            const lit=12+Math.random()*5;
            x.fillStyle='hsl('+hue+','+sat+'%,'+lit+'%)';
            x.fillRect(cx,cy,cw,ch);

            // Anti-reflective coating gradient (subtle blue shimmer)
            const grd=x.createLinearGradient(cx,cy,cx+cw,cy+ch);
            grd.addColorStop(0,'rgba(30,60,120,0.15)');
            grd.addColorStop(0.3,'rgba(20,40,90,0.05)');
            grd.addColorStop(0.7,'rgba(40,70,140,0.12)');
            grd.addColorStop(1,'rgba(25,50,110,0.08)');
            x.fillStyle=grd;x.fillRect(cx,cy,cw,ch);

            // 5 horizontal busbars per cell (silver)
            for(let bb=0;bb<5;bb++){
              const by=cy+ch*((bb+1)/6);
              x.fillStyle='rgba(200,200,200,0.22)';
              x.fillRect(cx,by-0.6,cw,1.2);
            }

            // Vertical finger lines (fine, ~20 per cell)
            x.strokeStyle='rgba(180,180,180,0.07)';
            x.lineWidth=0.4;
            const nFingers=20;
            for(let f=0;f<nFingers;f++){
              const fx=cx+cw*((f+0.5)/nFingers);
              x.beginPath();x.moveTo(fx,cy);x.lineTo(fx,cy+ch);x.stroke();
            }
          }
        }

        // Frame edge highlight (3D bevel effect)
        x.fillStyle='rgba(220,220,220,0.4)';
        x.fillRect(0,0,W,3);x.fillRect(0,0,3,H); // top+left highlight
        x.fillStyle='rgba(80,80,80,0.4)';
        x.fillRect(0,H-3,W,3);x.fillRect(W-3,0,3,H); // bottom+right shadow

      }else{
        // ═══ FIRST SOLAR CdTe THIN FILM — uniform black, no cell grid ═══
        // Black frame
        x.fillStyle='#1a1a1a';x.fillRect(0,0,W,H);
        // Near-black panel face
        x.fillStyle='#0c0c0c';x.fillRect(fr,fr,W-fr*2,H-fr*2);

        // Very subtle vertical laser scribe lines (barely visible)
        for(let i=fr+4;i<W-fr;i+=6){
          const opacity=0.03+Math.random()*0.04;
          x.strokeStyle='rgba(30,30,30,'+opacity+')';
          x.lineWidth=0.5;
          x.beginPath();x.moveTo(i,fr);x.lineTo(i,H-fr);x.stroke();
        }

        // Subtle horizontal scribe lines (wider spacing)
        for(let j=fr+40;j<H-fr;j+=42){
          x.strokeStyle='rgba(25,25,25,0.04)';
          x.lineWidth=0.4;
          x.beginPath();x.moveTo(fr,j);x.lineTo(W-fr,j);x.stroke();
        }

        // Very subtle dark gradient (slight sheen variation like the photo)
        const grd=x.createLinearGradient(0,0,W,H);
        grd.addColorStop(0,'rgba(20,20,25,0.08)');
        grd.addColorStop(0.4,'rgba(10,10,12,0.02)');
        grd.addColorStop(0.8,'rgba(15,15,18,0.06)');
        grd.addColorStop(1,'rgba(8,8,10,0.03)');
        x.fillStyle=grd;x.fillRect(fr,fr,W-fr*2,H-fr*2);

        // Frame edge (dark, not silver)
        x.fillStyle='rgba(40,40,40,0.5)';
        x.fillRect(0,0,W,2);x.fillRect(0,0,2,H);
        x.fillStyle='rgba(10,10,10,0.5)';
        x.fillRect(0,H-2,W,2);x.fillRect(W-2,0,2,H);
      }

      const t=new THREE.CanvasTexture(c);t.encoding=THREE.sRGBEncoding;return t;
    }
    function mkGroundTex(){
      const c=document.createElement('canvas');c.width=512;c.height=512;const x=c.getContext('2d');
      x.fillStyle='#8a9455';x.fillRect(0,0,512,512);
      for(let i=0;i<3000;i++){const px=Math.random()*512,py=Math.random()*512,sz=1+Math.random()*4;
        x.fillStyle='hsl('+Math.floor(75+Math.random()*30)+','+Math.floor(30+Math.random()*25)+'%,'+Math.floor(30+Math.random()*18)+'%)';
        x.fillRect(px,py,sz,sz);}
      for(let i=0;i<20;i++){x.fillStyle='rgba('+Math.floor(130+Math.random()*30)+','+Math.floor(115+Math.random()*25)+','+Math.floor(80+Math.random()*20)+',0.3)';x.beginPath();x.arc(Math.random()*512,Math.random()*512,10+Math.random()*30,0,Math.PI*2);x.fill();}
      const t=new THREE.CanvasTexture(c);t.wrapS=t.wrapT=THREE.RepeatWrapping;t.repeat.set(12,12);t.encoding=THREE.sRGBEncoding;return t;
    }
    function mkGravelTex(){
      const c=document.createElement('canvas');c.width=256;c.height=256;const x=c.getContext('2d');
      x.fillStyle='#b5ad98';x.fillRect(0,0,256,256);
      for(let i=0;i<2000;i++){x.fillStyle='hsl(40,15%,'+Math.floor(60+Math.random()*20)+'%)';x.fillRect(Math.random()*256,Math.random()*256,.5+Math.random()*2,.5+Math.random()*2);}
      const t=new THREE.CanvasTexture(c);t.wrapS=t.wrapT=THREE.RepeatWrapping;t.encoding=THREE.sRGBEncoding;return t;
    }

    // ═══════════════════════════════════════════════════════════════
    //  BUILD SOLAR SITE — all equipment, infrastructure, environment
    // ═══════════════════════════════════════════════════════════════
    function svBuildSite(sc, inv, dc, comb, isBi) {
      const R=()=>Math.random();

      // Ground
      const gG=new THREE.PlaneGeometry(800,800,60,60);const gP=gG.attributes.position;
      for(let i=0;i<gP.count;i++){const gx=gP.getX(i),gz=gP.getY(i);gP.setZ(i,Math.sin(gx*.04)*Math.cos(gz*.05)*.4+Math.sin(gx*.11+gz*.09)*.15)}
      gG.computeVertexNormals();
      const gnd=new THREE.Mesh(gG,new THREE.MeshStandardMaterial({map:mkGroundTex(),roughness:.92,metalness:0}));gnd.rotation.x=-Math.PI/2;gnd.receiveShadow=true;sc.add(gnd);

      // Materials
      const pTex=mkPanelTex(isBi);
      const M={
        pnl:new THREE.MeshStandardMaterial({map:pTex,roughness:isBi?0.08:0.15,metalness:isBi?0.6:0.3,envMapIntensity:isBi?0.9:0.3}),
        frame:new THREE.MeshStandardMaterial({color:0xC0C0C0,roughness:.25,metalness:.85}),
        steel:new THREE.MeshStandardMaterial({color:0x909090,roughness:.3,metalness:.9}),
        galv:new THREE.MeshStandardMaterial({color:0xA8B0A8,roughness:.35,metalness:.75}),
        dc:new THREE.MeshStandardMaterial({color:0xBB2020,roughness:.55,metalness:.1}),
        ac:new THREE.MeshStandardMaterial({color:0xDD7711,roughness:.45,metalness:.15}),
        inv:new THREE.MeshStandardMaterial({color:0x181818,roughness:.35,metalness:.35}),
        invD:new THREE.MeshStandardMaterial({color:0x222222,roughness:.4,metalness:.3}),
        conc:new THREE.MeshStandardMaterial({color:0xA5A5A0,roughness:.88,metalness:0}),
        tx:new THREE.MeshStandardMaterial({color:0x2563EB,roughness:.28,metalness:.45}),
        txFin:new THREE.MeshStandardMaterial({color:0x2050B0,roughness:.3,metalness:.5}),
        fence:new THREE.MeshStandardMaterial({color:0x888888,roughness:.45,metalness:.75,transparent:true,opacity:.3,side:THREE.DoubleSide}),
        fP:new THREE.MeshStandardMaterial({color:0x777777,roughness:.4,metalness:.8}),
        comb:new THREE.MeshStandardMaterial({color:0x505050,roughness:.4,metalness:.55}),
        warn:new THREE.MeshBasicMaterial({color:0xFFCC00}),
        led:new THREE.MeshBasicMaterial({color:0x22DD44}),
        bush:new THREE.MeshStandardMaterial({color:0x4a6830,roughness:.9,metalness:0}),
        bark:new THREE.MeshStandardMaterial({color:0x5a3a20,roughness:.95,metalness:0}),
        canopy:new THREE.MeshStandardMaterial({color:0x3a6a28,roughness:.85,metalness:0}),
        white:new THREE.MeshStandardMaterial({color:0xEEEEEE,roughness:.5,metalness:.05}),
        bldg:new THREE.MeshStandardMaterial({color:0xC8C0B0,roughness:.8,metalness:.05}),
        roof:new THREE.MeshStandardMaterial({color:0x666666,roughness:.4,metalness:.6}),
      };

      // Constants — 1P Portrait Single-Axis Tracker
      const ROWS=16,RS=8.5,TILT=22*Math.PI/180,PW=1.13,PH=2.28,PD=.035,GAP=.04;
      const PPR=isBi?110:95;
      const RL=PPR*(PW+GAP),X0=-RL/2,Z0=-(ROWS*RS)/2,HUB=3.4;

      // Gravel pad helper
      const gvT=mkGravelTex();
      function gpad(cx,cz,w,d){const m=new THREE.Mesh(new THREE.PlaneGeometry(w,d),new THREE.MeshStandardMaterial({map:gvT.clone(),roughness:.82,metalness:.05}));m.material.map.repeat.set(w/8,d/8);m.material.map.wrapS=m.material.map.wrapT=THREE.RepeatWrapping;m.rotation.x=-Math.PI/2;m.position.set(cx,.09,cz);m.receiveShadow=true;sc.add(m)}

      // ─── PANELS (InstancedMesh) ───
      const totP=ROWS*PPR;const pGeo=new THREE.BoxGeometry(PW,PH,PD);
      const panels=new THREE.InstancedMesh(pGeo,M.pnl,totP);panels.castShadow=true;panels.receiveShadow=true;
      const dm=new THREE.Object3D();let idx=0;
      for(let r=0;r<ROWS;r++){const rz=Z0+r*RS;for(let c=0;c<PPR;c++){dm.position.set(X0+c*(PW+GAP)+PW/2,HUB+Math.sin(TILT)*PH*.5,rz);dm.rotation.set(-TILT,0,0);dm.updateMatrix();panels.setMatrixAt(idx++,dm.matrix)}}
      panels.instanceMatrix.needsUpdate=true;sc.add(panels);

      // ─── RACKING ───
      for(let r=0;r<ROWS;r++){
        const rz=Z0+r*RS;
        const tt=new THREE.Mesh(new THREE.CylinderGeometry(.055,.055,RL+1.5,8),M.galv);tt.rotation.z=Math.PI/2;tt.position.set(0,HUB,rz);tt.castShadow=true;sc.add(tt);
        const pSp=4*(PW+GAP),nP=Math.floor(RL/pSp)+1;
        for(let p=0;p<nP;p++){
          const px=X0+p*pSp;
          const pile=new THREE.Mesh(new THREE.BoxGeometry(.10,4.2,.06),M.steel);pile.position.set(px,HUB/2-.1,rz);pile.castShadow=true;sc.add(pile);
          sc.add(new THREE.Mesh(new THREE.BoxGeometry(.04,4,.14),M.steel).translateX(px-.05).translateY(HUB/2-.1).translateZ(rz));
          sc.add(new THREE.Mesh(new THREE.BoxGeometry(.04,4,.14),M.steel).translateX(px+.05).translateY(HUB/2-.1).translateZ(rz));
          sc.add(new THREE.Mesh(new THREE.BoxGeometry(.22,.06,.22),M.steel).translateX(px).translateY(HUB).translateZ(rz));
        }
        const mot=new THREE.Mesh(new THREE.BoxGeometry(.6,.45,.35),M.invD);mot.position.set(0,HUB-.3,rz);mot.castShadow=true;sc.add(mot);
        sc.add(new THREE.Mesh(new THREE.SphereGeometry(.03,6,6),M.led).translateX(-.2).translateY(HUB-.15).translateZ(rz-.18));
        const mrG=new THREE.CylinderGeometry(.02,.02,RL+.5,4);
        const mr1=new THREE.Mesh(mrG,M.frame);mr1.rotation.z=Math.PI/2;mr1.position.set(0,HUB+Math.sin(TILT)*PH*.85,rz-Math.cos(TILT)*.4);sc.add(mr1);
        const mr2=new THREE.Mesh(mrG.clone(),M.frame);mr2.rotation.z=Math.PI/2;mr2.position.set(0,HUB-Math.sin(TILT)*PH*.1,rz+Math.cos(TILT)*.4);sc.add(mr2);
      }

      // ─── DC COLLECTION ───
      // Position depends on inverter type for proper routing
      const CE=RL/2+8; // Collection edge
      const DIX=X0-12; // Distributed inverter X position (west of array)
      const CIX=RL/2+35; // Central/Cluster inverter X position (east of array)
      
      // Wire materials
      const wireBlack=new THREE.MeshStandardMaterial({color:0x0a0a0a,roughness:.55,metalness:.15});
      const wireRed=new THREE.MeshStandardMaterial({color:0xaa2222,roughness:.55,metalness:.15});
      const conduitGray=new THREE.MeshStandardMaterial({color:0x606060,roughness:.4,metalness:.6});
      const conduitPVC=new THREE.MeshStandardMaterial({color:0x4a4a4a,roughness:.7,metalness:.1});
      
      // String sizing (available for all configs)
      const stringLen=isBi?28:6; // 28 modules/string for bifacial, 6 for First Solar
      const nStringsPerRow=Math.floor(PPR/stringLen);
      
      if(dc==='string-homeruns'){
        // ═══ STRING HOMERUNS ═══
        // Individual 10 AWG string wires from each string termination
        // Each string = 2 wires (+ and -) run as homerun pair
        // Routed via underground PVC conduits to inverter
        
        for(let r=0;r<ROWS;r++){
          const rz=Z0+r*RS;
          
          // ═══ STRING TERMINATION BOXES ═══
          for(let s=0;s<nStringsPerRow;s++){
            const sx=X0+s*(RL/nStringsPerRow)+RL/(nStringsPerRow*2);
            
            // String junction box mounted on tracker (weatherproof NEMA 4)
            const sjb=new THREE.Mesh(new THREE.BoxGeometry(.30,.18,.14),
              new THREE.MeshStandardMaterial({color:0x2a2a2a,roughness:.45,metalness:.5}));
            sjb.position.set(sx,HUB-.55,rz+.22);sjb.castShadow=true;sc.add(sjb);
            // Junction box lid
            sc.add(new THREE.Mesh(new THREE.BoxGeometry(.28,.16,.01),
              new THREE.MeshStandardMaterial({color:0x3a3a3a,roughness:.35,metalness:.55})).translateX(sx).translateY(HUB-.55).translateZ(rz+.15));
            // Screws on lid (4 corners)
            for(let scr=0;scr<4;scr++){
              const scrX=sx+((scr%2)-.5)*.2;
              const scrY=HUB-.55+((Math.floor(scr/2))-.5)*.12;
              sc.add(new THREE.Mesh(new THREE.CylinderGeometry(.012,.012,.02,6),M.steel).translateX(scrX).translateY(scrY).translateZ(rz+.14));
            }
            // Cable entry glands (top - from panels)
            for(let g=0;g<2;g++){
              sc.add(new THREE.Mesh(new THREE.CylinderGeometry(.018,.022,.06,6),M.steel).translateX(sx-.08+g*.16).translateY(HUB-.45).translateZ(rz+.22));
            }
            
            // Module interconnect cables (coming from panels above)
            const mCable1=new THREE.Mesh(new THREE.CylinderGeometry(.008,.008,.35,4),wireRed);
            mCable1.position.set(sx-.06,HUB-.28,rz+.15);mCable1.rotation.x=.2;sc.add(mCable1);
            const mCable2=new THREE.Mesh(new THREE.CylinderGeometry(.008,.008,.35,4),wireBlack);
            mCable2.position.set(sx+.06,HUB-.28,rz+.15);mCable2.rotation.x=.2;sc.add(mCable2);
            
            // Flex conduit drop from junction box to ground
            const flexH=HUB-.7;
            const flex=new THREE.Mesh(new THREE.CylinderGeometry(.025,.025,flexH,8),conduitGray);
            flex.position.set(sx,flexH/2+.05,rz+.28);sc.add(flex);
            // Conduit connector at top
            sc.add(new THREE.Mesh(new THREE.CylinderGeometry(.032,.028,.05,8),M.steel).translateX(sx).translateY(HUB-.65).translateZ(rz+.28));
            
            // ═══ HOMERUN ROUTING ═══
            if(inv==='distributed'){
              // Route WEST to distributed inverters
              const hrLen=sx-DIX;
              
              // Underground PVC conduit (visible as slight raised bump)
              const conduit=new THREE.Mesh(new THREE.CylinderGeometry(.035,.035,hrLen,6),conduitPVC);
              conduit.rotation.z=Math.PI/2;conduit.position.set(sx-hrLen/2,.04,rz+.35);sc.add(conduit);
              
              // Positive wire inside (partially visible at ends)
              const wireP=new THREE.Mesh(new THREE.CylinderGeometry(.012,.012,hrLen*.98,4),wireRed);
              wireP.rotation.z=Math.PI/2;wireP.position.set(sx-hrLen/2,.04,rz+.33);sc.add(wireP);
              // Negative wire
              const wireN=new THREE.Mesh(new THREE.CylinderGeometry(.012,.012,hrLen*.98,4),wireBlack);
              wireN.rotation.z=Math.PI/2;wireN.position.set(sx-hrLen/2,.04,rz+.37);sc.add(wireN);
              
              // Conduit sweep at junction box (90° elbow)
              sc.add(new THREE.Mesh(new THREE.TorusGeometry(.08,.025,6,8,Math.PI/2),conduitPVC).translateX(sx-.08).translateY(.12).translateZ(rz+.28).rotateZ(Math.PI).rotateY(Math.PI/2));
            }else{
              // Route EAST to centralized combiners
              const hrLen=CE-sx+8;
              const conduit=new THREE.Mesh(new THREE.CylinderGeometry(.035,.035,hrLen,6),conduitPVC);
              conduit.rotation.z=Math.PI/2;conduit.position.set(sx+hrLen/2,.04,rz+.35);sc.add(conduit);
              const wireP=new THREE.Mesh(new THREE.CylinderGeometry(.012,.012,hrLen*.98,4),wireRed);
              wireP.rotation.z=Math.PI/2;wireP.position.set(sx+hrLen/2,.04,rz+.33);sc.add(wireP);
              const wireN=new THREE.Mesh(new THREE.CylinderGeometry(.012,.012,hrLen*.98,4),wireBlack);
              wireN.rotation.z=Math.PI/2;wireN.position.set(sx+hrLen/2,.04,rz+.37);sc.add(wireN);
            }
          }
          
          // ═══ DC TRENCH (visible gravel cover) ═══
          if(inv==='distributed'){
            // Trench runs from array to inverter row (west)
            const trenchLen=X0-DIX+15;
            const trenchMat=new THREE.MeshStandardMaterial({color:0x6b5c4a,roughness:.92,metalness:0});
            const trench=new THREE.Mesh(new THREE.BoxGeometry(trenchLen,.03,1.8),trenchMat);
            trench.position.set(DIX+trenchLen/2-5,.015,rz+.35);trench.receiveShadow=true;sc.add(trench);
            // Trench warning tape (yellow stripe)
            if(r%4===0){
              sc.add(new THREE.Mesh(new THREE.BoxGeometry(trenchLen,.005,.15),M.warn).translateX(DIX+trenchLen/2-5).translateY(.035).translateZ(rz+.35));
            }
          }
        }
        
        // ═══ GROUND ROD & EQUIPMENT GROUNDING ═══
        if(inv==='distributed'){
          // Ground rods near each inverter position
          for(let r=0;r<ROWS;r+=2){
            const rz=Z0+r*RS+RS/2;
            // Ground rod (copper-clad steel)
            const gRod=new THREE.Mesh(new THREE.CylinderGeometry(.012,.012,1.2,6),
              new THREE.MeshStandardMaterial({color:0xb87333,roughness:.4,metalness:.7}));
            gRod.position.set(DIX-2.5,.6,rz+1);sc.add(gRod);
            // Ground wire to rod
            const gWire=new THREE.Mesh(new THREE.CylinderGeometry(.008,.008,1.5,4),
              new THREE.MeshStandardMaterial({color:0x00aa00,roughness:.5,metalness:.3}));
            gWire.rotation.z=Math.PI/4;gWire.position.set(DIX-1.8,.4,rz+.8);sc.add(gWire);
          }
        }
        
        // Main DC collection conduit (for centralized only)
        if(inv!=='distributed'){
          const mainConduit=new THREE.Mesh(new THREE.CylinderGeometry(.15,.15,ROWS*RS+12,10),conduitPVC);
          mainConduit.position.set(CE+5,(ROWS*RS+12)/2*.02+.15,0);sc.add(mainConduit);
        }
        
      }else if(dc==='harnesses'){
        // ═══ HARNESSES (Y-CONNECTORS) ═══
        // Pre-fabricated cable assemblies mounted ON the tracker structure
        // Y-connectors combine strings at source before routing
        // Cables run along torque tube
        
        for(let r=0;r<ROWS;r++){
          const rz=Z0+r*RS;
          
          // Main harness cables running along torque tube
          // Positive conductor (red)
          const harnP=new THREE.Mesh(new THREE.CylinderGeometry(.045,.045,RL*.94,6),M.dc);
          harnP.rotation.z=Math.PI/2;harnP.position.set(0,HUB-.42,rz+.28);harnP.castShadow=true;sc.add(harnP);
          // Negative conductor (black)
          const harnN=new THREE.Mesh(new THREE.CylinderGeometry(.045,.045,RL*.94,6),
            new THREE.MeshStandardMaterial({color:0x0a0a0a,roughness:.5,metalness:.15}));
          harnN.rotation.z=Math.PI/2;harnN.position.set(0,HUB-.50,rz+.28);sc.add(harnN);
          
          // Y-connector junction boxes along harness (combine 2 strings each)
          const nYconn=Math.floor(PPR/14); // ~7-8 Y-connectors per row
          for(let y=0;y<nYconn;y++){
            const yx=X0+RL*.06+y*(RL*.88/nYconn);
            // Y-connector box
            const ybox=new THREE.Mesh(new THREE.BoxGeometry(.22,.14,.14),
              new THREE.MeshStandardMaterial({color:0x1a1a1a,roughness:.45,metalness:.5}));
            ybox.position.set(yx,HUB-.46,rz+.32);sc.add(ybox);
            // Input cables from string (small wires going up to panels)
            for(let inp=0;inp<2;inp++){
              const icable=new THREE.Mesh(new THREE.CylinderGeometry(.01,.01,.35,3),M.dc);
              icable.position.set(yx-.06+inp*.12,HUB-.28,rz+.1);sc.add(icable);
            }
            // Cable tie/support
            sc.add(new THREE.Mesh(new THREE.BoxGeometry(.04,.02,.18),M.steel).translateX(yx).translateY(HUB-.38).translateZ(rz+.28));
          }
          
          // Harness termination box (end of row)
          const termX=inv==='distributed'?X0-.5:RL/2+1.5;
          const termBox=new THREE.Mesh(new THREE.BoxGeometry(.35,.25,.2),
            new THREE.MeshStandardMaterial({color:0x252525,roughness:.4,metalness:.45}));
          termBox.position.set(termX,HUB-.45,rz+.28);sc.add(termBox);
          
          // Drop cable from harness termination to ground/inverter
          const dropH=inv==='distributed'?HUB-.2:HUB-.3;
          const dropCable=new THREE.Mesh(new THREE.CylinderGeometry(.05,.05,dropH,6),M.dc);
          dropCable.position.set(termX,HUB-.45-dropH/2,rz+.3);sc.add(dropCable);
          
          // Ground routing
          if(inv!=='distributed'){
            // Route east to combiner area
            const groundRun=new THREE.Mesh(new THREE.CylinderGeometry(.06,.06,CE-termX+5,6),M.dc);
            groundRun.rotation.z=Math.PI/2;groundRun.position.set((termX+CE)/2+2,.15,rz+.4);sc.add(groundRun);
          }
        }
        
        // Main DC collection riser (for centralized configs)
        if(inv!=='distributed'){
          sc.add(new THREE.Mesh(new THREE.CylinderGeometry(.14,.14,ROWS*RS+12,8),M.dc).translateX(CE+4).translateY(.3));
          // Horizontal feed to combiner/inverter area
          const hFeed=new THREE.Mesh(new THREE.CylinderGeometry(.14,.14,CIX-CE-5,8),M.dc);
          hFeed.rotation.z=Math.PI/2;hFeed.position.set((CE+CIX)/2,.3,0);sc.add(hFeed);
        }
        
      }else if(dc==='trunk-bus'){
        // ═══ TRUNK BUS ═══
        // Elevated DC bus bars running along array rows
        // Strings tap into trunk via tap boxes
        // High-capacity copper/aluminum bus system on steel supports
        
        const bLen=ROWS*RS+14;
        const busY=2.2; // Bus height
        
        // ═══ MAIN BUS BARS (center of array) ═══
        // Positive bus (red/copper)
        const busP=new THREE.Mesh(new THREE.BoxGeometry(.12,bLen,.08),
          new THREE.MeshStandardMaterial({color:0xCC3333,roughness:.2,metalness:.75}));
        busP.rotation.x=Math.PI/2;busP.position.set(-.25,busY,0);busP.castShadow=true;sc.add(busP);
        // Negative bus (black/aluminum)
        const busN=new THREE.Mesh(new THREE.BoxGeometry(.12,bLen,.08),
          new THREE.MeshStandardMaterial({color:0x1a1a1a,roughness:.2,metalness:.7}));
        busN.rotation.x=Math.PI/2;busN.position.set(.25,busY,0);busN.castShadow=true;sc.add(busN);
        
        // Bus support structures
        const nSupp=Math.ceil(bLen/5);
        for(let s=0;s<nSupp;s++){
          const sz=Z0-5+s*5;
          // Steel H-frame support
          const postL=new THREE.Mesh(new THREE.BoxGeometry(.1,busY,.08),M.steel);
          postL.position.set(-.6,busY/2,sz);postL.castShadow=true;sc.add(postL);
          const postR=new THREE.Mesh(new THREE.BoxGeometry(.1,busY,.08),M.steel);
          postR.position.set(.6,busY/2,sz);postR.castShadow=true;sc.add(postR);
          // Cross beam
          sc.add(new THREE.Mesh(new THREE.BoxGeometry(1.4,.08,.08),M.steel).translateY(busY+.06).translateZ(sz));
          // Insulator standoffs (ceramic)
          const insulatorMat=new THREE.MeshStandardMaterial({color:0xE8DCC0,roughness:.35,metalness:.1});
          sc.add(new THREE.Mesh(new THREE.CylinderGeometry(.04,.06,.2,8),insulatorMat).translateX(-.25).translateY(busY+.16).translateZ(sz));
          sc.add(new THREE.Mesh(new THREE.CylinderGeometry(.04,.06,.2,8),insulatorMat).translateX(.25).translateY(busY+.16).translateZ(sz));
        }
        
        // Tap boxes for each row (where strings connect to bus)
        for(let r=0;r<ROWS;r++){
          const rz=Z0+r*RS;
          // Tap box (fused connection point)
          const tapBox=new THREE.Mesh(new THREE.BoxGeometry(.45,.35,.25),M.comb);
          tapBox.position.set(0,busY+.35,rz);tapBox.castShadow=true;sc.add(tapBox);
          // Status indicator
          sc.add(new THREE.Mesh(new THREE.SphereGeometry(.025,6,6),M.led).translateX(.15).translateY(busY+.55).translateZ(rz-.1));
          // Warning label
          sc.add(new THREE.Mesh(new THREE.BoxGeometry(.15,.08,.01),M.warn).translateX(-.1).translateY(busY+.55).translateZ(rz-.13));
          
          // String tap cables running from tracker to bus
          const nTaps=4; // 4 tap points per row
          for(let t=0;t<nTaps;t++){
            const tx=X0+RL*.15+t*(RL*.7/nTaps);
            // Vertical drop from bus to ground level at tap point
            const tapCable=new THREE.Mesh(new THREE.CylinderGeometry(.02,.02,busY-.3,4),M.dc);
            tapCable.position.set(tx,(busY-.3)/2+.15,rz-.2);sc.add(tapCable);
            // Horizontal run along ground from tap to bus center
            const horizTap=new THREE.Mesh(new THREE.CylinderGeometry(.02,.02,Math.abs(tx),4),M.dc);
            horizTap.rotation.z=Math.PI/2;horizTap.position.set(tx/2,.12,rz-.2);sc.add(horizTap);
          }
        }
        
        // Bus extension to LBD area
        const busExtLen=CE+15;
        const busExtP=new THREE.Mesh(new THREE.BoxGeometry(busExtLen,.08,.1),
          new THREE.MeshStandardMaterial({color:0xCC3333,roughness:.2,metalness:.75}));
        busExtP.position.set(busExtLen/2-5,1.5,Z0-8);busExtP.castShadow=true;sc.add(busExtP);
        const busExtN=new THREE.Mesh(new THREE.BoxGeometry(busExtLen,.08,.1),
          new THREE.MeshStandardMaterial({color:0x1a1a1a,roughness:.2,metalness:.7}));
        busExtN.position.set(busExtLen/2-5,1.5,Z0-9);busExtN.castShadow=true;sc.add(busExtN);
        // Extension supports
        for(let es=0;es<Math.floor(busExtLen/8);es++){
          const esx=es*8+3;
          sc.add(new THREE.Mesh(new THREE.CylinderGeometry(.06,.08,1.6,6),M.steel).translateX(esx).translateY(.8).translateZ(Z0-8.5));
        }
      }

      // ─── DC COMBINATION ───
      // Equipment placement depends on configuration
      
      if(comb==='combiner-boxes'){
        // ═══ COMBINER BOXES ═══
        // SolarBOS / Shoals style NEMA 4X combiner boxes
        // Pole-mounted, stainless steel enclosures
        // Fused inputs with monitoring
        
        const nCB=inv==='central'?14:10; // Combiners based on config
        const cbX=CE+8; // Combiner X position
        
        for(let i=0;i<nCB;i++){
          const cbZ=Z0+4+(i/(nCB-1))*(ROWS-2)*RS;
          
          // ═══ MOUNTING STRUCTURE ═══
          // Concrete pier foundation
          const pier=new THREE.Mesh(new THREE.CylinderGeometry(.2,.25,.6,8),M.conc);
          pier.position.set(cbX,.3,cbZ);sc.add(pier);
          
          // Galvanized steel pole (Schedule 40)
          const pole=new THREE.Mesh(new THREE.CylinderGeometry(.065,.065,3.8,8),
            new THREE.MeshStandardMaterial({color:0x909498,roughness:.35,metalness:.7}));
          pole.position.set(cbX,2.5,cbZ);pole.castShadow=true;sc.add(pole);
          
          // Pole cap
          sc.add(new THREE.Mesh(new THREE.SphereGeometry(.07,8,6,0,Math.PI*2,0,Math.PI/2),
            new THREE.MeshStandardMaterial({color:0x909498,roughness:.35,metalness:.7})).translateX(cbX).translateY(4.42).translateZ(cbZ));
          
          // Mounting bracket (unistrut)
          sc.add(new THREE.Mesh(new THREE.BoxGeometry(.9,.08,.12),
            new THREE.MeshStandardMaterial({color:0x909498,roughness:.4,metalness:.65})).translateX(cbX).translateY(4.1).translateZ(cbZ));
          sc.add(new THREE.Mesh(new THREE.BoxGeometry(.08,.35,.08),
            new THREE.MeshStandardMaterial({color:0x909498,roughness:.4,metalness:.65})).translateX(cbX-.38).translateY(3.95).translateZ(cbZ));
          sc.add(new THREE.Mesh(new THREE.BoxGeometry(.08,.35,.08),
            new THREE.MeshStandardMaterial({color:0x909498,roughness:.4,metalness:.65})).translateX(cbX+.38).translateY(3.95).translateZ(cbZ));
          
          // ═══ COMBINER BOX ENCLOSURE ═══
          // Main body (304 stainless steel)
          const cbBody=new THREE.Mesh(new THREE.BoxGeometry(.95,.75,.45),
            new THREE.MeshStandardMaterial({color:0x8a8a8a,roughness:.28,metalness:.72}));
          cbBody.position.set(cbX,3.55,cbZ);cbBody.castShadow=true;sc.add(cbBody);
          
          // Lid/door (with drip edge)
          const lid=new THREE.Mesh(new THREE.BoxGeometry(.92,.72,.025),
            new THREE.MeshStandardMaterial({color:0x7a7a7a,roughness:.25,metalness:.75}));
          lid.position.set(cbX,3.55,cbZ-.238);sc.add(lid);
          
          // Drip edge (rain hood)
          sc.add(new THREE.Mesh(new THREE.BoxGeometry(.96,.08,.06),
            new THREE.MeshStandardMaterial({color:0x7a7a7a,roughness:.25,metalness:.75})).translateX(cbX).translateY(3.95).translateZ(cbZ-.27));
          
          // Piano hinge (left side)
          sc.add(new THREE.Mesh(new THREE.BoxGeometry(.04,.68,.03),
            new THREE.MeshStandardMaterial({color:0x606060,roughness:.4,metalness:.6})).translateX(cbX-.44).translateY(3.55).translateZ(cbZ-.24));
          
          // Quarter-turn latches (2)
          for(let lt=0;lt<2;lt++){
            // Latch body
            sc.add(new THREE.Mesh(new THREE.CylinderGeometry(.025,.025,.04,8),M.steel).translateX(cbX+.35).translateY(3.35+lt*.4).translateZ(cbZ-.26).rotateX(Math.PI/2));
            // Latch handle
            sc.add(new THREE.Mesh(new THREE.BoxGeometry(.06,.015,.02),M.steel).translateX(cbX+.35).translateY(3.35+lt*.4).translateZ(cbZ-.28));
          }
          
          // Padlock hasp
          sc.add(new THREE.Mesh(new THREE.BoxGeometry(.04,.1,.02),M.steel).translateX(cbX+.35).translateY(3.55).translateZ(cbZ-.27));
          
          // ═══ FRONT PANEL DETAILS ═══
          // Manufacturer logo plate
          sc.add(new THREE.Mesh(new THREE.BoxGeometry(.35,.08,.002),M.white).translateX(cbX-.15).translateY(3.85).translateZ(cbZ-.252));
          
          // Rating/data plate
          sc.add(new THREE.Mesh(new THREE.BoxGeometry(.25,.15,.002),
            new THREE.MeshStandardMaterial({color:0xd0d0d0,roughness:.3,metalness:.5})).translateX(cbX+.25).translateY(3.25).translateZ(cbZ-.252));
          
          // ═══ STATUS INDICATORS ═══
          // Monitoring module window
          sc.add(new THREE.Mesh(new THREE.BoxGeometry(.4,.12,.01),
            new THREE.MeshStandardMaterial({color:0x1a1a1a,roughness:.1,metalness:.3})).translateX(cbX-.1).translateY(3.7).translateZ(cbZ-.252));
          
          // String status LEDs (8 inputs shown)
          for(let led=0;led<8;led++){
            const ledColor = led < 7 ? 0x22dd44 : 0xffaa00; // One amber for visual interest
            sc.add(new THREE.Mesh(new THREE.SphereGeometry(.012,6,6),
              new THREE.MeshBasicMaterial({color:ledColor})).translateX(cbX-.28+led*.045).translateY(3.7).translateZ(cbZ-.26));
          }
          
          // ═══ SAFETY LABELS ═══
          // Arc flash warning (orange)
          sc.add(new THREE.Mesh(new THREE.BoxGeometry(.2,.12,.002),
            new THREE.MeshStandardMaterial({color:0xff6600,roughness:.5,metalness:.1})).translateX(cbX-.25).translateY(3.4).translateZ(cbZ-.252));
          
          // High voltage warning (yellow)
          sc.add(new THREE.Mesh(new THREE.BoxGeometry(.15,.1,.002),M.warn).translateX(cbX+.05).translateY(3.4).translateZ(cbZ-.252));
          
          // ═══ CABLE ENTRIES ═══
          // Bottom cable glands (liquidtight connectors) - 8 DC inputs
          for(let g=0;g<8;g++){
            // Gland body
            sc.add(new THREE.Mesh(new THREE.CylinderGeometry(.022,.028,.08,8),
              new THREE.MeshStandardMaterial({color:0x404040,roughness:.5,metalness:.4})).translateX(cbX-.35+g*.1).translateY(3.12).translateZ(cbZ));
            // Gland nut
            sc.add(new THREE.Mesh(new THREE.CylinderGeometry(.03,.03,.02,6),M.steel).translateX(cbX-.35+g*.1).translateY(3.06).translateZ(cbZ));
            // Input cable (coming from ground)
            sc.add(new THREE.Mesh(new THREE.CylinderGeometry(.015,.015,.6,4),wireRed).translateX(cbX-.35+g*.1).translateY(2.78).translateZ(cbZ));
          }
          
          // Output cable glands (bottom, larger for combined output)
          for(let out=0;out<2;out++){
            sc.add(new THREE.Mesh(new THREE.CylinderGeometry(.035,.04,.1,8),
              new THREE.MeshStandardMaterial({color:0x404040,roughness:.5,metalness:.4})).translateX(cbX-.08+out*.16).translateY(3.1).translateZ(cbZ+.18));
            // Output cables
            sc.add(new THREE.Mesh(new THREE.CylinderGeometry(.025,.025,.65,6),
              out===0?wireRed:wireBlack).translateX(cbX-.08+out*.16).translateY(2.75).translateZ(cbZ+.18));
          }
          
          // ═══ GROUNDING ═══
          // Ground lug (green/yellow)
          sc.add(new THREE.Mesh(new THREE.BoxGeometry(.05,.03,.03),
            new THREE.MeshStandardMaterial({color:0x44aa44,roughness:.4,metalness:.5})).translateX(cbX+.42).translateY(3.2).translateZ(cbZ));
          // Ground wire down pole
          sc.add(new THREE.Mesh(new THREE.CylinderGeometry(.008,.008,2.5,4),
            new THREE.MeshStandardMaterial({color:0x00aa00,roughness:.5,metalness:.3})).translateX(cbX+.08).translateY(2.0).translateZ(cbZ+.05));
          
          // ═══ SURGE PROTECTION ═══
          // SPD module on side
          sc.add(new THREE.Mesh(new THREE.BoxGeometry(.08,.15,.06),
            new THREE.MeshStandardMaterial({color:0x2255aa,roughness:.4,metalness:.35})).translateX(cbX+.5).translateY(3.55).translateZ(cbZ));
          sc.add(new THREE.Mesh(new THREE.SphereGeometry(.012,5,5),M.led).translateX(cbX+.5).translateY(3.65).translateZ(cbZ-.03));
        }
        
        // ═══ DC OUTPUT TRENCH TO INVERTER ═══
        const trenchLen=CIX-cbX;
        // Main trench
        sc.add(new THREE.Mesh(new THREE.BoxGeometry(trenchLen,.04,2.5),
          new THREE.MeshStandardMaterial({color:0x5a5045,roughness:.9,metalness:0})).translateX(cbX+trenchLen/2).translateY(.02).translateZ(0));
        // Conduit runs in trench
        for(let run=0;run<3;run++){
          sc.add(new THREE.Mesh(new THREE.CylinderGeometry(.06,.06,trenchLen,6),conduitPVC).translateX(cbX+trenchLen/2).translateY(.08).translateZ(-.6+run*.6).rotateZ(Math.PI/2));
        }
        
      }else if(comb==='lbds'){
        // ═══ LBDs (LOAD BREAK DISCONNECTS) ═══
        // Large DC disconnect enclosures
        // Aggregate trunk bus feeds before inverters
        // Include visible disconnect handles and safety equipment
        
        const nLBD=6;
        const lbdX=CE+12;
        
        for(let i=0;i<nLBD;i++){
          const lbdZ=Z0+4+(i/(nLBD-1))*(ROWS-2)*RS;
          
          // Concrete equipment pad
          gpad(lbdX,lbdZ,5,4);
          
          // LBD enclosure (large industrial cabinet)
          const lbdBody=new THREE.Mesh(new THREE.BoxGeometry(1.8,2.2,1.3),
            new THREE.MeshStandardMaterial({color:0x3a3a3a,roughness:.4,metalness:.55}));
          lbdBody.position.set(lbdX,1.2,lbdZ);lbdBody.castShadow=true;sc.add(lbdBody);
          
          // Ventilation louvers (top)
          for(let v=0;v<5;v++){
            sc.add(new THREE.Mesh(new THREE.BoxGeometry(1.4,.05,.02),M.invD).translateX(lbdX).translateY(1.85+v*.1).translateZ(lbdZ-.67));
          }
          
          // Main disconnect handle (RED - visible safety feature)
          const handleGrp=new THREE.Group();
          const handleBase=new THREE.Mesh(new THREE.BoxGeometry(.2,.12,.08),M.steel);
          handleBase.position.set(.75,1.5,-.6);handleGrp.add(handleBase);
          const handleArm=new THREE.Mesh(new THREE.BoxGeometry(.1,.55,.12),
            new THREE.MeshStandardMaterial({color:0xDD0000,roughness:.35,metalness:.4}));
          handleArm.position.set(.75,1.8,-.65);handleArm.rotation.z=-.25;handleGrp.add(handleArm);
          const handleGrip=new THREE.Mesh(new THREE.CylinderGeometry(.04,.04,.18,8),
            new THREE.MeshStandardMaterial({color:0xDD0000,roughness:.4,metalness:.35}));
          handleGrip.rotation.x=Math.PI/2;handleGrip.position.set(.75,2.05,-.72);handleGrp.add(handleGrip);
          handleGrp.position.set(lbdX,0,lbdZ);sc.add(handleGrp);
          
          // Position indicator (ON/OFF)
          sc.add(new THREE.Mesh(new THREE.BoxGeometry(.15,.25,.02),
            new THREE.MeshStandardMaterial({color:0x00aa00,roughness:.3,metalness:.2})).translateX(lbdX+.55).translateY(1.4).translateZ(lbdZ-.67));
          
          // Warning stripes (yellow/black)
          for(let w=0;w<4;w++){
            sc.add(new THREE.Mesh(new THREE.BoxGeometry(1.82,.06,.01),M.warn).translateX(lbdX).translateY(.3+w*.55).translateZ(lbdZ-.67));
          }
          
          // Arc flash warning label
          sc.add(new THREE.Mesh(new THREE.BoxGeometry(.5,.35,.01),
            new THREE.MeshStandardMaterial({color:0xff6600,roughness:.5,metalness:.1})).translateX(lbdX-.45).translateY(1.9).translateZ(lbdZ-.67));
          
          // Nameplate
          sc.add(new THREE.Mesh(new THREE.BoxGeometry(.6,.2,.01),M.white).translateX(lbdX-.4).translateY(.7).translateZ(lbdZ-.67));
          
          // Cable entry points (bottom)
          sc.add(new THREE.Mesh(new THREE.CylinderGeometry(.08,.08,.15,8),M.steel).translateX(lbdX-.5).translateY(.08).translateZ(lbdZ));
          sc.add(new THREE.Mesh(new THREE.CylinderGeometry(.08,.08,.15,8),M.steel).translateX(lbdX+.5).translateY(.08).translateZ(lbdZ));
          
          // Output conduit to inverter
          const outConduit=new THREE.Mesh(new THREE.CylinderGeometry(.1,.1,CIX-lbdX-8,6),M.dc);
          outConduit.rotation.z=Math.PI/2;outConduit.position.set((lbdX+CIX)/2,.2,lbdZ);sc.add(outConduit);
        }
      }
      // comb==='none' — DC goes directly to inverter (distributed configs)

      // ─── INVERTERS ───
      const IX=CIX; // Use centralized position variable
      
      if(inv==='distributed'){
        // ═══ DISTRIBUTED STRING INVERTERS ═══
        // Commercial string inverters (like SMA Sunny Tripower 50/60)
        // Mounted on galvanized steel stands near each tracker row pair
        // DC combining happens INSIDE the inverter (4-6 MPPT inputs)
        
        for(let r=0;r<ROWS;r+=2){
          const rz=Z0+r*RS+RS/2;
          const ix=DIX; // West side of array
          
          // ═══ EQUIPMENT PAD ═══
          gpad(ix,rz,5,4);
          
          // Concrete equipment pad edge/curb
          const padEdge=new THREE.Mesh(new THREE.BoxGeometry(5.2,.15,4.2),
            new THREE.MeshStandardMaterial({color:0x888880,roughness:.85,metalness:.05}));
          padEdge.position.set(ix,.075,rz);sc.add(padEdge);
          
          // ═══ INVERTER MOUNTING STAND ═══
          // Galvanized steel unistrut frame
          const standMat=new THREE.MeshStandardMaterial({color:0x8a9090,roughness:.35,metalness:.75});
          // Vertical posts (4 corners)
          for(let p=0;p<4;p++){
            const px=ix+((p%2)-.5)*1.4;
            const pz=rz+((Math.floor(p/2))-.5)*.6;
            const post=new THREE.Mesh(new THREE.BoxGeometry(.06,1.6,.06),standMat);
            post.position.set(px,.85,pz);post.castShadow=true;sc.add(post);
            // Base plate
            sc.add(new THREE.Mesh(new THREE.BoxGeometry(.15,.02,.15),standMat).translateX(px).translateY(.12).translateZ(pz));
            // Anchor bolt
            sc.add(new THREE.Mesh(new THREE.CylinderGeometry(.015,.015,.08,6),M.steel).translateX(px).translateY(.08).translateZ(pz));
          }
          // Horizontal rails (top)
          sc.add(new THREE.Mesh(new THREE.BoxGeometry(1.5,.05,.05),standMat).translateX(ix).translateY(1.62).translateZ(rz-.28));
          sc.add(new THREE.Mesh(new THREE.BoxGeometry(1.5,.05,.05),standMat).translateX(ix).translateY(1.62).translateZ(rz+.28));
          // Cross bracing
          sc.add(new THREE.Mesh(new THREE.BoxGeometry(.04,.04,.7),standMat).translateX(ix-.65).translateY(.9).translateZ(rz));
          sc.add(new THREE.Mesh(new THREE.BoxGeometry(.04,.04,.7),standMat).translateX(ix+.65).translateY(.9).translateZ(rz));
          
          // ═══ INVERTER ENCLOSURE ═══
          const invBody=new THREE.Mesh(new THREE.BoxGeometry(1.3,1.0,.55),M.inv);
          invBody.position.set(ix,1.15,rz);invBody.castShadow=true;sc.add(invBody);
          
          // Heat sink fins (extruded aluminum - both sides)
          for(let f=0;f<15;f++){
            sc.add(new THREE.Mesh(new THREE.BoxGeometry(.018,.85,.52),M.invD).translateX(ix+.58+f*.008).translateY(1.15).translateZ(rz));
            sc.add(new THREE.Mesh(new THREE.BoxGeometry(.018,.85,.52),M.invD).translateX(ix-.58-f*.008).translateY(1.15).translateZ(rz));
          }
          
          // Front panel (powder coated steel)
          const frontPanel=new THREE.Mesh(new THREE.BoxGeometry(1.25,.92,.02),
            new THREE.MeshStandardMaterial({color:0x1a1a1a,roughness:.2,metalness:.5}));
          frontPanel.position.set(ix,1.15,rz-.285);sc.add(frontPanel);
          
          // LCD display with bezel
          sc.add(new THREE.Mesh(new THREE.BoxGeometry(.48,.28,.015),
            new THREE.MeshStandardMaterial({color:0x151515,roughness:.15,metalness:.4})).translateX(ix-.25).translateY(1.28).translateZ(rz-.295));
          // LCD screen (slight blue glow)
          sc.add(new THREE.Mesh(new THREE.BoxGeometry(.42,.22,.005),
            new THREE.MeshStandardMaterial({color:0x0a2848,roughness:.05,metalness:.1,emissive:0x051525,emissiveIntensity:.3})).translateX(ix-.25).translateY(1.28).translateZ(rz-.3));
          
          // Status LED indicators (5 LEDs with labels)
          const ledData=[{c:0x22dd44,l:'RUN'},{c:0x22dd44,l:'GRID'},{c:0x22dd44,l:'DC'},{c:0x2288ff,l:'COM'},{c:0xffaa00,l:'WARN'}];
          for(let l=0;l<5;l++){
            // LED
            sc.add(new THREE.Mesh(new THREE.SphereGeometry(.015,6,6),
              new THREE.MeshBasicMaterial({color:ledData[l].c})).translateX(ix-.38+l*.09).translateY(1.52).translateZ(rz-.295));
            // LED housing ring
            sc.add(new THREE.Mesh(new THREE.TorusGeometry(.018,.004,6,12),
              new THREE.MeshStandardMaterial({color:0x333333,roughness:.3,metalness:.6})).translateX(ix-.38+l*.09).translateY(1.52).translateZ(rz-.295));
          }
          
          // DC Disconnect switch (RED rotary handle)
          const dcDisc=new THREE.Group();
          sc.add(new THREE.Mesh(new THREE.BoxGeometry(.14,.18,.03),
            new THREE.MeshStandardMaterial({color:0x2a2a2a,roughness:.4,metalness:.45})).translateX(ix-.48).translateY(1.05).translateZ(rz-.295));
          sc.add(new THREE.Mesh(new THREE.CylinderGeometry(.04,.04,.025,12),
            new THREE.MeshStandardMaterial({color:0xcc0000,roughness:.35,metalness:.4})).translateX(ix-.48).translateY(1.05).translateZ(rz-.31).rotateX(Math.PI/2));
          sc.add(new THREE.Mesh(new THREE.BoxGeometry(.06,.02,.04),
            new THREE.MeshStandardMaterial({color:0xcc0000,roughness:.35,metalness:.4})).translateX(ix-.48).translateY(1.08).translateZ(rz-.32));
          // "DC DISCONNECT" label
          sc.add(new THREE.Mesh(new THREE.BoxGeometry(.12,.03,.002),M.warn).translateX(ix-.48).translateY(.93).translateZ(rz-.296));
          
          // AC Disconnect switch (BLACK handle)
          sc.add(new THREE.Mesh(new THREE.BoxGeometry(.14,.18,.03),
            new THREE.MeshStandardMaterial({color:0x2a2a2a,roughness:.4,metalness:.45})).translateX(ix+.48).translateY(1.05).translateZ(rz-.295));
          sc.add(new THREE.Mesh(new THREE.CylinderGeometry(.04,.04,.025,12),
            new THREE.MeshStandardMaterial({color:0x1a1a1a,roughness:.35,metalness:.4})).translateX(ix+.48).translateY(1.05).translateZ(rz-.31).rotateX(Math.PI/2));
          sc.add(new THREE.Mesh(new THREE.BoxGeometry(.06,.02,.04),
            new THREE.MeshStandardMaterial({color:0x1a1a1a,roughness:.35,metalness:.4})).translateX(ix+.48).translateY(1.08).translateZ(rz-.32));
          
          // Manufacturer logo plate
          sc.add(new THREE.Mesh(new THREE.BoxGeometry(.35,.08,.002),M.white).translateX(ix+.3).translateY(.78).translateZ(rz-.296));
          
          // Rating/nameplate
          sc.add(new THREE.Mesh(new THREE.BoxGeometry(.25,.12,.002),
            new THREE.MeshStandardMaterial({color:0xc0c0c0,roughness:.3,metalness:.6})).translateX(ix-.3).translateY(.78).translateZ(rz-.296));
          
          // ═══ DC INPUT CONDUITS (from string homeruns) ═══
          const nInputs=Math.min(nStringsPerRow,6);
          for(let d=0;d<Math.min(nInputs,6);d++){
            // PVC conduit stub-up from ground
            const condX=ix-.4+d*.15;
            sc.add(new THREE.Mesh(new THREE.CylinderGeometry(.025,.025,.45,6),conduitPVC).translateX(condX).translateY(.32).translateZ(rz+.15));
            // Conduit connector (liquidtight)
            sc.add(new THREE.Mesh(new THREE.CylinderGeometry(.032,.028,.06,8),M.steel).translateX(condX).translateY(.56).translateZ(rz+.15));
            // Flex conduit to inverter bottom
            sc.add(new THREE.Mesh(new THREE.CylinderGeometry(.022,.022,.18,6),conduitGray).translateX(condX).translateY(.66).translateZ(rz+.05).rotateX(.4));
          }
          
          // ═══ AC OUTPUT CONDUIT ═══
          // Rigid metal conduit from inverter to AC trench
          const acCondLen=3;
          sc.add(new THREE.Mesh(new THREE.CylinderGeometry(.04,.04,acCondLen,8),conduitGray).translateX(ix+acCondLen/2+1).translateY(.25).translateZ(rz).rotateZ(Math.PI/2));
          // Conduit supports
          for(let cs=0;cs<2;cs++){
            sc.add(new THREE.Mesh(new THREE.BoxGeometry(.06,.15,.1),standMat).translateX(ix+1.5+cs*1.2).translateY(.18).translateZ(rz));
          }
          // LB conduit body (junction)
          sc.add(new THREE.Mesh(new THREE.BoxGeometry(.12,.12,.08),conduitGray).translateX(ix+.7).translateY(.62).translateZ(rz));
          // Vertical conduit from inverter to LB
          sc.add(new THREE.Mesh(new THREE.CylinderGeometry(.035,.035,.35,6),conduitGray).translateX(ix+.7).translateY(.42).translateZ(rz));
          
          // ═══ SURGE PROTECTION DEVICE ═══
          sc.add(new THREE.Mesh(new THREE.BoxGeometry(.12,.18,.08),
            new THREE.MeshStandardMaterial({color:0x2255aa,roughness:.4,metalness:.35})).translateX(ix+.2).translateY(1.05).translateZ(rz+.25));
          sc.add(new THREE.Mesh(new THREE.SphereGeometry(.015,5,5),M.led).translateX(ix+.2).translateY(1.16).translateZ(rz+.21));
        }
        
        // ═══ AC COLLECTION TRENCH (runs east to AC panel) ═══
        const acTrenchMat=new THREE.MeshStandardMaterial({color:0x5a5045,roughness:.88,metalness:0});
        for(let r=0;r<ROWS;r+=2){
          const rz=Z0+r*RS+RS/2;
          // Individual AC run from each inverter
          const acRunLen=IX-DIX-20;
          sc.add(new THREE.Mesh(new THREE.BoxGeometry(acRunLen,.025,1),acTrenchMat).translateX(DIX+5+acRunLen/2).translateY(.015).translateZ(rz));
          // AC cable (480V 3-phase)
          sc.add(new THREE.Mesh(new THREE.CylinderGeometry(.035,.035,acRunLen,6),M.ac).translateX(DIX+5+acRunLen/2).translateY(.08).translateZ(rz).rotateZ(Math.PI/2));
        }
        // Main AC collection trench (north-south)
        const mainAcTrench=new THREE.Mesh(new THREE.BoxGeometry(2,.03,ROWS*RS+8),acTrenchMat);
        mainAcTrench.position.set(IX-18,.015,0);sc.add(mainAcTrench);
        // Main AC conduit bundle
        sc.add(new THREE.Mesh(new THREE.CylinderGeometry(.12,.12,ROWS*RS+6,8),M.ac).translateX(IX-18).translateY(.15));
        
        // ═══ AC COLLECTION PANEL / RECOMBINER ═══
        gpad(IX-12,0,12,16);
        
        // AC recombiner enclosure (NEMA 3R outdoor)
        const acPanel=new THREE.Mesh(new THREE.BoxGeometry(4,2.8,1.6),
          new THREE.MeshStandardMaterial({color:0x454545,roughness:.4,metalness:.55}));
        acPanel.position.set(IX-12,1.5,0);acPanel.castShadow=true;sc.add(acPanel);
        
        // Panel doors (2 sections)
        for(let door=0;door<2;door++){
          sc.add(new THREE.Mesh(new THREE.BoxGeometry(1.8,2.5,.03),
            new THREE.MeshStandardMaterial({color:0x3a3a3a,roughness:.35,metalness:.5})).translateX(IX-12.9+door*1.9).translateY(1.4).translateZ(-.82));
          // Door handles
          sc.add(new THREE.Mesh(new THREE.BoxGeometry(.08,.25,.06),M.steel).translateX(IX-12.1+door*1.9).translateY(1.4).translateZ(-.86));
          // Padlock hasps
          sc.add(new THREE.Mesh(new THREE.BoxGeometry(.06,.12,.03),M.steel).translateX(IX-12.1+door*1.9).translateY(1.0).translateZ(-.86));
        }
        
        // Ventilation louvers (top)
        for(let v=0;v<6;v++){
          sc.add(new THREE.Mesh(new THREE.BoxGeometry(3.5,.06,.02),M.invD).translateX(IX-12).translateY(2.55+v*.08).translateZ(-.82));
        }
        
        // Status indicators
        for(let l=0;l<4;l++){
          sc.add(new THREE.Mesh(new THREE.SphereGeometry(.025,6,6),M.led).translateX(IX-13.5+l*.35).translateY(2.65).translateZ(-.84));
        }
        
        // Warning label
        sc.add(new THREE.Mesh(new THREE.BoxGeometry(.6,.25,.01),M.warn).translateX(IX-11).translateY(2.0).translateZ(-.82));
        
        // Nameplate
        sc.add(new THREE.Mesh(new THREE.BoxGeometry(.8,.2,.01),M.white).translateX(IX-12.8).translateY(.5).translateZ(-.82));
        
        // AC output to step-up transformer
        const toXfmr=new THREE.Mesh(new THREE.CylinderGeometry(.08,.08,12,8),M.ac);
        toXfmr.rotation.z=Math.PI/2;toXfmr.position.set(IX-6,.2,0);sc.add(toXfmr);
        
        // ═══ STEP-UP TRANSFORMER (480V to 34.5kV) ═══
        gpad(IX+5,0,14,12);
        
        // Transformer pad
        sc.add(new THREE.Mesh(new THREE.BoxGeometry(10,.4,8),M.conc).translateX(IX+5).translateY(.2).translateZ(0));
        
        // Transformer tank
        const stepUpTx=new THREE.Mesh(new THREE.BoxGeometry(5,3.5,3.5),M.tx);
        stepUpTx.position.set(IX+5,2.0,0);stepUpTx.castShadow=true;sc.add(stepUpTx);
        
        // Transformer cooling radiators
        for(let side=-1;side<=1;side+=2){
          for(let f=0;f<8;f++){
            sc.add(new THREE.Mesh(new THREE.BoxGeometry(.06,2.8,.08),M.txFin).translateX(IX+7.8+f*.18).translateY(1.8).translateZ(side*2));
          }
        }
        
        // Conservator tank
        sc.add(new THREE.Mesh(new THREE.CylinderGeometry(.35,.35,3,10),M.tx).translateX(IX+5).translateY(4.5).translateZ(0).rotateZ(Math.PI/2));
        
        // HV bushings
        for(let b=0;b<3;b++){
          sc.add(new THREE.Mesh(new THREE.CylinderGeometry(.12,.18,2,10),
            new THREE.MeshStandardMaterial({color:0xDDCCA0,roughness:.35,metalness:.2})).translateX(IX+4+b*1).translateY(4.8).translateZ(-2.2));
          for(let shed=0;shed<4;shed++){
            sc.add(new THREE.Mesh(new THREE.CylinderGeometry(.22,.18,.08,12),
              new THREE.MeshStandardMaterial({color:0xDDCCA0,roughness:.35,metalness:.2})).translateX(IX+4+b*1).translateY(4.0+shed*.45).translateZ(-2.2));
          }
        }
        
        // LV bushings
        for(let b=0;b<3;b++){
          sc.add(new THREE.Mesh(new THREE.CylinderGeometry(.08,.12,1.2,8),
            new THREE.MeshStandardMaterial({color:0xDDCCA0,roughness:.35,metalness:.2})).translateX(IX+4+b*1).translateY(4.2).translateZ(2.2));
        }
        
      }else if(inv==='centralized-cluster'){
        // ═══ CENTRALIZED STRING INVERTER CLUSTERS ═══
        // String inverters grouped on common skid/pad
        // 6 inverter units arranged 2 rows × 3 columns
        // Includes MV step-up transformer
        
        gpad(IX,0,40,32);
        
        // Inverter skids (6 units in 2×3 arrangement)
        for(let row=0;row<2;row++){
          for(let col=0;col<3;col++){
            const skidX=IX-12+col*12;
            const skidZ=-8+row*16;
            
            // Main inverter cabinet
            const cabinet=new THREE.Mesh(new THREE.BoxGeometry(6.5,3.0,3.5),M.inv);
            cabinet.position.set(skidX,1.6,skidZ);cabinet.castShadow=true;sc.add(cabinet);
            
            // Vertical cooling fins
            for(let f=0;f<14;f++){
              sc.add(new THREE.Mesh(new THREE.BoxGeometry(.04,2.7,3.52),M.invD).translateX(skidX-2.8+f*.45).translateY(1.6).translateZ(skidZ));
            }
            
            // Control panel section (door)
            sc.add(new THREE.Mesh(new THREE.BoxGeometry(1.4,2.4,.04),
              new THREE.MeshStandardMaterial({color:0x252525,roughness:.3,metalness:.45})).translateX(skidX-2.0).translateY(1.4).translateZ(skidZ-1.78));
            
            // HMI touchscreen
            sc.add(new THREE.Mesh(new THREE.BoxGeometry(.7,.5,.02),
              new THREE.MeshStandardMaterial({color:0x0a2040,roughness:.05,metalness:.1})).translateX(skidX-2.0).translateY(2.0).translateZ(skidZ-1.8));
            
            // Ventilation louver panel
            for(let v=0;v<4;v++){
              sc.add(new THREE.Mesh(new THREE.BoxGeometry(4,.08,.03),M.invD).translateX(skidX+.8).translateY(2.5+v*.15).translateZ(skidZ-1.78));
            }
            
            // Status beacon (tower light)
            const beacon=new THREE.Mesh(new THREE.CylinderGeometry(.06,.06,.2,8),M.led);
            beacon.position.set(skidX+2.8,3.25,skidZ-1.5);sc.add(beacon);
            
            // AC output terminal box
            sc.add(new THREE.Mesh(new THREE.BoxGeometry(.9,.7,.6),M.comb).translateX(skidX+2.5).translateY(.45).translateZ(skidZ+1.5));
          }
        }
        
        // Medium voltage transformer (step-up)
        const mvtX=IX+12;
        sc.add(new THREE.Mesh(new THREE.BoxGeometry(.15,4,.15),M.conc).translateX(mvtX).translateY(0).translateZ(0));
        const mvt=new THREE.Mesh(new THREE.BoxGeometry(4.5,3.2,2.8),M.tx);
        mvt.position.set(mvtX,1.7,0);mvt.castShadow=true;sc.add(mvt);
        // Transformer cooling radiators
        for(let f=0;f<8;f++){
          sc.add(new THREE.Mesh(new THREE.BoxGeometry(.1,2.5,2.85),M.txFin).translateX(mvtX+2.5+f*.22).translateY(1.7).translateZ(0));
        }
        // HV bushings
        const bushMat=new THREE.MeshStandardMaterial({color:0xE0D4B0,roughness:.35,metalness:.15});
        for(let b=0;b<3;b++){
          sc.add(new THREE.Mesh(new THREE.CylinderGeometry(.12,.16,1.8,8),bushMat).translateX(mvtX-1+b*1).translateY(4.2).translateZ(0));
        }
        
      }else if(inv==='central'){
        // ═══ CENTRAL INVERTER ═══
        // Large single inverter station
        // Utility-scale central inverter building
        // Typically 2-4 MW capacity per unit
        
        gpad(IX,0,36,26);
        
        // Main inverter building/enclosure
        const invBldg=new THREE.Mesh(new THREE.BoxGeometry(22,5.5,12),M.inv);
        invBldg.position.set(IX,2.85,0);invBldg.castShadow=true;sc.add(invBldg);
        
        // Cooling fins (full length)
        for(let f=0;f<20;f++){
          sc.add(new THREE.Mesh(new THREE.BoxGeometry(.05,5.0,12.02),M.invD).translateX(IX-9.5+f*1.0).translateY(2.85).translateZ(0));
        }
        
        // Access doors (3 along front)
        for(let d=0;d<3;d++){
          sc.add(new THREE.Mesh(new THREE.BoxGeometry(2.0,3.5,.06),
            new THREE.MeshStandardMaterial({color:0x252525,roughness:.35,metalness:.4})).translateX(IX-7+d*7).translateY(1.85).translateZ(-6.04));
          // Door handles
          sc.add(new THREE.Mesh(new THREE.CylinderGeometry(.02,.02,.3,4),M.steel).translateX(IX-7+d*7+.7).translateY(1.7).translateZ(-6.08));
        }
        
        // Roof-mounted cooling units (6 units)
        for(let c=0;c<6;c++){
          const cuX=IX-8+c*3.2;
          const cu=new THREE.Mesh(new THREE.BoxGeometry(2.8,1.4,2.8),
            new THREE.MeshStandardMaterial({color:0x454545,roughness:.35,metalness:.5}));
          cu.position.set(cuX,6.3,0);cu.castShadow=true;sc.add(cu);
          // Fan shroud
          sc.add(new THREE.Mesh(new THREE.CylinderGeometry(.95,.95,.12,16),
            new THREE.MeshStandardMaterial({color:0x555555,roughness:.3,metalness:.55})).translateX(cuX).translateY(7.05).translateZ(0));
        }
        
        // Control room section (attached)
        const ctrlRoom=new THREE.Mesh(new THREE.BoxGeometry(6,5,5),M.bldg);
        ctrlRoom.position.set(IX+14,2.6,0);ctrlRoom.castShadow=true;sc.add(ctrlRoom);
        // Control room window
        sc.add(new THREE.Mesh(new THREE.BoxGeometry(1.5,1.8,.06),
          new THREE.MeshStandardMaterial({color:0x88AACC,roughness:.1,metalness:.2,transparent:true,opacity:.6})).translateX(IX+14).translateY(3.0).translateZ(-2.54));
        // Control room door
        sc.add(new THREE.Mesh(new THREE.BoxGeometry(1.2,2.4,.06),
          new THREE.MeshStandardMaterial({color:0x445566,roughness:.5,metalness:.35})).translateX(IX+16.5).translateY(1.3).translateZ(-2.54));
        
        // DC input cable tray (from combiners/LBDs)
        const dcTray=new THREE.Mesh(new THREE.BoxGeometry(CE,.25,2.5),
          new THREE.MeshStandardMaterial({color:0x505050,roughness:.55,metalness:.4}));
        dcTray.position.set(IX-CE/2-.5,.15,7);sc.add(dcTray);
        
        // AC output to substation (large cables)
        const acMain=new THREE.Mesh(new THREE.CylinderGeometry(.15,.15,20,8),M.ac);
        acMain.rotation.z=Math.PI/2;acMain.position.set(IX+27,.25,0);sc.add(acMain);
      }

      // ─── SUBSTATION ───
      const SX=IX+55,SZ=-35;
      gpad(SX,SZ,50,45);
      
      // ═══ SUBSTATION GRAVEL BASE ═══
      const subGravel=new THREE.Mesh(new THREE.BoxGeometry(48,.08,42),
        new THREE.MeshStandardMaterial({color:0x9a9085,roughness:.9,metalness:0}));
      subGravel.position.set(SX,.04,SZ);subGravel.receiveShadow=true;sc.add(subGravel);
      
      // ═══ MAIN POWER TRANSFORMER (34.5kV/115kV) ═══
      // Concrete foundation with oil containment
      const txFoundation=new THREE.Mesh(new THREE.BoxGeometry(14,1.2,12),M.conc);
      txFoundation.position.set(SX,.6,SZ);sc.add(txFoundation);
      // Oil containment berm
      sc.add(new THREE.Mesh(new THREE.BoxGeometry(16,.3,14),
        new THREE.MeshStandardMaterial({color:0x888880,roughness:.85,metalness:.05})).translateX(SX).translateY(.15).translateZ(SZ));
      
      // Transformer main tank
      const txfTank=new THREE.Mesh(new THREE.BoxGeometry(8,7,6),M.tx);
      txfTank.position.set(SX,4.7,SZ);txfTank.castShadow=true;sc.add(txfTank);
      
      // Transformer tank details (welds, ribs)
      for(let rib=0;rib<5;rib++){
        sc.add(new THREE.Mesh(new THREE.BoxGeometry(8.02,.08,.15),M.tx).translateX(SX).translateY(2+rib*1.4).translateZ(SZ-3.02));
        sc.add(new THREE.Mesh(new THREE.BoxGeometry(8.02,.08,.15),M.tx).translateX(SX).translateY(2+rib*1.4).translateZ(SZ+3.02));
      }
      
      // Transformer cooling radiators (ONAN type)
      for(let side=-1;side<=1;side+=2){
        // Radiator bank housing
        sc.add(new THREE.Mesh(new THREE.BoxGeometry(3,.3,2.2),M.txFin).translateX(SX+5.8).translateY(5).translateZ(SZ+side*3.2));
        sc.add(new THREE.Mesh(new THREE.BoxGeometry(3,.3,2.2),M.txFin).translateX(SX+5.8).translateY(2).translateZ(SZ+side*3.2));
        // Individual radiator fins
        for(let f=0;f<12;f++){
          const fin=new THREE.Mesh(new THREE.BoxGeometry(.08,5.5,.08),M.txFin);
          fin.position.set(SX+4.5+f*.22,4,SZ+side*3.2);sc.add(fin);
        }
        // Oil headers (top and bottom pipes)
        sc.add(new THREE.Mesh(new THREE.CylinderGeometry(.12,.12,3,8),M.tx).translateX(SX+5.8).translateY(6.8).translateZ(SZ+side*3.2).rotateZ(Math.PI/2));
        sc.add(new THREE.Mesh(new THREE.CylinderGeometry(.12,.12,3,8),M.tx).translateX(SX+5.8).translateY(1.5).translateZ(SZ+side*3.2).rotateZ(Math.PI/2));
      }
      
      // Conservator tank (oil expansion) with accessories
      const consv=new THREE.Mesh(new THREE.CylinderGeometry(.6,.6,5,12),M.tx);
      consv.rotation.z=Math.PI/2;consv.position.set(SX,9.5,SZ);consv.castShadow=true;sc.add(consv);
      // Conservator end caps
      sc.add(new THREE.Mesh(new THREE.SphereGeometry(.6,10,10,0,Math.PI),M.tx).translateX(SX-2.5).translateY(9.5).translateZ(SZ).rotateZ(-Math.PI/2));
      sc.add(new THREE.Mesh(new THREE.SphereGeometry(.6,10,10,0,Math.PI),M.tx).translateX(SX+2.5).translateY(9.5).translateZ(SZ).rotateZ(Math.PI/2));
      // Buchholz relay
      sc.add(new THREE.Mesh(new THREE.CylinderGeometry(.15,.15,.4,8),M.steel).translateX(SX-1).translateY(8.8).translateZ(SZ));
      // Oil level indicator
      sc.add(new THREE.Mesh(new THREE.BoxGeometry(.2,.3,.15),M.white).translateX(SX+1.5).translateY(9.8).translateZ(SZ-.62));
      
      // ═══ HV BUSHINGS (115kV side) ═══
      const bushM=new THREE.MeshStandardMaterial({color:0xE0D4B8,roughness:.32,metalness:.18});
      for(let b=0;b<3;b++){
        const bx=SX-1.8+b*1.8;
        // Main bushing column
        sc.add(new THREE.Mesh(new THREE.CylinderGeometry(.18,.25,4.5,12),bushM).translateX(bx).translateY(10.5).translateZ(SZ-3.5));
        // Bushing sheds (porcelain skirts)
        for(let s=0;s<8;s++){
          const shedR=.4-.02*s;
          sc.add(new THREE.Mesh(new THREE.CylinderGeometry(shedR,shedR-.05,.12,14),bushM).translateX(bx).translateY(8.5+s*.55).translateZ(SZ-3.5));
        }
        // Bushing top terminal
        sc.add(new THREE.Mesh(new THREE.CylinderGeometry(.08,.08,.3,8),M.steel).translateX(bx).translateY(13).translateZ(SZ-3.5));
      }
      
      // ═══ LV BUSHINGS (34.5kV side) ═══
      for(let b=0;b<3;b++){
        const bx=SX-1.8+b*1.8;
        sc.add(new THREE.Mesh(new THREE.CylinderGeometry(.12,.18,2.5,10),bushM).translateX(bx).translateY(9.5).translateZ(SZ+4));
        for(let s=0;s<4;s++){
          sc.add(new THREE.Mesh(new THREE.CylinderGeometry(.28,.24,.1,12),bushM).translateX(bx).translateY(8.5+s*.5).translateZ(SZ+4));
        }
      }
      
      // ═══ TRANSFORMER NAMEPLATE & ACCESSORIES ═══
      sc.add(new THREE.Mesh(new THREE.BoxGeometry(1,.6,.02),M.white).translateX(SX-3.5).translateY(3).translateZ(SZ-3.02));
      // Pressure relief device
      sc.add(new THREE.Mesh(new THREE.CylinderGeometry(.15,.12,.25,8),M.steel).translateX(SX+3).translateY(8.2).translateZ(SZ-2.8));
      // Temperature gauges
      sc.add(new THREE.Mesh(new THREE.CylinderGeometry(.1,.1,.08,10),M.white).translateX(SX-2.5).translateY(5).translateZ(SZ-3.05));
      sc.add(new THREE.Mesh(new THREE.CylinderGeometry(.1,.1,.08,10),M.white).translateX(SX-2).translateY(5).translateZ(SZ-3.05));
      
      // ═══ SWITCHGEAR / RELAY BUILDING ═══
      const swgBldg=new THREE.Mesh(new THREE.BoxGeometry(8,4,5),M.bldg);
      swgBldg.position.set(SX-16,2.1,SZ);swgBldg.castShadow=true;sc.add(swgBldg);
      // Roof
      sc.add(new THREE.Mesh(new THREE.BoxGeometry(8.4,.2,5.4),M.roof).translateX(SX-16).translateY(4.2).translateZ(SZ));
      // Door
      sc.add(new THREE.Mesh(new THREE.BoxGeometry(1.2,2.8,.06),
        new THREE.MeshStandardMaterial({color:0x445566,roughness:.45,metalness:.4})).translateX(SX-16).translateY(1.5).translateZ(SZ-2.54));
      // Door handle
      sc.add(new THREE.Mesh(new THREE.CylinderGeometry(.02,.02,.2,4),M.steel).translateX(SX-15.4).translateY(1.5).translateZ(SZ-2.58));
      // Windows
      for(let w=0;w<2;w++){
        sc.add(new THREE.Mesh(new THREE.BoxGeometry(1.2,1,.06),
          new THREE.MeshStandardMaterial({color:0x88AACC,roughness:.1,metalness:.2,transparent:true,opacity:.6})).translateX(SX-18+w*4).translateY(2.8).translateZ(SZ-2.54));
      }
      // HVAC unit
      sc.add(new THREE.Mesh(new THREE.BoxGeometry(1.5,1,1.2),
        new THREE.MeshStandardMaterial({color:0x888888,roughness:.4,metalness:.5})).translateX(SX-12.5).translateY(.6).translateZ(SZ+2));
      
      // ═══ HIGH VOLTAGE BUS STRUCTURE ═══
      const busColors=[0xCC0000,0xFFCC00,0x0066CC]; // R-Y-B phase colors
      
      // A-frame bus supports
      for(let sup=0;sup<4;sup++){
        const supX=SX-12+sup*6;
        // Steel columns
        sc.add(new THREE.Mesh(new THREE.CylinderGeometry(.12,.18,10,6),M.steel).translateX(supX-.8).translateY(5).translateZ(SZ-8));
        sc.add(new THREE.Mesh(new THREE.CylinderGeometry(.12,.18,10,6),M.steel).translateX(supX+.8).translateY(5).translateZ(SZ-8));
        // Cross beam
        sc.add(new THREE.Mesh(new THREE.BoxGeometry(2,.2,.2),M.steel).translateX(supX).translateY(10).translateZ(SZ-8));
        // Diagonal bracing
        sc.add(new THREE.Mesh(new THREE.CylinderGeometry(.05,.05,4,4),M.steel).translateX(supX).translateY(7).translateZ(SZ-8).rotateZ(.4));
      }
      
      // 3-phase bus bars
      for(let phase=0;phase<3;phase++){
        const busBar=new THREE.Mesh(new THREE.CylinderGeometry(.04,.04,24,6),
          new THREE.MeshStandardMaterial({color:busColors[phase],roughness:.25,metalness:.75}));
        busBar.rotation.z=Math.PI/2;busBar.position.set(SX,10.5+phase*.8,SZ-8-phase*.5);sc.add(busBar);
        
        // Suspension insulators
        for(let ins=0;ins<4;ins++){
          sc.add(new THREE.Mesh(new THREE.CylinderGeometry(.08,.12,.6,8),bushM).translateX(SX-12+ins*6).translateY(10+phase*.8).translateZ(SZ-8-phase*.5));
        }
      }
      
      // ═══ CIRCUIT BREAKERS (SF6) ═══
      for(let cb=0;cb<2;cb++){
        const cbX=SX-6+cb*10;
        const cbZ=SZ+12;
        
        // Breaker foundation
        sc.add(new THREE.Mesh(new THREE.BoxGeometry(3,.4,2),M.conc).translateX(cbX).translateY(.2).translateZ(cbZ));
        
        // Breaker tank/mechanism
        const cbTank=new THREE.Mesh(new THREE.BoxGeometry(2,2.8,1.5),
          new THREE.MeshStandardMaterial({color:0x4a4a4a,roughness:.4,metalness:.55}));
        cbTank.position.set(cbX,1.8,cbZ);cbTank.castShadow=true;sc.add(cbTank);
        
        // Breaker operating mechanism
        sc.add(new THREE.Mesh(new THREE.BoxGeometry(1,1.2,.8),M.comb).translateX(cbX).translateY(.9).translateZ(cbZ-.9));
        
        // Breaker bushings (3 phase)
        for(let bp=0;bp<3;bp++){
          sc.add(new THREE.Mesh(new THREE.CylinderGeometry(.1,.14,1.5,8),bushM).translateX(cbX-.6+bp*.6).translateY(3.8).translateZ(cbZ));
        }
        
        // Nameplate
        sc.add(new THREE.Mesh(new THREE.BoxGeometry(.5,.3,.01),M.white).translateX(cbX).translateY(1.5).translateZ(cbZ-.77));
      }
      
      // ═══ DISCONNECT SWITCHES ═══
      for(let ds=0;ds<3;ds++){
        const dsX=SX+8;
        const dsZ=SZ-6+ds*6;
        // Switch base
        sc.add(new THREE.Mesh(new THREE.BoxGeometry(.8,.4,.6),M.conc).translateX(dsX).translateY(.2).translateZ(dsZ));
        // Insulator stack
        sc.add(new THREE.Mesh(new THREE.CylinderGeometry(.1,.14,2,8),bushM).translateX(dsX).translateY(1.4).translateZ(dsZ));
        // Switch blade (open position)
        sc.add(new THREE.Mesh(new THREE.BoxGeometry(.08,1.5,.04),M.steel).translateX(dsX).translateY(2.8).translateZ(dsZ).rotateZ(.6));
      }
      
      // ═══ AC CABLE TRENCH FROM INVERTER/TRANSFORMER ═══
      const acTrenchLen=SX-IX-20;
      sc.add(new THREE.Mesh(new THREE.BoxGeometry(acTrenchLen,.08,2),
        new THREE.MeshStandardMaterial({color:0x5a5045,roughness:.88,metalness:0})).translateX(IX+10+acTrenchLen/2).translateY(.04).translateZ(SZ+20));
      // Cable tray covers
      for(let cov=0;cov<Math.floor(acTrenchLen/3);cov++){
        sc.add(new THREE.Mesh(new THREE.BoxGeometry(2.8,.04,1.8),M.steel).translateX(IX+12+cov*3).translateY(.1).translateZ(SZ+20));
      }
      // Cables in trench
      for(let cab=0;cab<3;cab++){
        sc.add(new THREE.Mesh(new THREE.CylinderGeometry(.06,.06,acTrenchLen,6),M.ac).translateX(IX+10+acTrenchLen/2).translateY(.08).translateZ(SZ+19.4+cab*.3).rotateZ(Math.PI/2));
      }
      
      // ═══ TRANSMISSION STRUCTURES (DEAD-END) ═══
      for(let tower=0;tower<3;tower++){
        const tX=SX+22+tower*28;
        
        // Steel lattice tower (simplified)
        // Main legs
        for(let leg=0;leg<4;leg++){
          const legX=tX+((leg%2)-.5)*1.5;
          const legZ=SZ+((Math.floor(leg/2))-.5)*1.5;
          sc.add(new THREE.Mesh(new THREE.CylinderGeometry(.08,.15,22,6),M.steel).translateX(legX).translateY(11).translateZ(legZ));
        }
        // Cross bracing (X pattern)
        for(let h=0;h<4;h++){
          sc.add(new THREE.Mesh(new THREE.CylinderGeometry(.03,.03,3.5,4),M.steel).translateX(tX).translateY(4+h*5).translateZ(SZ-.75).rotateY(Math.PI/4).rotateX(.5));
          sc.add(new THREE.Mesh(new THREE.CylinderGeometry(.03,.03,3.5,4),M.steel).translateX(tX).translateY(4+h*5).translateZ(SZ+.75).rotateY(-Math.PI/4).rotateX(.5));
        }
        // Cross arm
        const crossArm=new THREE.Mesh(new THREE.BoxGeometry(14,.25,.3),M.steel);
        crossArm.position.set(tX,21,SZ);crossArm.castShadow=true;sc.add(crossArm);
        // Vertical arm extensions
        for(let ext=-1;ext<=1;ext++){
          sc.add(new THREE.Mesh(new THREE.BoxGeometry(.2,2,.2),M.steel).translateX(tX+ext*5).translateY(22).translateZ(SZ));
        }
        
        // Strain insulators on cross arm
        for(let ins=0;ins<3;ins++){
          // Insulator string
          for(let disc=0;disc<6;disc++){
            sc.add(new THREE.Mesh(new THREE.CylinderGeometry(.15,.12,.12,10),bushM).translateX(tX-5+ins*5).translateY(20-disc*.2).translateZ(SZ));
          }
        }
        
        // Transmission conductors (between towers)
        if(tower<2){
          for(let cond=0;cond<3;cond++){
            // Slight sag in conductor
            const condWire=new THREE.Mesh(new THREE.CylinderGeometry(.02,.02,28,4),
              new THREE.MeshBasicMaterial({color:0x333333}));
            condWire.rotation.z=Math.PI/2;
            condWire.position.set(tX+14,19.5-cond*.1,SZ-5+cond*5);
            sc.add(condWire);
          }
        }
      }
      
      // ═══ METERING EQUIPMENT ═══
      sc.add(new THREE.Mesh(new THREE.BoxGeometry(1.5,2.2,1),
        new THREE.MeshStandardMaterial({color:0x606060,roughness:.4,metalness:.5})).translateX(SX-10).translateY(1.2).translateZ(SZ+8));
      sc.add(new THREE.Mesh(new THREE.BoxGeometry(.4,.3,.02),M.white).translateX(SX-10).translateY(1.8).translateZ(SZ+7.48));
      
      // (Substation is within main site perimeter - no separate fence needed)

      // Site boundary reference (used for roads, buildings, vegetation placement)
      const F={x1:X0-22,x2:SX+75,z1:Z0-22,z2:-Z0+22};

      // ─── ROADS ───
      const rdT=mkGravelTex();rdT.repeat.set(1,15);
      const rd1=new THREE.Mesh(new THREE.PlaneGeometry(5,F.z2-F.z1+30),new THREE.MeshStandardMaterial({map:rdT,roughness:.8,metalness:0}));rd1.rotation.x=-Math.PI/2;rd1.position.set(F.x1-5,.07,0);rd1.receiveShadow=true;sc.add(rd1);
      const rdT2=mkGravelTex();rdT2.repeat.set(15,1);
      const rd2=new THREE.Mesh(new THREE.PlaneGeometry(F.x2-F.x1-10,4),new THREE.MeshStandardMaterial({map:rdT2,roughness:.8,metalness:0}));rd2.rotation.x=-Math.PI/2;rd2.position.set((F.x1+F.x2)/2,.06,F.z2-6);rd2.receiveShadow=true;sc.add(rd2);

      // ─── O&M BUILDING ───
      const omX=F.x1+12,omZ=F.z2-10;gpad(omX,omZ,16,12);
      const om=new THREE.Mesh(new THREE.BoxGeometry(12,3.8,8),M.bldg);om.position.set(omX,1.9,omZ);om.castShadow=true;sc.add(om);
      sc.add(new THREE.Mesh(new THREE.BoxGeometry(12.4,.2,8.4),M.roof).translateX(omX).translateY(3.9).translateZ(omZ));
      for(let w=0;w<3;w++)sc.add(new THREE.Mesh(new THREE.BoxGeometry(1.2,1.0,.06),new THREE.MeshStandardMaterial({color:0x88AACC,roughness:.1,metalness:.2,transparent:true,opacity:.6})).translateX(omX-4+w*3).translateY(2.2).translateZ(omZ-4.04));
      sc.add(new THREE.Mesh(new THREE.BoxGeometry(1.6,2.6,.06),new THREE.MeshStandardMaterial({color:0x445566,roughness:.5,metalness:.3})).translateX(omX+3).translateY(1.3).translateZ(omZ-4.04));

      // ─── WEATHER STATION ───
      const wsX=F.x1+6,wsZ=F.z1+6;
      sc.add(new THREE.Mesh(new THREE.CylinderGeometry(.04,.04,7,6),M.steel).translateX(wsX).translateY(3.5).translateZ(wsZ));
      sc.add(new THREE.Mesh(new THREE.CylinderGeometry(.12,.12,.06,10),M.white).translateX(wsX).translateY(7.1).translateZ(wsZ));
      sc.add(new THREE.Mesh(new THREE.SphereGeometry(.1,8,6,0,Math.PI*2,0,Math.PI/2),new THREE.MeshStandardMaterial({color:0xffffff,transparent:true,opacity:.4,roughness:.05,metalness:.1})).translateX(wsX).translateY(7.16).translateZ(wsZ));
      sc.add(new THREE.Mesh(new THREE.BoxGeometry(.4,.6,.25),M.white).translateX(wsX).translateY(2.2).translateZ(wsZ));
      const rc=new THREE.Mesh(new THREE.BoxGeometry(.8,.4,.025),M.pnl);rc.position.set(wsX+1.5,4.5,wsZ);rc.rotation.x=-TILT;sc.add(rc);

      // ─── VEGETATION ───
      function makePine(x,z,scale){
        const t=new THREE.Group();const s=scale||1;
        const totalH=(14+R()*8)*s;const crownStart=totalH*(0.3+R()*0.12);const crownH=totalH-crownStart;const maxRad=(3+R()*1.5)*s;
        const barkMat=new THREE.MeshStandardMaterial({color:new THREE.Color('rgb('+Math.floor(50+R()*20)+','+Math.floor(32+R()*12)+','+Math.floor(18+R()*6)+')'),roughness:0.95});
        const trk=new THREE.Mesh(new THREE.CylinderGeometry(0.06*s,0.18*s,crownStart,6),barkMat);trk.position.y=crownStart/2;trk.castShadow=true;t.add(trk);
        const whorls=5+Math.floor(R()*3);
        for(let w=0;w<whorls;w++){const wF=w/whorls;const wy=crownStart+wF*crownH*0.92;const wR=maxRad*(1-wF*0.85)*(0.85+R()*0.3);
          const branches=3+Math.floor(R()*2);const aOff=w*0.8+R()*1.5;
          for(let b=0;b<branches;b++){const ba=aOff+(b/branches)*Math.PI*2+R()*0.3;
            const nSize=(1.2+R()*0.8)*s*(1-wF*0.5);
            const gV=Math.floor(55+R()*45+(1-wF)*15);
            const needleMat=new THREE.MeshStandardMaterial({color:new THREE.Color('rgb('+Math.floor(25+R()*15)+','+gV+','+Math.floor(12+R()*12)+')'),roughness:0.85});
            const nc=new THREE.Mesh(new THREE.IcosahedronGeometry(nSize,0),needleMat);nc.position.set(Math.cos(ba)*wR*0.75,wy,Math.sin(ba)*wR*0.75);nc.scale.set(1+R()*0.3,0.5+R()*0.3,1+R()*0.3);nc.castShadow=true;t.add(nc);
          }}
        const topMat=new THREE.MeshStandardMaterial({color:new THREE.Color('rgb('+Math.floor(30+R()*15)+','+Math.floor(70+R()*30)+','+Math.floor(15+R()*10)+')'),roughness:0.85});
        t.add(new THREE.Mesh(new THREE.ConeGeometry(0.6*s,2*s,5),topMat).translateY(crownStart+crownH*0.95+0.8*s));
        t.position.set(x,0,z);sc.add(t);
      }
      for(let i=0;i<40;i++){const tx=F.x1-20+i*((F.x2-F.x1+60)/40)+R()*5;makePine(tx,F.z1-12-R()*15,0.5+R()*0.5);if(R()<0.6)makePine(tx+R()*4,F.z1-25-R()*12,0.4+R()*0.5)}
      for(let i=0;i<40;i++){const tx=F.x1-20+i*((F.x2-F.x1+60)/40)+R()*5;makePine(tx,F.z2+12+R()*15,0.5+R()*0.5);if(R()<0.6)makePine(tx+R()*4,F.z2+25+R()*12,0.4+R()*0.5)}
      for(let i=0;i<10;i++)makePine(F.x2+10+R()*30,F.z1+R()*(F.z2-F.z1),0.4+R()*0.5);
      for(let i=0;i<14;i++){const tz=F.z1+i*((F.z2-F.z1)/14)+R()*6;makePine(F.x1-12-R()*18,tz,0.5+R()*0.5)}
      for(let i=0;i<30;i++){const side=Math.floor(R()*4);let bx,bz;
        if(side===0){bx=F.x1-3-R()*4;bz=F.z1+R()*(F.z2-F.z1)}else if(side===1){bx=F.x2+3+R()*4;bz=F.z1+R()*(F.z2-F.z1)}else if(side===2){bx=F.x1+R()*(F.x2-F.x1);bz=F.z1-3-R()*4}else{bx=F.x1+R()*(F.x2-F.x1);bz=F.z2+3+R()*4}
        const bsh=new THREE.Mesh(new THREE.SphereGeometry(0.6+R()*0.4,6,5),M.bush);bsh.position.set(bx,0.4,bz);bsh.scale.y=0.6;bsh.castShadow=true;sc.add(bsh)}
    }




    init();
    initQuiz();
  </script>
</body>
</html>
